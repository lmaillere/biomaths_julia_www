[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Présentation",
    "section": "",
    "text": "Ces pages proposent une introduction à la simulation d’équations différentielles avec Julia, centrée sur la simulation de modèles classiques en dynamique des populations.\nLe document est structuré comme suit :\n\nLa section sur les populations isolées introduit les bases en dimension 1 (modèle de Malthus, modèle logistique et effets Allee)\nla section sur les populations exploitées introduit les diagrammes de bifurcations et la dimension 2 (prélèvements et effets Allee, interactions insectes-oiseaux)\nla section sur les populations en interaction approfondit la dimension 2, notamment via les représentations dans l’espace d’état, et traite des interactions entre populations sous l’angle des modèles proies-prédateurs (modèle de Lotka Volterra et modèle de Rosenzweig MacArthur)\n\nAllons-y !\n\n\n\n\n\nReusehttps://creativecommons.org/licenses/by-nc/4.0/"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "A Propos",
    "section": "",
    "text": "Ces pages ont été générées avec Quarto, et Julia (version 1.9.4).\nLes principaux packages utilisés sont DifferentialEquations.jl, et Plots.jl\n\n\n\n\n\nReusehttps://creativecommons.org/licenses/by-nc/4.0/"
  },
  {
    "objectID": "pop_isolees.html",
    "href": "pop_isolees.html",
    "title": "Populations isolées",
    "section": "",
    "text": "Nous considérons le modèle proposé par Malthus (1798) : \n\\dot x = (n-m)x,\n\\tag{1} avec n le taux de natalité, et m le taux de mortalité.\n\n\nPour simuler ce modèle, c’est à dire intégrer numériquement les solutions au problème de Cauchy correspondant à l’Equation 1 avec x(0)=x_0\\geq0, nous allons utiliser les routines de DifferentialEquations.jl avec la méthode par défaut. Nous utiliserons aussi le package Plots.jl pour les représentations graphiques.\n\nusing Plots, DifferentialEquations\n\n\n\n\nNous définissions la condition initiale de la simulation :\n\nx0 = 0.1\n\nNous définissons les paramètres, et les encapsulons dans un vecteur de paramètres :\n\nn = 3.0     # natalité\nm = 2.0     # morrtalité\npar_malthus = [n, m] # packing\n\nEnfin, les propriétés du temps d’intégration :\n\ntspan = (0.0, 10.0)\ntstep = 0.1\n\n\n\n\nOn définit le modèle comme une fonction renvoyant la dérivée de x (comme SVector) en fonction de l’état, de paramètres, et du temps. L’ordre des arguments est important, c’est sous cette forme que les routines d’intégration attendent le modèle.\n\nfunction malthus(u, p, t)\n    n, m = p        # unpacking\n    x = u[1]        # use x notation\n    dx = (n-m)x     # return derivative\nend\n\n\n\n\nOn commence par définir le problème de Cauchy à intégrer, comme un ODEProblem avec arguments: le modèle, la condition initiale, les bornes d’intégration, les paramètres ainsi que l’option saveat = tstep permettant de récupérer la solution tout les tstep pas de temps (il y a plein d’options de sortie de l’intégration, dont même une fonction du temps !)\n\nprob_malthus = ODEProblem(malthus,          # modèle\n                          x0,               # condition initiale\n                          tspan,            # tspan\n                          par_malthus,      # paramètres\n                          saveat = tstep)   # option de sortie\n\nOn intègre le modèle via solve, défini par DifferentialEquations.jl pour des struct de type ODEProblem :\n\nsol_malthus = solve(prob_malthus)\n\nLe type de solution renvoyée par le solveur est assez complexe et comprend de nombreux champs informatifs sur le calcul. On peut accéder au temps de simulation via sol_malthus.t :\n\nfirst(sol_malthus.t, 3)\n\n3-element Vector{Float64}:\n 0.0\n 0.1\n 0.2\n\n\nainsi qu’aux valeurs de la variable x calculées le long du temps via sol_matlhus.u :\n\nfirst(sol_malthus.u, 3)\n\n3-element Vector{Float64}:\n 0.1\n 0.1105170918098962\n 0.12214028021690636\n\n\nMême si ce n’est pas indispensable, il est possible de transformer la solution renvoyée facilement en DataFrame, qui peut permettre des manipulations plus faciles.\n\nusing DataFrames\n\nsol_malthus = DataFrame(sol_malthus)\nrename!(sol_malthus, :timestamp =&gt; :time, :value =&gt; :x)\n\nsi bien que :\n\nfirst(sol_malthus, 3)\n\n3×2 DataFrame\n\n\n\nRow\ntime\nx\n\n\n\nFloat64\nFloat64\n\n\n\n\n1\n0.0\n0.1\n\n\n2\n0.1\n0.110517\n\n\n3\n0.2\n0.12214\n\n\n\n\n\n\n\n\n\nOn peut représenter graphiquement la simulation de la croissance de la population au cours du temps (ici via le dataframe).\n\nplot(sol_malthus.time, sol_malthus.x,\n    palette = :tab10,\n    linewidth = 2,\n    title = \"\\n Modèle de Malthus \\$n=$n, m=$m\\$\",\n    label = \"population \\$x\\$\",  \n    ylabel = \"densité de population \\$x(t)\\$\", \n    xlabel = \"temps \\$t\\$\",\n    margin = .5Plots.cm,\n    topmargin = 1Plots.cm)"
  },
  {
    "objectID": "pop_interactions.html",
    "href": "pop_interactions.html",
    "title": "Populations en interaction (1)",
    "section": "",
    "text": "Pour débuter cette partie sur les populations en interactions, nous reprenons le modèle de tordeuse de Ludwig, Jones, and Holling (1978) en supposant que la population d’oiseaux réagit (lentement) à la démographie des tordeuses, via la prédation.\nLe changement principal ici est la dimension du modèle (dimension 2) : les tailles de populations de tordeuses x et d’oiseaux y varient toutes deux au cours du temps en s’influençant l’une l’autre, avec une population d’oiseaux qui varie lentement (d’où le paramètre \\varepsilon).\nLe modèle prend la forme :\n\n\\left\\{\n\\begin{array}{l}\n\\displaystyle \\dot x = rx\\left(1-\\frac{x}{K}\\right) - \\frac{\\alpha x^2}{h^2+x^2}\\ y \\\\[.3cm]\n\\displaystyle \\dot y = \\varepsilon \\left(\\frac{n \\alpha x^2}{h^2+x^2}\\ y -m y\\right)\n\\end{array}\n\\right.\n\\tag{1}\nIl faut ajuster un peu la manière de coder pour prendre en compte ces deux dimensions. Commençons par les paramètres divers.\n\nusing DifferentialEquations, Plots, DataFrames\n\n# paramètres\nr = 5.0      # natalité\nK = 10.0     # mortalité\nα = 1.0      # taux max de prédation\nh = 0.5      # constante de demi-saturation\n\nϵ = 0.01     # timescale\nn = 5.0      # gain à la prédation\nm = 3.0      # moralité\n\n\npar_tord_ois = [r, K, α, h, ϵ, n, m] \n\n# temps d'intégration\ntspan = (0.0, 400.0)\ntstep = 0.02\n\n# conditions initiales\nx0 = 1.0    # tordeuses\ny0 = 2.5    # oiseaux\netat0 = [x0, y0]\n\nPuis le modèle :\n\nfunction tord_ois(u, param, t)\n    r, K, α, h, ϵ, n, m = param\n    x = u[1]\n    y = u[2]\n    dx = r*x*(1 - x/K) - α*x^2/(h^2 + x^2) * y\n    dy = ϵ*(n*α*x^2/(h^2 + x^2) * y - m * y)\n    [dx, dy]\nend\n\nProblème d’intégration et simulation :\n\nprob_tord_ois = ODEProblem(tord_ois, \n                           etat0, \n                           tspan, \n                           par_tord_ois, \n                           saveat = tstep)\n\nsol_tord_ois = solve(prob_tord_ois, reltol = 1e-6)\n\nsol_tord_ois = DataFrame(sol_tord_ois)\nrename!(sol_tord_ois, :timestamp =&gt; :time, :value1 =&gt; :x, :value2 =&gt; :y)\n\nReprésentation graphique contre le temps\n\n# color definitions\nmygreen = palette(:tab10)[3]\nmyorange = palette(:tab10)[2]\nmyblue = palette(:tab10)[1]\nmyred = palette(:tab10)[4]\n\nP1 = plot(sol_tord_ois.time, sol_tord_ois.x,\n          color = myblue,\n          linewidth = 2,\n          label = \"tordeuses \\$x\\$\",\n          xlabel = \"temps\",\n          ylabel = \"densités de populations\",\n          title = \"Dynamiques des tordeuses avec\\n population d'oiseaux variable\")\n\nplot!(P1, sol_tord_ois.time, sol_tord_ois.y ./ 2,\n      color = myorange,\n      linewidth = 2,\n      label = \"oiseaux \\$y/2\\$\")\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nOn observe ici des bifurcations dynamiques avec le passage de la population de tordeuse d’une branche d’équilibre stable à l’autre, qui créé un comportement de type cycle d’hysteresis. La situation se comprend bien sur le diagramme de bifurcations (y, x). On retrace le diagramme de bifurcations.\n\n\nCode\nusing Symbolics, Polynomials\n\n@variables X\nD = Differential(X)\n\n# lieu des équilibres positifs\nY = r/(α*X)*(1-X/K)*(h^2+X^2)\n\n# dénominateur de la dérivée\ndnumerator = Symbolics.arguments(Symbolics.value(simplify(expand_derivatives(D(Y)))))[1]\n\n# on récupère les coefficients X^k du polynôme\ncoefs_dict = Symbolics.value(dnumerator).dict\ndd = Dict(Symbolics.degree(first(kv)) =&gt; kv[2] for kv ∈ coefs_dict)\n# on rajoute dans le dictionnaire le coefficient constant\ndd[0] = substitute(dnumerator, Dict(X=&gt;0))\n\n# on définit le polynôme à partir du dictionnaire\ndnumpoly = SparsePolynomial(dd, :X)\n\n# on calcule les racines en filtrant les racines entre 0 et K via une fonction anonyme s-&gt; K &gt; s &gt; 0\ndroots = filter(s -&gt; K &gt; s &gt; 0, roots(dnumpoly))\n\n# vecteur pour le tracé du diagramme de bifurcation\nxplot1 = 0.08:.01:droots[1]\nxplot2 = droots[1]:.01:droots[2]\nxplot3 = droots[2]:.01:K\nyeq1 = r.*(1 .-xplot1./K) ./ (α.*xplot1).*(h^2 .+xplot1.^2)\nyeq2 = r.*(1 .-xplot2./K) ./ (α.*xplot2).*(h^2 .+xplot2.^2)\nyeq3 = r.*(1 .-xplot3./K) ./ (α.*xplot3).*(h^2 .+xplot3.^2)\n\n# diagramme de bifurcations\nPbif = plot(yeq1, xplot1,\n            linewidth = 2,\n            color = mygreen,\n            label = \"équilibres stables\",\n            legend = :left,\n            xlabel = \"population d'oiseaux \\$y\\$\",\n            ylabel = \"population de tordeuses \\$x\\$\",\n            title = \"Diagramme de bifurcations pour le modèle de tordeuses\",\n            margin = .5Plots.cm,\n            topmargin = 1Plots.cm)\n\nplot!(Pbif, yeq2, xplot2,\n      linewidth = 2,\n      color = myred,\n      label = \"équilibres instables\")\n\nplot!(Pbif, yeq3, xplot3,\n      linewidth = 2,\n      color = mygreen,\n      label = \"\")\n\nplot!(Pbif, [0, maximum(yeq1)], [0, 0], \n      color = myred,\n      lw = 2,\n      label = \"\")\n\n\nOn trace sur ce diagramme la trajectoire simulée plus haut :\n\nplot!(Pbif, sol_tord_ois.y, sol_tord_ois.x,\n      color = myblue,\n      linewidth = 2,\n      linealpha = 0.5,\n      label = \"trajectoire\")"
  },
  {
    "objectID": "pop_exploitees.html",
    "href": "pop_exploitees.html",
    "title": "Populations exploitées",
    "section": "",
    "text": "Nous reprenons le modèle précédent sur l’effet Allee mais en prenant en compte des prélèvements externes avec un effort (taux) de prélèvement E : \n\\dot x = r x \\left(\\frac{x}{\\epsilon}-1\\right)\\left(1-\\frac{x}{K}\\right)-Ex.\n\\tag{1}\nLa simulation de ce modèle pour différentes valeurs de E (par exemple E=0.2 ou E=0.85) ne présente aucune difficulté supplémentaire.\nNous allons maintenant nous intéresser à une situation où l’effort de prélèvement E varie au cours du temps entre une valeur soutenable E_s (par exemple 0.2), et une valeur excessive E_x (par exemple 0.85).\nL’attendu théorique est que si les prélèvements sont maintenus à une valeur excessive E_x trop longtemps, la population disparait irrémédiablement même si les prélèvements sont par la suite ramenés à une valeur initialement soutenable E_s.\n\n\n\nusing DifferentialEquations, Plots, DataFrames\n\nDéfinissons une fonction effort() dépendant du temps, qui renvoit :\n\nE_s~ si ~t&lt;T_s\nE_x~ si ~t\\in [T_s+T_x[\nà nouveau E_s~ si ~t\\geq T_s+T_x\n\n\n# paramètres\nE_s = 0.2\nE_x = 0.85\nT_s = 10.0\nT_x = 9.0 \n\npar_effort = [E_s, E_x, T_s, T_x]\n\nfunction effort(t, pars)\n    E_s, E_x, T_s, T_x = pars\n\n    if t &lt; T_s || t &gt;= T_s + T_x\n        return E_s\n    elseif t &gt;= T_s && t &lt; T_s + T_x\n        return E_x\n    end\nend\n\nLa fonction correspond bien à nos hypothèses :\n\n\nCode\ntime2plot = 0: .1: 30\n\nplot(time2plot, [effort(t, par_effort) for t in time2plot],\n     palette = :tab10,\n     linewidth = 2,\n     label = \"\\$E(t)\\$\",\n     xlabel = \"temps\",\n     ylabel = \"\\$E(t)\\$\",\n     title = \"Effort de pêche \\$E(t)\\$\",\n     margin = .5Plots.cm,\n     topmargin = 1Plots.cm)\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNous définissons les paramètres du modèle, la condition initiale et le temps d’intégration :\n\n\nCode\nx0 = 10.\n\ntspan = (0.0, 30.0)\ntstep = 0.1\n\nr = 1.\nK = 10.\nepsilon = 2.                 # seuil de Allee\npar_allee = [r, K, epsilon] # packing\ntspan_allee = (0.0, 3.0)\n\n\nNous définissons le système dynamique comme précédemment, à la différence que nous prévoyons de surcharger l’argument p dans le problème d’intégration sous forme d’un vecteur comprennant :\n\nle vecteur de paramètres par_allee en première position\nle vecteur de paramètres par_effort en seconde position\net la fonction effort en troisième position\n\n\nfunction allee_evar(u, p, t)\n    r, K, epsilon = p[1]        # unpacking model parameters\n    par_effort = p[2]           # unpacking fishing effort parameters\n    E = p[3]                    # unpacking fishing effort function\n    x = u[1]                    # use x notation\n    \n    dx = r*x*(x/epsilon - 1)*(1 - x/K) - E(t, par_effort)*x\nend\n\nL’intégration en elle-même suit le shéma vu précédemment, si ce n’est que l’argument de paramètres doit bien refléter ce qui est attendu par la fonction allee_evar(). La simulation en elle-même est effectuée avec une modification de la précision relative de l’intégration reltol = 1e-6, la précision par défaut n’étant pas suffisante ici.\n\nprob_allee_evar = ODEProblem(allee_evar, \n                             x0, \n                             tspan, \n                             [par_allee, par_effort, effort], \n                             saveat = tstep)\n\nsol_allee_evar = solve(prob_allee_evar, reltol = 1e-6)\n\nsol_allee_evar = DataFrame(sol_allee_evar)\nrename!(sol_allee_evar, :timestamp =&gt; :time, :value =&gt; :x)\n\nFinalement, nous pouvons représenter graphiquement la solution contre le temps. Ici, malgré la perturbation violente induite par la période de surexploitation, le pêcherie retrouve une situation soutenable après un retour à E=E_s.\n\n\nCode\nplot(sol_allee_evar.time, sol_allee_evar.x,\n     label = \"\\$x(t)\\$\",\n     linewidth = 2,\n     xlabel = \"temps\",\n     ylabel = \"densité de population \\$x(t)\\$\",\n     title = \"Effort de pêche variant dans le temps\",\n     palette = :tab10,\n     legend = :left,\n     margin = .5Plots.cm,\n     topmargin = 1Plots.cm)\n\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 1: Persistence dans le modèle avec effet Allee et prélèvements\n\n\n\n\n\nLorsque la période de surexploitation de la population est trop longue (e.g. ici T_x=9.2), la population ne parvient pas à récupérer malgré le retour à un effort de prélèvements soutenable.\n\n\nCode\n# change parameter\nT_x2 = 9.2\n\npar_effort2 = [E_s, E_x, T_s, T_x2]\n\n# define new problem and integrate\nprob_allee_evar2 = ODEProblem(allee_evar, \n                             x0, \n                             tspan, \n                             [par_allee, par_effort2, effort], \n                             saveat = tstep)\n\nsol_allee_evar2 = solve(prob_allee_evar2, reltol = 1e-6)\n\nsol_allee_evar2 = DataFrame(sol_allee_evar2)\nrename!(sol_allee_evar2, :timestamp =&gt; :time, :value =&gt; :x)\n\n# plot\nplot(sol_allee_evar2.time, sol_allee_evar2.x,\n     label = \"\\$x(t)\\$\",\n     linewidth = 2,\n     xlabel = \"temps\",\n     ylabel = \"densité de population \\$x(t)\\$\",\n     title = \"Effort de pêche variant dans le temps\",\n     palette = :tab10,\n     legend = :left,\n     margin = .5Plots.cm,\n     topmargin = 1Plots.cm)\n\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 2: Extinction dans le modèle avec effet Allee et prélèvements\n\n\n\n\n\n\nIl s’agit ici de représenter dans l’espace (E, x) l’évolution conjointe de l’effort de pêche et de la densité de la population au cours du temps, afin de mieux comprendre le phénomène d’extinction. Dans cet objectif, on tracera aussi le lieu des équilibres de la population x^*(E) en fonction d’une valeur de E constante, i.e. : \nx^*(E) = 0,\n ou : \nE = r\\left(\\frac{x^*(E)}{\\epsilon}-1\\right)\\left(1-\\frac{x^*(E)}{K}\\right).\n\nNous allons tracer les situations dans 2 sous figures. Commençons par les lieux des équilibres :\n\n# vecteurs pour le tracé\ne2plot = 0:.1:1\nx2plot1 = epsilon:.02:(K+epsilon)/2\nx2plot2 = (K+epsilon)/2:.02:K\n\n# parabole pour les equilibres positifs\nfunction eeqpos(x, par = par_allee)\n        r, K, epsilon = par\n\n        r*(x/epsilon -1)*(1-x/K)\nend\n\n# on définit des couleurs spécifiques depuis la palette :pal10\nmygreen = palette(:tab10)[3]\nmyorange = palette(:tab10)[2]\nmyblue = palette(:tab10)[1]\nmyred = palette(:tab10)[4]\n\n# plot\nP1 = plot(e2plot, zeros(length(e2plot)),\n          color = mygreen,\n          linewidth = 2,\n          label = \"équilibres stables\",\n          ylabel = \"densité de population \\$x\\$\",\n          xlabel = \"effort de pêche \\$E\\$\",\n          legend = :left)\n        #   margin = .5Plots.cm,\n        #   topmargin = 1Plots.cm)\n\nplot!(P1, eeqpos.(x2plot1), x2plot1, \n          color= myorange,\n          linewidth = 2,\n          label = \"équilibre instable\")\n\nplot!(P1, eeqpos.(x2plot2), x2plot2, \n          color= mygreen,\n          linewidth = 2,\n          label =\"\")\n\ndisplay(P1)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nOn prépare un graphique P2 avec les mêmes éléments :\n\nP2 = deepcopy(P1) # évite de tout retaper...\n\nOn complète P1 et P2 avec quelques annotations et les trajectoires calculées plus haut en fonction de l’effort de pêche variable au cours du temps, et on trace les résultats en deux sous-figures :\n\nannotate!(P1, .35, 8.5, Plots.text(\"branche stable\", 10, rotation=-28))\nannotate!(P1, .4, 2.7, Plots.text(\"branche instable\", 10, rotation=28))\nannotate!(P2, .4, 2.7, Plots.text(\"branche instable\", 10, rotation=28))\nannotate!(P2, .35, 8.5, Plots.text(\"branche stable\", 10, rotation=-28))\n\nplot!(P1, [effort(t, par_effort) for t in sol_allee_evar.time], sol_allee_evar.x,\n      color = myblue, \n      linewidth = 2,\n      label = \"trajectory\")\n\nplot!(P2, [effort(t, par_effort2) for t in sol_allee_evar2.time], sol_allee_evar2.x,\n      color = myblue, \n      linewidth = 2,\n      label = \"trajectory\")\n\nplot(P1, P2, suptitle = \"Effets Allee et prélèvements\",\n     margin = .5Plots.cm,\n     topmargin = 1Plots.cm)\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\nFigure 3: bifurcation pli et catastrophe dans le modèle avec effet Allee et prélèvements"
  },
  {
    "objectID": "pop_isolees.html#sec-malthus",
    "href": "pop_isolees.html#sec-malthus",
    "title": "Populations isolées",
    "section": "",
    "text": "Nous considérons le modèle proposé par Malthus (1798) : \n\\dot x = (n-m)x,\n\\tag{1} avec n le taux de natalité, et m le taux de mortalité.\n\n\nPour simuler ce modèle, c’est à dire intégrer numériquement les solutions au problème de Cauchy correspondant à l’Equation 1 avec x(0)=x_0\\geq0, nous allons utiliser les routines de DifferentialEquations.jl avec la méthode par défaut. Nous utiliserons aussi le package Plots.jl pour les représentations graphiques.\n\nusing Plots, DifferentialEquations\n\n\n\n\nNous définissions la condition initiale de la simulation :\n\nx0 = 0.1\n\nNous définissons les paramètres, et les encapsulons dans un vecteur de paramètres :\n\nn = 3.0     # natalité\nm = 2.0     # morrtalité\npar_malthus = [n, m] # packing\n\nEnfin, les propriétés du temps d’intégration :\n\ntspan = (0.0, 10.0)\ntstep = 0.1\n\n\n\n\nOn définit le modèle comme une fonction renvoyant la dérivée de x (comme SVector) en fonction de l’état, de paramètres, et du temps. L’ordre des arguments est important, c’est sous cette forme que les routines d’intégration attendent le modèle.\n\nfunction malthus(u, p, t)\n    n, m = p        # unpacking\n    x = u[1]        # use x notation\n    dx = (n-m)x     # return derivative\nend\n\n\n\n\nOn commence par définir le problème de Cauchy à intégrer, comme un ODEProblem avec arguments: le modèle, la condition initiale, les bornes d’intégration, les paramètres ainsi que l’option saveat = tstep permettant de récupérer la solution tout les tstep pas de temps (il y a plein d’options de sortie de l’intégration, dont même une fonction du temps !)\n\nprob_malthus = ODEProblem(malthus,          # modèle\n                          x0,               # condition initiale\n                          tspan,            # tspan\n                          par_malthus,      # paramètres\n                          saveat = tstep)   # option de sortie\n\nOn intègre le modèle via solve, défini par DifferentialEquations.jl pour des struct de type ODEProblem :\n\nsol_malthus = solve(prob_malthus)\n\nLe type de solution renvoyée par le solveur est assez complexe et comprend de nombreux champs informatifs sur le calcul. On peut accéder au temps de simulation via sol_malthus.t :\n\nfirst(sol_malthus.t, 3)\n\n3-element Vector{Float64}:\n 0.0\n 0.1\n 0.2\n\n\nainsi qu’aux valeurs de la variable x calculées le long du temps via sol_matlhus.u :\n\nfirst(sol_malthus.u, 3)\n\n3-element Vector{Float64}:\n 0.1\n 0.1105170918098962\n 0.12214028021690636\n\n\nMême si ce n’est pas indispensable, il est possible de transformer la solution renvoyée facilement en DataFrame, qui peut permettre des manipulations plus faciles.\n\nusing DataFrames\n\nsol_malthus = DataFrame(sol_malthus)\nrename!(sol_malthus, :timestamp =&gt; :time, :value =&gt; :x)\n\nsi bien que :\n\nfirst(sol_malthus, 3)\n\n3×2 DataFrame\n\n\n\nRow\ntime\nx\n\n\n\nFloat64\nFloat64\n\n\n\n\n1\n0.0\n0.1\n\n\n2\n0.1\n0.110517\n\n\n3\n0.2\n0.12214\n\n\n\n\n\n\n\n\n\nOn peut représenter graphiquement la simulation de la croissance de la population au cours du temps (ici via le dataframe).\n\nplot(sol_malthus.time, sol_malthus.x,\n    palette = :tab10,\n    linewidth = 2,\n    title = \"\\n Modèle de Malthus \\$n=$n, m=$m\\$\",\n    label = \"population \\$x\\$\",  \n    ylabel = \"densité de population \\$x(t)\\$\", \n    xlabel = \"temps \\$t\\$\",\n    margin = .5Plots.cm,\n    topmargin = 1Plots.cm)"
  },
  {
    "objectID": "pop_isolees.html#préliminaires",
    "href": "pop_isolees.html#préliminaires",
    "title": "Populations isolées",
    "section": "Préliminaires",
    "text": "Préliminaires\nPour simuler ce modèle, c’est à dire intégrer numériquement les solutions au problème de Cauchy correspondant à l’Equation 1 avec x(0)=x_0\\geq0, nous allons utiliser les routines de DifferentialEquations.jl avec une méthode utilisant des tableaux statiques pour la rapidité d’exécution (package StaticArrays.jl). Nous utiliserons aussi le package Plots.jl pour les représentations graphiques.\n\nusing Plots, DifferentialEquations, StaticArrays"
  },
  {
    "objectID": "pop_isolees.html#conditions-initiales-paramètres-et-temps",
    "href": "pop_isolees.html#conditions-initiales-paramètres-et-temps",
    "title": "Populations isolées",
    "section": "Conditions initiales, paramètres et temps",
    "text": "Conditions initiales, paramètres et temps\nNous définissions la condition initiale de la simulation, et l’assignons dans un vecteur statique etat0 :\n\nx0 = 0.1\netat0 = @SVector [x0]\n\nNous définissons les paramètres, et les encapsulons dans un vecteur de paramètres :\n\nn = 3.0     # natalité\nm = 2.0     # morrtalité\npar_malthus = [n, m]\n\nEnfin, les propriétés du temps d’intégration :\n\ntspan = (0.0, 5.0)\ntstep = 0.1"
  },
  {
    "objectID": "pop_isolees.html#section",
    "href": "pop_isolees.html#section",
    "title": "Populations isolées",
    "section": "",
    "text": "On peut représenter graphiquement la simulation de la croissance de la population au cours du temps (ici via le dataframe).\n\nplot(sol_malthus.time, sol_malthus.x,\n    palette = :tab10,\n    linewidth = 2,\n    title = \"\\n Modèle de Malthus\",\n    label = \"population \" * L\"x\",  # latex strings, makrdown latex is off in labels\n    ylabel = \"densité de population \\$x(t)\\$\", # latex markdown is ok in axis label\n    xlabel = \"temps \\$t\\$\",\n    margin = .5Plots.cm,\n    topmargin = 1Plots.cm)"
  },
  {
    "objectID": "pop_isolees.html#sec-logistic",
    "href": "pop_isolees.html#sec-logistic",
    "title": "Populations isolées",
    "section": "Le modèle logistique",
    "text": "Le modèle logistique\nNous considérons ici le modèle “logistique” proposé par Verhulst (1838) :\n\n\\dot x = r x \\left(1-\\frac{x}{K}\\right),\n\\tag{2} avec r le taux de croissance intrinsèque de la population et K la capacité de charge de l’environnement.\nIl n’y a pas de difficulté particulière par rapport aux simulations précedentes. On va réutiliser la condition initiale et les paramètres de temps définis précédemment.\nIl faut cependant définir les paramètres du modèle Equation 2 :\n\n\nCode\nr = 1.0      # natalité\nK = 10.0     # morrtalité\npar_logistic = [r, K] # packing\n\n\nainsi que le nouveau système dynamique :\n\n\nCode\nfunction logistic(u, p, t)\n    r, K = p            # unpacking\n    x = u[1]            # use x notation\n    dx = r*x*(1-x/K)    # return derivative\nend\n\n\net le problème de Cauchy correspondant :\n\n\nCode\nprob_logistic = ODEProblem(logistic,        # modèle\n                          x0,               # condition initiale\n                          tspan,            # tspan\n                          par_logistic,     # paramètres\n                          saveat = tstep)   # option de sortie\n\n\nOn simule et on transforme la solution en dataframe :\n\n\nCode\nsol_logistic = solve(prob_logistic)\n\nsol_logistic = DataFrame(sol_logistic)\nrename!(sol_logistic, :timestamp =&gt; :time, :value =&gt; :x)\n\n\nOn trace la solution, en rajoutant les équilibres stable (x=K) et instable (x=0) :\n\n\nCode\n# solution\nplot(sol_logistic.time, sol_logistic.x,\n    palette = :tab10,\n    linewidth = 2,\n    title = \"\\n Modèle logistique \\$r=$r, K=$K\\$\",\n    label = \"population \\$x\\$\",  \n    legend = :right,\n    ylabel = \"densité de population \\$x(t)\\$\", \n    xlabel = \"temps \\$t\\$\",\n    margin = .5Plots.cm,\n    topmargin = 1Plots.cm)\n\n# équilibre 0\nplot!(sol_logistic.time, zeros(length(sol_logistic.time)),\n      color = \"red\",\n      linewidth = 2,\n      linestyle = :dash,\n      linealpha = .5,\n      label = \"équilibre instable\")\n\n# équilibre 1\nplot!(sol_logistic.time, ones(length(sol_logistic.time)).*K,\n      color = \"green\",\n      linewidth = 2,\n      linestyle = :dash,\n      linealpha = .5,\n      label = \"équilibre stable\")"
  },
  {
    "objectID": "pop_isolees.html#effets-allee",
    "href": "pop_isolees.html#effets-allee",
    "title": "Populations isolées",
    "section": "Effets Allee",
    "text": "Effets Allee"
  },
  {
    "objectID": "pop_isolees.html#sec-allee",
    "href": "pop_isolees.html#sec-allee",
    "title": "Populations isolées",
    "section": "Effets Allee",
    "text": "Effets Allee\nOn s’intéresse à un modèle de dynamique de population avec “effets Allee forts”, souvent attribué à Gruntfest, Arditi, and Dombrovsky (1997)1 :1 mais de nombreuses variations de cette forme polynomiale existent dans la littérature depuis Bazykin (1985)\n\n\\dot x = r x \\left(\\frac{x}{\\epsilon}-1\\right)\\left(1-\\frac{x}{K}\\right),\n\\tag{3} avec r le taux de croissance intrinsèque de la population (par analogie avec la logistique), K la capacité de charge de l’environnement et \\epsilon le seuil en dessous duquel la population n’est pas viable (‘seuil de Allee’).\nNous souhaitons illustrer la bistabilité caractéristique du comportement de ce modèle à partir de la simulation depuis plusieurs conditions initiales.\nCommençons par définir le modèle et les paramètres (en conservant les r et K précédents):\n\n\nCode\nepsilon = 2                 # seuil de Allee\npar_allee = [r, K, epsilon] # packing\ntspan_allee = (0.0, 3.0)\n\nfunction allee(u, p, t)\n    r, K, epsilon = p        # unpacking\n    x = u[1]                 # use x notation\n    dx = r*x*(x/epsilon - 1)*(1 - x/K)     # return derivative\nend\n\n\nNous définissons une fonction qui réalise une simulation en un seul appel :\n\nfunction int_allee(x0, tspan = tspan_allee, param = par_allee)\n    prob_allee = ODEProblem(allee,          # modèle\n                          x0,               # condition initiale\n                          tspan,            # tspan\n                          param,            # paramètres\n                          saveat = tstep)   # option de sortie\n    \n    sol_allee = solve(prob_allee)\n    sol_allee = DataFrame(sol_allee)\n    rename!(sol_allee, :timestamp =&gt; :time, :value =&gt; :x)\nend\n\nNous définissons un vecteur de conditions initiales différentes :\n\nx0step = 1.35\nx0vec = x0step:x0step:K\n\nFinalement on réalise la figure, en initiant un graphique P et en faisant une boucle pour tracer chacune des simulations correspondant aux différentes conditions initiales :\n\n# custom color palette\ninit_cgrad = palette([:steelblue, :lightblue], length(x0vec))\n\n# initialisation du graphique\nP = plot(palette = init_cgrad,\n         title = \"\\n Modèle à effets Allee \\$r=$r, K=$K\\$, \\$ϵ=$epsilon\\$\",\n         legend = :right,\n         ylabel = \"densité de population \\$x(t)\\$\", \n         xlabel = \"temps \\$t\\$\",\n         margin = .5Plots.cm,\n         topmargin = 1Plots.cm)\n\n# boucle de plot avec intégration pour differentes conditions initiales\nfor x0 in x0vec\n    plot!(P, int_allee(x0).time, int_allee(x0).x,\n          linewidth = 2,\n          label = \"\")\nend\n\n# équilibres\nplot!(P, int_allee(0).time, zeros(length(int_allee(0).time)),\n      color = \"green\",\n      linewidth = 2,\n      linestyle = :dash,\n      linealpha = .5,\n      label = \"équilibre stable\")\nplot!(P, int_allee(0).time, ones(length(int_allee(0).time)).*epsilon,\n      color = \"red\",\n      linewidth = 2,\n      linestyle = :dash,\n      linealpha = .5,\n      label = \"équilibre instable\")\nplot!(P, int_allee(0).time, ones(length(int_allee(0).time)).*K,\n      color = \"green\",\n      linewidth = 2,\n      linestyle = :dash,\n      linealpha = .5,\n      label = \"\")\n\ndisplay(P)      # actually shows the plot P\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPassons aux populations exploitées."
  },
  {
    "objectID": "pop_exploitees.html#sec-allee-prelev",
    "href": "pop_exploitees.html#sec-allee-prelev",
    "title": "Populations exploitées",
    "section": "",
    "text": "Nous reprenons le modèle précédent sur l’effet Allee mais en prenant en compte des prélèvements externes avec un effort (taux) de prélèvement E : \n\\dot x = r x \\left(\\frac{x}{\\epsilon}-1\\right)\\left(1-\\frac{x}{K}\\right)-Ex.\n\\tag{1}\nLa simulation de ce modèle pour différentes valeurs de E (par exemple E=0.2 ou E=0.85) ne présente aucune difficulté supplémentaire.\nNous allons maintenant nous intéresser à une situation où l’effort de prélèvement E varie au cours du temps entre une valeur soutenable E_s (par exemple 0.2), et une valeur excessive E_x (par exemple 0.85).\nL’attendu théorique est que si les prélèvements sont maintenus à une valeur excessive E_x trop longtemps, la population disparait irrémédiablement même si les prélèvements sont par la suite ramenés à une valeur initialement soutenable E_s.\n\n\n\nusing DifferentialEquations, Plots, DataFrames\n\nDéfinissons une fonction effort() dépendant du temps, qui renvoit :\n\nE_s~ si ~t&lt;T_s\nE_x~ si ~t\\in [T_s+T_x[\nà nouveau E_s~ si ~t\\geq T_s+T_x\n\n\n# paramètres\nE_s = 0.2\nE_x = 0.85\nT_s = 10.0\nT_x = 9.0 \n\npar_effort = [E_s, E_x, T_s, T_x]\n\nfunction effort(t, pars)\n    E_s, E_x, T_s, T_x = pars\n\n    if t &lt; T_s || t &gt;= T_s + T_x\n        return E_s\n    elseif t &gt;= T_s && t &lt; T_s + T_x\n        return E_x\n    end\nend\n\nLa fonction correspond bien à nos hypothèses :\n\n\nCode\ntime2plot = 0: .1: 30\n\nplot(time2plot, [effort(t, par_effort) for t in time2plot],\n     palette = :tab10,\n     linewidth = 2,\n     label = \"\\$E(t)\\$\",\n     xlabel = \"temps\",\n     ylabel = \"\\$E(t)\\$\",\n     title = \"Effort de pêche \\$E(t)\\$\",\n     margin = .5Plots.cm,\n     topmargin = 1Plots.cm)\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNous définissons les paramètres du modèle, la condition initiale et le temps d’intégration :\n\n\nCode\nx0 = 10.\n\ntspan = (0.0, 30.0)\ntstep = 0.1\n\nr = 1.\nK = 10.\nepsilon = 2.                 # seuil de Allee\npar_allee = [r, K, epsilon] # packing\ntspan_allee = (0.0, 3.0)\n\n\nNous définissons le système dynamique comme précédemment, à la différence que nous prévoyons de surcharger l’argument p dans le problème d’intégration sous forme d’un vecteur comprennant :\n\nle vecteur de paramètres par_allee en première position\nle vecteur de paramètres par_effort en seconde position\net la fonction effort en troisième position\n\n\nfunction allee_evar(u, p, t)\n    r, K, epsilon = p[1]        # unpacking model parameters\n    par_effort = p[2]           # unpacking fishing effort parameters\n    E = p[3]                    # unpacking fishing effort function\n    x = u[1]                    # use x notation\n    \n    dx = r*x*(x/epsilon - 1)*(1 - x/K) - E(t, par_effort)*x\nend\n\nL’intégration en elle-même suit le shéma vu précédemment, si ce n’est que l’argument de paramètres doit bien refléter ce qui est attendu par la fonction allee_evar(). La simulation en elle-même est effectuée avec une modification de la précision relative de l’intégration reltol = 1e-6, la précision par défaut n’étant pas suffisante ici.\n\nprob_allee_evar = ODEProblem(allee_evar, \n                             x0, \n                             tspan, \n                             [par_allee, par_effort, effort], \n                             saveat = tstep)\n\nsol_allee_evar = solve(prob_allee_evar, reltol = 1e-6)\n\nsol_allee_evar = DataFrame(sol_allee_evar)\nrename!(sol_allee_evar, :timestamp =&gt; :time, :value =&gt; :x)\n\nFinalement, nous pouvons représenter graphiquement la solution contre le temps. Ici, malgré la perturbation violente induite par la période de surexploitation, le pêcherie retrouve une situation soutenable après un retour à E=E_s.\n\n\nCode\nplot(sol_allee_evar.time, sol_allee_evar.x,\n     label = \"\\$x(t)\\$\",\n     linewidth = 2,\n     xlabel = \"temps\",\n     ylabel = \"densité de population \\$x(t)\\$\",\n     title = \"Effort de pêche variant dans le temps\",\n     palette = :tab10,\n     legend = :left,\n     margin = .5Plots.cm,\n     topmargin = 1Plots.cm)\n\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 1: Persistence dans le modèle avec effet Allee et prélèvements\n\n\n\n\n\nLorsque la période de surexploitation de la population est trop longue (e.g. ici T_x=9.2), la population ne parvient pas à récupérer malgré le retour à un effort de prélèvements soutenable.\n\n\nCode\n# change parameter\nT_x2 = 9.2\n\npar_effort2 = [E_s, E_x, T_s, T_x2]\n\n# define new problem and integrate\nprob_allee_evar2 = ODEProblem(allee_evar, \n                             x0, \n                             tspan, \n                             [par_allee, par_effort2, effort], \n                             saveat = tstep)\n\nsol_allee_evar2 = solve(prob_allee_evar2, reltol = 1e-6)\n\nsol_allee_evar2 = DataFrame(sol_allee_evar2)\nrename!(sol_allee_evar2, :timestamp =&gt; :time, :value =&gt; :x)\n\n# plot\nplot(sol_allee_evar2.time, sol_allee_evar2.x,\n     label = \"\\$x(t)\\$\",\n     linewidth = 2,\n     xlabel = \"temps\",\n     ylabel = \"densité de population \\$x(t)\\$\",\n     title = \"Effort de pêche variant dans le temps\",\n     palette = :tab10,\n     legend = :left,\n     margin = .5Plots.cm,\n     topmargin = 1Plots.cm)\n\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 2: Extinction dans le modèle avec effet Allee et prélèvements\n\n\n\n\n\n\nIl s’agit ici de représenter dans l’espace (E, x) l’évolution conjointe de l’effort de pêche et de la densité de la population au cours du temps, afin de mieux comprendre le phénomène d’extinction. Dans cet objectif, on tracera aussi le lieu des équilibres de la population x^*(E) en fonction d’une valeur de E constante, i.e. : \nx^*(E) = 0,\n ou : \nE = r\\left(\\frac{x^*(E)}{\\epsilon}-1\\right)\\left(1-\\frac{x^*(E)}{K}\\right).\n\nNous allons tracer les situations dans 2 sous figures. Commençons par les lieux des équilibres :\n\n# vecteurs pour le tracé\ne2plot = 0:.1:1\nx2plot1 = epsilon:.02:(K+epsilon)/2\nx2plot2 = (K+epsilon)/2:.02:K\n\n# parabole pour les equilibres positifs\nfunction eeqpos(x, par = par_allee)\n        r, K, epsilon = par\n\n        r*(x/epsilon -1)*(1-x/K)\nend\n\n# on définit des couleurs spécifiques depuis la palette :pal10\nmygreen = palette(:tab10)[3]\nmyorange = palette(:tab10)[2]\nmyblue = palette(:tab10)[1]\nmyred = palette(:tab10)[4]\n\n# plot\nP1 = plot(e2plot, zeros(length(e2plot)),\n          color = mygreen,\n          linewidth = 2,\n          label = \"équilibres stables\",\n          ylabel = \"densité de population \\$x\\$\",\n          xlabel = \"effort de pêche \\$E\\$\",\n          legend = :left)\n        #   margin = .5Plots.cm,\n        #   topmargin = 1Plots.cm)\n\nplot!(P1, eeqpos.(x2plot1), x2plot1, \n          color= myorange,\n          linewidth = 2,\n          label = \"équilibre instable\")\n\nplot!(P1, eeqpos.(x2plot2), x2plot2, \n          color= mygreen,\n          linewidth = 2,\n          label =\"\")\n\ndisplay(P1)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nOn prépare un graphique P2 avec les mêmes éléments :\n\nP2 = deepcopy(P1) # évite de tout retaper...\n\nOn complète P1 et P2 avec quelques annotations et les trajectoires calculées plus haut en fonction de l’effort de pêche variable au cours du temps, et on trace les résultats en deux sous-figures :\n\nannotate!(P1, .35, 8.5, Plots.text(\"branche stable\", 10, rotation=-28))\nannotate!(P1, .4, 2.7, Plots.text(\"branche instable\", 10, rotation=28))\nannotate!(P2, .4, 2.7, Plots.text(\"branche instable\", 10, rotation=28))\nannotate!(P2, .35, 8.5, Plots.text(\"branche stable\", 10, rotation=-28))\n\nplot!(P1, [effort(t, par_effort) for t in sol_allee_evar.time], sol_allee_evar.x,\n      color = myblue, \n      linewidth = 2,\n      label = \"trajectory\")\n\nplot!(P2, [effort(t, par_effort2) for t in sol_allee_evar2.time], sol_allee_evar2.x,\n      color = myblue, \n      linewidth = 2,\n      label = \"trajectory\")\n\nplot(P1, P2, suptitle = \"Effets Allee et prélèvements\",\n     margin = .5Plots.cm,\n     topmargin = 1Plots.cm)\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\nFigure 3: bifurcation pli et catastrophe dans le modèle avec effet Allee et prélèvements"
  },
  {
    "objectID": "pop_exploitees.html#prélèvements-variables-dans-le-temps",
    "href": "pop_exploitees.html#prélèvements-variables-dans-le-temps",
    "title": "Populations exploitées",
    "section": "",
    "text": "using DifferentialEquations, Plots, DataFrames\n\nDéfinissons une fonction effort() dépendant du temps, qui renvoit :\n\nE_s~ si ~t&lt;T_s\nE_x~ si ~t\\in [T_s+T_x[\nà nouveau E_s~ si ~t\\geq T_s+T_x\n\n\n# paramètres\nE_s = 0.2\nE_x = 0.85\nT_s = 10.0\nT_x = 9.0\n\npar_effort = [E_s, E_x, T_s, T_x]\n\nfunction effort(t, pars)\n    E_s, E_x, T_s, T_x = pars\n\n    if t &lt; T_s || t &gt;= T_s + T_x\n        return E_s\n    elseif t &gt;= T_s && t &lt; T_s + T_x\n        return E_x\n    end\nend\n\nLa fonction correspond bien à nos hypothèses :\n\n\nCode\ntime2plot = 0: .1: 30\n\nplot(time2plot, [effort(t, par_effort) for t in time2plot],\n     palette = :tab10,\n     linewidth = 2,\n     label = \"\\$E(t)\\$\",\n     xlabel = \"temps\",\n     ylabel = \"\\$E(t)\\$\",\n     title = \"Effort de pêche \\$E(t)\\$\",\n     margin = .5Plots.cm,\n     topmargin = 1Plots.cm)"
  },
  {
    "objectID": "pop_exploitees.html#simulations-en-fonction-du-temps",
    "href": "pop_exploitees.html#simulations-en-fonction-du-temps",
    "title": "Populations exploitées",
    "section": "",
    "text": "Nous définissons les paramètres du modèle, la condition initiale et le temps d’intégration :\n\n\nCode\nx0 = 10.\n\ntspan = (0.0, 30.0)\ntstep = 0.1\n\nr = 1.\nK = 10.\nepsilon = 2.                 # seuil de Allee\npar_allee = [r, K, epsilon] # packing\ntspan_allee = (0.0, 3.0)\n\n\nNous définissons le système dynamique comme précédemment, à la différence que nous prévoyons de surcharger l’argument p dans le problème d’intégration sous forme d’un vecteur comprennant :\n\nle vecteur de paramètres par_allee en première position\nle vecteur de paramètres par_effort en seconde position\net la fonction effort en troisième position\n\n\nfunction allee_evar(u, p, t)\n    r, K, epsilon = p[1]        # unpacking model parameters\n    par_effort = p[2]           # unpacking fishing effort parameters\n    E = p[3]                    # unpacking fishing effort function\n    x = u[1]                    # use x notation\n    \n    dx = r*x*(x/epsilon - 1)*(1 - x/K) - E(t, par_effort)*x\nend\n\nL’intégration en elle-même suit le shéma vu précédemment, si ce n’est que l’argument de paramètres doit bien refléter ce qui est attendu par la fonction allee_evar(). La simulation en elle-même est effectuée avec une modification de la précision relative de l’intégration reltol = 1e-6, la précision par défaut n’étant pas suffisante ici.\n\nprob_allee_evar = ODEProblem(allee_evar, \n                             x0, \n                             tspan, \n                             [par_allee, par_effort, effort], \n                             saveat = tstep)\n\nsol_allee_evar = solve(prob_allee_evar, reltol = 1e-6)\n\nsol_allee_evar = DataFrame(sol_allee_evar)\nrename!(sol_allee_evar, :timestamp =&gt; :time, :value =&gt; :x)\n\nFinalement, nous pouvons représenter graphiquement la solution contre le temps. Ici, malgré la perturbation violente induite par la période de surexploitation, le pêcherie retrouve une situation soutenable après un retour à E=E_s.\n\n\nCode\nplot(sol_allee_evar.time, sol_allee_evar.x,\n     label = \"\\$x(t)\\$\",\n     linewidth = 2,\n     xlabel = \"temps\",\n     ylabel = \"densité de population \\$x(t)\\$\",\n     title = \"Effort de pêche variant dans le temps\",\n     palette = :tab10,\n     legend = :left,\n     margin = .5Plots.cm,\n     topmargin = 1Plots.cm)\n\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 1: Persistence dans le modèle avec effet Allee et prélèvements\n\n\n\n\n\nLorsque la période de surexploitation de la population est trop longue (e.g. ici T_x=9.2), la population ne parvient pas à récupérer malgré le retour à un effort de prélèvements soutenable.\n\n\nCode\n# change parameter\nT_x2 = 9.2\n\npar_effort2 = [E_s, E_x, T_s, T_x2]\n\n# define new problem and integrate\nprob_allee_evar2 = ODEProblem(allee_evar, \n                             x0, \n                             tspan, \n                             [par_allee, par_effort2, effort], \n                             saveat = tstep)\n\nsol_allee_evar2 = solve(prob_allee_evar2, reltol = 1e-7)\n\nsol_allee_evar2 = DataFrame(sol_allee_evar2)\nrename!(sol_allee_evar2, :timestamp =&gt; :time, :value =&gt; :x)\n\n# plot\nplot(sol_allee_evar2.time, sol_allee_evar2.x,\n     label = \"\\$x(t)\\$\",\n     linewidth = 2,\n     xlabel = \"temps\",\n     ylabel = \"densité de population \\$x(t)\\$\",\n     title = \"Effort de pêche variant dans le temps\",\n     palette = :tab10,\n     legend = :left,\n     margin = .5Plots.cm,\n     topmargin = 1Plots.cm)\n\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 2: Extinction dans le modèle avec effet Allee et prélèvements"
  },
  {
    "objectID": "pop_exploitees.html#simulations-dans-lespace-e-x",
    "href": "pop_exploitees.html#simulations-dans-lespace-e-x",
    "title": "Populations exploitées",
    "section": "",
    "text": "Il s’agit ici de représenter dans l’espace (E, x) l’évolution conjointe de l’effort de pêche et de la densité de la population au cours du temps, afin de mieux comprendre le phénomène d’extinction. Dans cet objectif, on tracera aussi le lieu des équilibres de la population x^*(E) en fonction d’une valeur de E constante, i.e. : \nx^*(E) = 0,\n ou : \nE = r\\left(\\frac{x^*(E)}{\\epsilon}-1\\right)\\left(1-\\frac{x^*(E)}{K}\\right).\n\nNous allons tracer les situations dans 2 sous figures. Commençons par les lieux des équilibres :\n\n# vecteurs pour le tracé\ne2plot = 0:.1:1\nx2plot1 = epsilon:.02:(K+epsilon)/2\nx2plot2 = (K+epsilon)/2:.02:K\n\n# parabole pour les equilibres positifs\nfunction eeqpos(x, par = par_allee)\n        r, K, epsilon = par\n\n        r*(x/epsilon -1)*(1-x/K)\nend\n\n# on définit des couleurs spécifiques depuis la palette :pal10\nmygreen = palette(:tab10)[3]\nmyorange = palette(:tab10)[2]\nmyblue = palette(:tab10)[1]\n\n# plot\nP1 = plot(e2plot, zeros(length(e2plot)),\n          color = mygreen,\n          linewidth = 2,\n          label = \"équilibres stables\",\n          ylabel = \"densité de population \\$x\\$\",\n          xlabel = \"effort de pêche \\$E\\$\",\n          legend = :left)\n        #   margin = .5Plots.cm,\n        #   topmargin = 1Plots.cm)\n\nplot!(P1, eeqpos.(x2plot1), x2plot1, \n          color= myorange,\n          linewidth = 2,\n          label = \"équilibre instable\")\n\nplot!(P1, eeqpos.(x2plot2), x2plot2, \n          color= mygreen,\n          linewidth = 2,\n          label =\"\")\n\ndisplay(P1)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nOn prépare un graphique P2 avec les mêmes éléments :\n\nP2 = deepcopy(P1) # évite de tout retaper...\n\nOn complète P1 et P2 avec quelques annotations et les trajectoires calculées plus haut en fonction de l’effort de pêche variable au cours du temps, et on trace les résultats en deux sous-figures :\n\nannotate!(P1, .35, 8.5, Plots.text(\"branche stable\", 10, rotation=-28))\nannotate!(P1, .4, 2.7, Plots.text(\"branche instable\", 10, rotation=28))\nannotate!(P2, .4, 2.7, Plots.text(\"branche instable\", 10, rotation=28))\nannotate!(P2, .35, 8.5, Plots.text(\"branche stable\", 10, rotation=-28))\n\nplot!(P1, [effort(t, par_effort) for t in sol_allee_evar.time], sol_allee_evar.x,\n      color = myblue, \n      linewidth = 2,\n      label = \"trajectory\")\n\nplot!(P2, [effort(t, par_effort2) for t in sol_allee_evar2.time], sol_allee_evar2.x,\n      color = myblue, \n      linewidth = 2,\n      label = \"trajectory\")\n\nplot(P1, P2, suptitle = \"Effets Allee et prélèvements\",\n     margin = .5Plots.cm,\n     topmargin = 1Plots.cm)\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\nFigure 3: bifurcation pli et catastrophe dans le modèle avec effet Allee et prélèvements"
  },
  {
    "objectID": "pop_exploitees.html#la-tordeuse-du-bourgeon-de-lépinette",
    "href": "pop_exploitees.html#la-tordeuse-du-bourgeon-de-lépinette",
    "title": "Populations exploitées",
    "section": "La tordeuse du bourgeon de l’épinette",
    "text": "La tordeuse du bourgeon de l’épinette\n\nModèle\nNous considérons le modèle de dynamique de populations suivant, inspiré de Ludwig, Jones, and Holling (1978) :\n\n\\dot x =rx\\left(1-\\frac{x}{K}\\right) - \\frac{\\alpha x^2}{h^2+x^2}\\ y,\n\\tag{2}\navec x la densité de tordeuses et y la densité d’oiseaux. La croissance des tordeuses suit une loi logistique et la prédation des oiseaux une réponse fonctionnelle de type Holling III.\n\n\nSimulations\nOn procède classiquement, en ajustant les valeurs de paramètres pour mettre en évidence les phénomènes dynamiques attendus :\n\n# paramètres\nr = 5.0      # natalité\nK = 10.0     # mortalité\nα = 1.0      # taux max de prédation\nh = 0.5      # constante de demi-saturation\nyc = 7.0     # densité de prédateurs\n\npar_tordeuse = [r, K, α, h, yc] \n\n# temps d'intégration\ntspan = (0.0, 3.0)\ntstep = 0.02\n\nPuis on définit le modèle :\n\nfunction tordeuse(u, p, t)\n    r, K, α, h, yc = p\n    x = u[1]\n    dx = r*x*(1 - x/K) - α*x^2/(h^2 + x^2)*yc\nend\n\nComme pour le modèle avec effets Allee, on définit une fonction qui simule et renvoit la solution pour pouvoir illustrer la bi-stabilité :\n\nfunction int_tordeuse(x0, tspan = tspan, param = par_tordeuse)\n    prob_tordeuse = ODEProblem(tordeuse,       # modèle\n                               x0,               # condition initiale\n                               tspan,            # tspan\n                               param,            # paramètres\n                               saveat = tstep)   # option de sortie\n    \n    sol_tordeuse = solve(prob_tordeuse)\n    sol_tordeuse = DataFrame(sol_tordeuse)\n    rename!(sol_tordeuse, :timestamp =&gt; :time, :value =&gt; :x)\nend\n\nNous simulons le modèle depuis différentes conditions intiales, et traçons les résultats via une boucle.\n\n# conditions initiales\nx0step = 1.35\nx0vec = x0step:x0step:K\n\n# custom color palette\ninit_cgrad = palette([:steelblue, :lightblue], length(x0vec))\n\n# initialisation du graphique, équilibre nul\nP = plot(palette = init_cgrad,\n         legend = :right, \n         label =\"équilibres instables\",\n         title = \"Tordeuse du bourgeon de l\\'épinette\",\n         ylabel = \"densité de population \\$x(t)\\$\", \n         xlabel = \"temps \\$t\\$\",\n         margin = .5Plots.cm,\n         topmargin = 1Plots.cm)\n\n# boucle de plot avec intégration pour differentes conditions initiales\nfor x0 in x0vec\n    plot!(P, int_tordeuse(x0).time, int_tordeuse(x0).x,\n          linewidth = 2,\n          label = \"\")\nend\n\ndisplay(P)      # actually shows the plot P\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nEquilibres\nLes valeurs des équilibres positifs du modèle Equation 2 n’ont pas d’écriture mathématique simple. Nous allons calculer numériquement les racines du polynôme dont ils sont solution : \nr\\left(1-\\frac{x^*}{K}\\right)\\left(h^2+x^{*2}\\right)-\\alpha x^* y = 0\n\\tag{3}\nPour cela, on utilise le package Polynomials.jl :\n\nusing Polynomials\n\n# définition du monôme X\nX = Polynomial([0, 1])\n\n# définition du polynôme \npol = r*(1-X/K)*(h^2 + X^2)-α*X*yc\n\n# calcul des racines, réelles, positives et plus petites que K\neq_pos = roots(pol)                         # calcul des racines\neq_pos = real.(eq_pos[isreal.(eq_pos)])     # filtrage des racines réelles\neq_pos = eq_pos[(eq_pos .&gt; 0) .& (eq_pos .&lt;= K)] # filtrage des racines &gt;0 et &lt;K\n\n3-element Vector{Float64}:\n 0.20406511760131657\n 1.4717313636879934\n 8.324203518710693\n\n\nEt on trace les différents équilibres :\n\nt2plot = collect(tspan)\n\n# initialisation du graphique, équilibre nul\nplot!(P, t2plot, zeros(length(t2plot)), \n         lw=2, \n         linestyle = :dash, \n         color = myorange, \n         palette = init_cgrad,\n         legend = :right, \n         label =\"équilibres instables\",\n         ylabel = \"densité de population \\$x(t)\\$\", \n         xlabel = \"temps \\$t\\$\",\n         margin = .5Plots.cm,\n         topmargin = 1Plots.cm)\n\n# équilibres positifs\nif length(eq_pos) == 1\n    plot!(P, t2plot, ones(length(t2plot)).*eq_pos, \n          color = mygreen, \n          label =\"équilibre stable\")\nelseif length(eq_pos) == 3\n    plot!(P, t2plot, ones(length(t2plot)).*eq_pos[1], \n          lw=2, \n          linestyle = :dash, \n          color = mygreen, \n          label =\"équilibres stables\")\n    plot!(P, t2plot, ones(length(t2plot)).*eq_pos[2], \n          lw=2, \n          linestyle = :dash, \n          color = myorange, \n          label = \"\")\n    plot!(P, t2plot, ones(length(t2plot)).*eq_pos[3], \n          lw=2, \n          linestyle = :dash, \n          color = mygreen, \n          label = \"\")\nend\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 4: bistabilité dans le modèle de la tordeuse du bourgeon de l’épinette\n\n\n\n\n\nDiagramme de bifurcations\nFinalement nous traçons dans le plan (y, x) le lieu des points d’équilibres en fonction de la taille de la population d’oiseaux:\n\ny = \\frac{r}{\\alpha x^*}\\left(1-\\frac{x^*}{K}\\right)(h^2+x^{*2})\n\\tag{4}\nComme nous l’avons vu en cours cette fonction est non monotone avec une branche décroissante, une branche croissante puis à nouveau une branche décroissante, le sens de variation déterminant la stabilité de l’équilibre correspondant.\nPour déterminer ces différentes branches et les représenter de différentes couleurs de façon à illustrer leur stabilité, nous allons dériver l’Equation 4 par rapport à x^* en utilisant le package Symbolics.jl et chercher les racines de la dérivée1.1 si l’Equation 4 avait été un polynôme nous aurions utilisé les outils pour les polynômes, mais il s’agit d’une fraction rationnelle\n\nusing Symbolics\n\n@variables X\nD = Differential(X)\n\nY = r/(α*X)*(1-X/K)*(h^2+X^2)\n\n \\begin{equation}\n\\frac{5 \\left( 1 - 0.1 X \\right) \\left( 0.25 + X^{2} \\right)}{X}\n\\end{equation}\n\n\n\nLes racines de la dérivée, sont les racines du numérateur de la dérivée, donc on dérive, et on récupère ce numérateur:\n\ndnumerator = Symbolics.arguments(Symbolics.value(simplify(expand_derivatives(D(Y)))))[1]\ndnumerator\n\n \\begin{equation}\n-1.25 + 5.0 X^{2} - X^{3}\n\\end{equation}\n\n\n\nComme ce numérateur est un polynôme, on peut utiliser le polynôme symbolique de Symbolics.jl pour regénérer un polynôme et utiliser la méthode roots() de Polynomials.jl22 il faut l’admettre, ce serait plus simple d’avoir directement une façon de trouver les racines d’un polynôme symbolique, mais ça ne semble pas implanté pour l’instant (fin 2023)\n\n# on récupère les coefficients X^k du polynôme\ncoefs_dict = Symbolics.value(dnumerator).dict\ndd = Dict(Symbolics.degree(first(kv)) =&gt; kv[2] for kv ∈ coefs_dict)\n\n# on rajoute dans le dictionnaire le coefficient constant\ndd[0] = substitute(dnumerator, Dict(X=&gt;0))\n\n# on définit le polynôme à partir du dictionnaire\ndnumpoly = SparsePolynomial(dd, :X)\n\n# on calcule les solutions en filtrant les racines entre 0 et K via une fonction anonyme s-&gt; K &gt; s &gt; 0\ndroots = filter(s -&gt; K &gt; s &gt; 0, roots(dnumpoly))\n\nOn calcule les branches correspondantes et on peut les tracer dans le plan (y,x) pour illustrer le diagramme de bifurcations.\n\n# on calcule chacune des branches\nxplot1 = 0.08:.01:droots[1]\nxplot2 = droots[1]:.01:droots[2]\nxplot3 = droots[2]:.01:K\nyeq1 = r.*(1 .-xplot1./K) ./ (α.*xplot1).*(h^2 .+xplot1.^2)\nyeq2 = r.*(1 .-xplot2./K) ./ (α.*xplot2).*(h^2 .+xplot2.^2)\nyeq3 = r.*(1 .-xplot3./K) ./ (α.*xplot3).*(h^2 .+xplot3.^2)\n\n# diagramme de bifurcations\nPbif = plot(yeq1, xplot1,\n            linewidth = 2,\n            color = mygreen,\n            label = \"équilibres stables\",\n            legend = :left,\n            xlabel = \"population d'oiseaux \\$y\\$\",\n            ylabel = \"population de tordeuses \\$x\\$\",\n            title = \"Diagramme de bifurcations pour le modèle de tordeuses\",\n            margin = .5Plots.cm,\n            topmargin = 1Plots.cm)\n\nplot!(Pbif, yeq2, xplot2,\n      linewidth = 2,\n      color = myred,\n      label = \"équilibres instables\")\n\nplot!(Pbif, yeq3, xplot3,\n      linewidth = 2,\n      color = mygreen,\n      label = \"\")\n\nplot!(Pbif, [0, maximum(yeq1)], [0, 0], \n      color = myred,\n      lw = 2,\n      label = \"\")\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 5: bifurcations dans le modèle de la tordeuse du bourgeon de l’épinette\n\n\n\nNous verrons sur la page des populations en interactions le cas où la population d’oiseaux varie lentement au cours du temps."
  },
  {
    "objectID": "pop_interactions.html#la-tordeuse-du-bourgeon-de-lépinette-suite",
    "href": "pop_interactions.html#la-tordeuse-du-bourgeon-de-lépinette-suite",
    "title": "Populations en interaction (1)",
    "section": "",
    "text": "Pour débuter cette partie sur les populations en interactions, nous reprenons le modèle de tordeuse de Ludwig, Jones, and Holling (1978) en supposant que la population d’oiseaux réagit (lentement) à la démographie des tordeuses, via la prédation.\nLe changement principal ici est la dimension du modèle (dimension 2) : les tailles de populations de tordeuses x et d’oiseaux y varient toutes deux au cours du temps en s’influençant l’une l’autre, avec une population d’oiseaux qui varie lentement (d’où le paramètre \\varepsilon).\nLe modèle prend la forme :\n\n\\left\\{\n\\begin{array}{l}\n\\displaystyle \\dot x = rx\\left(1-\\frac{x}{K}\\right) - \\frac{\\alpha x^2}{h^2+x^2}\\ y \\\\[.3cm]\n\\displaystyle \\dot y = \\varepsilon \\left(\\frac{n \\alpha x^2}{h^2+x^2}\\ y -m y\\right)\n\\end{array}\n\\right.\n\\tag{1}\nIl faut ajuster un peu la manière de coder pour prendre en compte ces deux dimensions. Commençons par les paramètres divers.\n\nusing DifferentialEquations, Plots, DataFrames\n\n# paramètres\nr = 5.0      # natalité\nK = 10.0     # mortalité\nα = 1.0      # taux max de prédation\nh = 0.5      # constante de demi-saturation\n\nϵ = 0.01     # timescale\nn = 5.0      # gain à la prédation\nm = 3.0      # moralité\n\n\npar_tord_ois = [r, K, α, h, ϵ, n, m] \n\n# temps d'intégration\ntspan = (0.0, 400.0)\ntstep = 0.02\n\n# conditions initiales\nx0 = 1.0    # tordeuses\ny0 = 2.5    # oiseaux\netat0 = [x0, y0]\n\nPuis le modèle :\n\nfunction tord_ois(u, param, t)\n    r, K, α, h, ϵ, n, m = param\n    x = u[1]\n    y = u[2]\n    dx = r*x*(1 - x/K) - α*x^2/(h^2 + x^2) * y\n    dy = ϵ*(n*α*x^2/(h^2 + x^2) * y - m * y)\n    [dx, dy]\nend\n\nProblème d’intégration et simulation :\n\nprob_tord_ois = ODEProblem(tord_ois, \n                           etat0, \n                           tspan, \n                           par_tord_ois, \n                           saveat = tstep)\n\nsol_tord_ois = solve(prob_tord_ois, reltol = 1e-6)\n\nsol_tord_ois = DataFrame(sol_tord_ois)\nrename!(sol_tord_ois, :timestamp =&gt; :time, :value1 =&gt; :x, :value2 =&gt; :y)\n\nReprésentation graphique contre le temps\n\n# color definitions\nmygreen = palette(:tab10)[3]\nmyorange = palette(:tab10)[2]\nmyblue = palette(:tab10)[1]\nmyred = palette(:tab10)[4]\n\nP1 = plot(sol_tord_ois.time, sol_tord_ois.x,\n          color = myblue,\n          linewidth = 2,\n          label = \"tordeuses \\$x\\$\",\n          xlabel = \"temps\",\n          ylabel = \"densités de populations\",\n          title = \"Dynamiques des tordeuses avec\\n population d'oiseaux variable\")\n\nplot!(P1, sol_tord_ois.time, sol_tord_ois.y ./ 2,\n      color = myorange,\n      linewidth = 2,\n      label = \"oiseaux \\$y/2\\$\")\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nOn observe ici des bifurcations dynamiques avec le passage de la population de tordeuse d’une branche d’équilibre stable à l’autre, qui créé un comportement de type cycle d’hysteresis. La situation se comprend bien sur le diagramme de bifurcations (y, x). On retrace le diagramme de bifurcations.\n\n\nCode\nusing Symbolics, Polynomials\n\n@variables X\nD = Differential(X)\n\n# lieu des équilibres positifs\nY = r/(α*X)*(1-X/K)*(h^2+X^2)\n\n# dénominateur de la dérivée\ndnumerator = Symbolics.arguments(Symbolics.value(simplify(expand_derivatives(D(Y)))))[1]\n\n# on récupère les coefficients X^k du polynôme\ncoefs_dict = Symbolics.value(dnumerator).dict\ndd = Dict(Symbolics.degree(first(kv)) =&gt; kv[2] for kv ∈ coefs_dict)\n# on rajoute dans le dictionnaire le coefficient constant\ndd[0] = substitute(dnumerator, Dict(X=&gt;0))\n\n# on définit le polynôme à partir du dictionnaire\ndnumpoly = SparsePolynomial(dd, :X)\n\n# on calcule les racines en filtrant les racines entre 0 et K via une fonction anonyme s-&gt; K &gt; s &gt; 0\ndroots = filter(s -&gt; K &gt; s &gt; 0, roots(dnumpoly))\n\n# vecteur pour le tracé du diagramme de bifurcation\nxplot1 = 0.08:.01:droots[1]\nxplot2 = droots[1]:.01:droots[2]\nxplot3 = droots[2]:.01:K\nyeq1 = r.*(1 .-xplot1./K) ./ (α.*xplot1).*(h^2 .+xplot1.^2)\nyeq2 = r.*(1 .-xplot2./K) ./ (α.*xplot2).*(h^2 .+xplot2.^2)\nyeq3 = r.*(1 .-xplot3./K) ./ (α.*xplot3).*(h^2 .+xplot3.^2)\n\n# diagramme de bifurcations\nPbif = plot(yeq1, xplot1,\n            linewidth = 2,\n            color = mygreen,\n            label = \"équilibres stables\",\n            legend = :left,\n            xlabel = \"population d'oiseaux \\$y\\$\",\n            ylabel = \"population de tordeuses \\$x\\$\",\n            title = \"Diagramme de bifurcations pour le modèle de tordeuses\",\n            margin = .5Plots.cm,\n            topmargin = 1Plots.cm)\n\nplot!(Pbif, yeq2, xplot2,\n      linewidth = 2,\n      color = myred,\n      label = \"équilibres instables\")\n\nplot!(Pbif, yeq3, xplot3,\n      linewidth = 2,\n      color = mygreen,\n      label = \"\")\n\nplot!(Pbif, [0, maximum(yeq1)], [0, 0], \n      color = myred,\n      lw = 2,\n      label = \"\")\n\n\nOn trace sur ce diagramme la trajectoire simulée plus haut :\n\nplot!(Pbif, sol_tord_ois.y, sol_tord_ois.x,\n      color = myblue,\n      linewidth = 2,\n      linealpha = 0.5,\n      label = \"trajectoire\")"
  },
  {
    "objectID": "pop_interactions.html#sec-lv",
    "href": "pop_interactions.html#sec-lv",
    "title": "Populations en interaction (1)",
    "section": "Le modèle proie-prédateur de Lotka et Volterra",
    "text": "Le modèle proie-prédateur de Lotka et Volterra\nNous considérons le modèle de dynamique de populations de Lotka (1925) et Volterra (1926) :\n\n\\left\\{\\begin{array}{l}\n\\dot x = rx - c xy,\\\\\n\\dot y = bxy - m y.\n\\end{array}\\right.\n\\tag{2}\nAvec x la population de proies et y la population de prédateurs.\n\nDynamiques\nIl n’y a pas de difficulté particulière à la simulation par rapport au modèle de la tordeuse du bourgeon de l’épinette avec population d’oiseaux variables.\n\n\nCode\n# conditions initiales\nx0 = 1.0\ny0 = 1.95\netat0 = [x0, y0]\n\n# paramètres\nr = 1.0\nc = 1.0\nb = 1.0\nm = 1.0\npar_lovo = [r, c, b, m]\n\n# integration plus longue\ntspan = (0.0, 30.0)\ntstep = .01\n\n# définition du modèle\nfunction lovo(u, par, t)\n    r, c, b, m = par\n    x = u[1]\n    y = u[2]\n    dx = r*x - c*x*y\n    dy = b*x*y - m*y\n    [dx, dy]\nend\n\n# problème\nprob_lovo = ODEProblem(lovo, etat0, tspan, par_lovo, saveat = tstep)\n# intégration\nsol_lovo = solve(prob_lovo, reltol = 1e-6)\n# dataframe\nsol_lovo = DataFrame(sol_lovo)\nrename!(sol_lovo, :timestamp =&gt; :time, :value1 =&gt; :x, :value2 =&gt; :y)\n\nPlv = plot(sol_lovo.time, sol_lovo.x,\n           linewidth = 2,\n           color = myblue,\n           label = \"proies\",\n           xlabel = \"temps\",\n           ylabel = \"densité de populations\",\n           title = \"Modèle de Lotka Volterra\",\n           margin = .5Plots.cm,\n           topmargin = 1Plots.cm)\n\nplot!(Plv, sol_lovo.time, sol_lovo.y,\n      linewidth = 2,\n      color = myorange,\n      label = \"prédateurs\")\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nEspace d’état\nCommençons par tracer les isoclines nulles ainsi que l’orientation du champs de vecteur dans l’espace d’état. Ce dernier utilise la fonction quiver().\n\n# on redéfinit des fonctions qui renvoient les composantes de la dérivée mises à l'échelle\nscale = 10\nder_x(x, y) = lovo([x y], par_lovo, 0)[1]/scale\nder_y(x, y) = lovo([x y], par_lovo, 0)[2]/scale\n\n# on définit un ensemble de valeur de x et y formant une grille \n# sur laquelle évaluer le champs de vecteurs\nxrange = range(0., 2, length=11)'  # note ' : on va broadcaster pour créer la grille via der_x.() et der_y.()\nyrange = range(0. ,2, length=11)\n\n# champs de vecteurs\nPlan = quiver(xrange, yrange, \n       quiver = (der_x.(xrange, yrange), der_y.(xrange, yrange)),\n       ylim = (-0.05, 2),\n       xlim = (-0.05, 2),\n       color = :lightgray,\n     grid = false,\n       title = \"Modèle de Lotka Volterra\",\n       xlabel = \"proies\",\n       ylabel = \"prédateurs\",\n       margin = .5Plots.cm,\n       topmargin = 1Plots.cm)\n\nOn rajoute les isoclines nulles et les équilibres :\n\n\nCode\n# isoclines nulles\nxplot = 0:2\nyplot = 0:2\nplot!(Plan, xplot, ones(length(xplot)).*r./c,\n      linewidth = 2,\n      color = mygreen,\n      label = \"\\$\\\\dot x = 0\\$\")\nplot!(Plan, zeros(length(yplot)), yplot,\n      linewidth = 2,\n      color = mygreen,\n      label = \"\")\nplot!(Plan, ones(length(yplot)).*m./b, yplot,\n      linewidth = 2,\n      color = myred,\n      label = \"\\$\\\\dot y = 0\\$\")\nplot!(Plan, xplot, zeros(length(xplot)), \n      linewidth = 2,\n      color = myred,\n      label = \"\")\n\n# équilibres\nplot!(Plan, (0, 0),\n      markershape = :circle,\n      color= myred,\n      label = \"\")\nplot!(Plan, (m/b, r/c),\n      markershape = :circle,\n      color= myorange,\n      label = \"\")\n\n\nEt enfin la trajectoire :\n\n\nCode\n# trajectoire\nplot!(Plan,  sol_lovo.x, sol_lovo.y,\n      color = myblue,\n      linewidth = 2,\n      label = \"trajectoire\")\n\ndisplay(Plan)\n\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 1: Plan de phase du modèle de Lotka Volterra\n\n\n\n\n\nIntégrale première\nNous illustrons en 3D l’intégrale première du modèle et superposons la trajectoire simulée plus haut sur ce graphique. L’intégrale première s’écrit : \nH(x,y)= -r\\log(y)+c y-m\\log(x) + bx\n\n\n# l'intégrale première\nfunction int_prem(x, y, par = par_lovo)\n      r, c, b, m = par\n      -r*log(y) + c*y - m*log(x) + b*x\nend\n\nPour tracer le graphique en 3D, nous utilisons le backend plotly.\n\nplotly()\n\n# grille x, y\nxsurf = .2: .1: 3\nysurf = .2:.1: 3\n\n# calcul de la surface via une compréhension de liste\nzsurf = [int_prem(x, y, par_lovo) for x in xsurf, y in ysurf]\n# et H(x0, y0)\nzplane = [int_prem(x0, y0, par_lovo) for x in xsurf, y in ysurf]\n\n# on trace H(x0, y0)\nPsurf = plot(xsurf, ysurf, zplane, \n              st = :surface, \n              color = myorange, \n              alpha =.5, \n              label = \"\") \n\n# l'intégrale première\nplot!(Psurf, xsurf, ysurf, zsurf, \n             st=:surface, \n             alpha = .6, \n             camera = (30, 10), \n             color = :viridis,\n             xlabel = \"proies\",\n             ylabel = \"prédateurs\",\n             title = \"Intégrale première du modèle de Lotka Volterra\")\n\n# la trajectoire\nplot!(Psurf, sol_lovo.x, sol_lovo.y, ones(length(sol_lovo.x)).*int_prem(x0, y0, par_lovo), \n      color = myred, \n      lw=4, \n      label = \"\")\n\n    \n    \n\n\n\n\nFinissons ce TP en simulant le modèle de Rosenzweig MacArthur, par ici."
  },
  {
    "objectID": "pop_interactions2.html",
    "href": "pop_interactions2.html",
    "title": "Populations en interaction (2)",
    "section": "",
    "text": "using DifferentialEquations, DataFrames\n\n# conditions initiales\nx0 = 1.0\ny0 = 1.95\netat0 = [x0, y0]\n\n# paramètres\nr = 1.0\nc = 1.0\nb = 1.0\nm = 1.0\npar_lovo = [r, c, b, m]\n\n# integration plus longue\ntspan = (0.0, 30.0)\ntstep = .01\n\n# définition du modèle\nfunction lovo(u, par, t)\n    r, c, b, m = par\n    x = u[1]\n    y = u[2]\n    dx = r*x - c*x*y\n    dy = b*x*y - m*y\n    [dx, dy]\nend\n\n# problème\nprob_lovo = ODEProblem(lovo, etat0, tspan, par_lovo, saveat = tstep)\n# intégration\nsol_lovo = solve(prob_lovo, reltol = 1e-6)\n# dataframe\nsol_lovo = DataFrame(sol_lovo)\nrename!(sol_lovo, :timestamp =&gt; :time, :value1 =&gt; :x, :value2 =&gt; :y)\n\n\nfunction int_prem(x, y, par = par_lovo)\n      r, c, b, m = par\n      -r*log(y) + c*y - m*log(x) + b*x\nend\n\n\nusing GLMakie\n\nxsurf = .2: .1: 3\nysurf = .2:.1: 3\nzsurf = [int_prem(x, y, par_lovo) for x in xsurf, y in ysurf]\n\nsurface(xsurf, ysurf, zsurf, \n        axis = (type=Axis3,xlabel = \"proies \\$x\\$\",\n        ylabel = \"prédateurs \\$y\\$\"))\n\n\n\n\n\n\n\n\n\nReusehttps://creativecommons.org/licenses/by-nc/4.0/"
  }
]