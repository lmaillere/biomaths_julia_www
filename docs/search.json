[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Introduction",
    "section": "",
    "text": "Ces pages proposent une introduction à la simulation d’équations différentielles avec Julia, centrée sur la simulation de modèles classiques en dynamique des populations.\nCes pages sont structurées comme suit :\nLe site contient aussi du matétiel supplémentaire pour compléments plus avancés (graphiques, methodes d’intégration alternatives, équations de réaction-diffusion)."
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "A Propos",
    "section": "",
    "text": "Ces pages ont été générées avec Quarto, et Julia (version 1.10.0).\nLes principaux packages utilisés sont DifferentialEquations.jl, Plots.jl, DataFrames.jl, Makie.jl, Polynomials.jl et Symbolics.jl.\n\n\n\n\n\nReusehttps://creativecommons.org/licenses/by-nc/4.0/"
  },
  {
    "objectID": "pop_isolees.html",
    "href": "pop_isolees.html",
    "title": "Populations isolées",
    "section": "",
    "text": "Nous considérons le modèle proposé par Malthus (1798) : \n\\dot x = (n-m)x,\n\\tag{1} avec n le taux de natalité, et m le taux de mortalité.\n\n\nPour simuler ce modèle, c’est à dire intégrer numériquement les solutions au problème de Cauchy correspondant à l’Equation 1 avec x(0)=x_0\\geq0, nous allons utiliser les routines de DifferentialEquations.jl avec la méthode par défaut. Nous utiliserons aussi le package Plots.jl pour les représentations graphiques1.1 si vous n’avez jamais installé un package, il faudra commencer par le faire avant de pouvoir l’utiliser…\n\nusing DifferentialEquations\nusing Plots\n\n\n\n\nNous définissions la condition initiale de la simulation :\n\nx0 = 0.1\n\nNous définissons les paramètres, et les encapsulons dans un vecteur de paramètres :\n\nn = 3.0     # natalité\nm = 2.0     # mortalité\npar_malthus = [n, m] # packing in an array\n\nEnfin, les propriétés du temps d’intégration :\n\ntspan = (0.0, 10.0)\ntstep = 0.1\n\n\n\n\nOn définit le modèle comme une fonction renvoyant la dérivée de x en fonction de l’état (u est la notation pour DifferentialEquations.jl), de paramètres (p), et du temps (t). L’ordre des arguments est important, c’est sous cette forme que les routines d’intégration attendent le modèle.\n\nfunction malthus(u, p, t)\n    n, m = p                # unpacking\n    x = u                # use x notation\n    return dx = (n-m)x      # return derivative\nend\n\n\n\n\n\n\n\nNote\n\n\n\nL’ordre des arguments u, p, t est important pour le solver de DifferentialEquations.jl.\n\n\n\n\n\nOn commence par définir le problème de Cauchy à intégrer, comme un ODEProblem avec arguments: le modèle, la condition initiale, les bornes d’intégration, les paramètres ainsi que l’option saveat = tstep permettant de récupérer la solution tout les tstep pas de temps (il y a plein d’options de sortie de l’intégration, dont même une fonction du temps !)\n\nprob_malthus = ODEProblem(\n    malthus,          # modèle\n    x0,               # condition initiale\n    tspan,            # tspan\n    par_malthus;      # paramètres\n    saveat = tstep,   # keyword argument, option de sortie\n)\n\nOn intègre le modèle via solve, défini par DifferentialEquations.jl pour des struct de type ODEProblem :\n\nsol_malthus = solve(prob_malthus)\n\nLe type de solution renvoyé par le solveur est assez complexe et comprend de nombreux champs informatifs sur le calcul. On peut accéder au temps de simulation via sol_malthus.t :\n\nfirst(sol_malthus.t, 3)\n\n3-element Vector{Float64}:\n 0.0\n 0.1\n 0.2\n\n\nainsi qu’aux valeurs de la variable x calculées le long du temps via sol_matlhus.u :\n\nfirst(sol_malthus.u, 3)\n\n3-element Vector{Float64}:\n 0.1\n 0.1105170918098962\n 0.12214028021690636\n\n\nMême si ce n’est pas indispensable, il est possible de transformer la solution renvoyée facilement en DataFrame, qui peut permettre des manipulations plus faciles.\n\nusing DataFrames\n\nsol_malthus = DataFrame(sol_malthus)\nrename!(sol_malthus, :timestamp =&gt; :time, :value =&gt; :x)\n\n\n\n\n\n\n\nNote\n\n\n\nremarquez la fonction rename! qui modifie en place le dataframe. Par convention les fonctions dont le nom finit par ! modifient leur argument en place.\n\n\nsi bien que :\n\nfirst(sol_malthus, 3)\n\n3×2 DataFrame\n\n\n\nRow\ntime\nx\n\n\n\nFloat64\nFloat64\n\n\n\n\n1\n0.0\n0.1\n\n\n2\n0.1\n0.110517\n\n\n3\n0.2\n0.12214\n\n\n\n\n\n\n\n\n\nOn peut représenter graphiquement la simulation de la croissance de la population au cours du temps (ici via le dataframe).\n\nplot(\n    sol_malthus.time,                   # abscisses\n    sol_malthus.x;                      # ordonnées\n    palette = :tab10,                   # palette de couleurs\n    linewidth = 2,\n    title = \"\\n Modèle de Malthus \\$n=$n, m=$m\\$\",\n    label = \"population \\$x\\$\",\n    ylabel = \"densité de population \\$x(t)\\$\",\n    xlabel = \"temps \\$t\\$\",\n    margin = .5Plots.cm,\n    topmargin = 1Plots.cm,\n)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nLes titres et autres chaînes de caractères peuvent utiliser des formules LaTeX via \\$, e.g. \"\\$x\\$\".\nLa notation \"$m\" accède à la valeur du paramètre m et la renvoit dans la chaine de caractères."
  },
  {
    "objectID": "pop_interactions.html",
    "href": "pop_interactions.html",
    "title": "Populations en interaction (1)",
    "section": "",
    "text": "Pour débuter cette partie sur les populations en interactions, nous reprenons le modèle de tordeuse de Ludwig, Jones, and Holling (1978) en supposant que la population d’oiseaux réagit (lentement) à la démographie des tordeuses, via la prédation.\nLe changement principal ici est la dimension du modèle (dimension 2) : les tailles de populations de tordeuses x et d’oiseaux y varient toutes deux au cours du temps en s’influençant l’une l’autre, avec une population d’oiseaux qui varie lentement (d’où le paramètre \\varepsilon supposé petit) par rapport à celle des tordeuses.\nLe modèle prend la forme : \n\\left\\{\n\\begin{array}{l}\n\\displaystyle \\dot x = rx\\left(1-\\frac{x}{K}\\right) - \\frac{\\alpha x^2}{h^2+x^2}\\ y \\\\[.3cm]\n\\displaystyle \\dot y = \\varepsilon \\left(\\frac{n \\alpha x^2}{h^2+x^2}\\ y -m y\\right)\n\\end{array}\n\\right.\n\\tag{1}\nIl faut ajuster un peu la manière de coder pour prendre en compte ces deux dimensions. Commençons par les paramètres divers.\n\nusing DifferentialEquations\nusing Plots\nusing DataFrames\n\n# paramètres\nr = 5.0      # natalité\nK = 10.0     # mortalité\nα = 1.0      # taux max de prédation\nh = 0.5      # constante de demi-saturation\n\nϵ = 0.01     # timescale, \\epsilon + TAB\nn = 5.0      # gain à la prédation\nm = 3.0      # mortalité\n\npar_tord_ois = [r, K, α, h, ϵ, n, m]\n\n# temps d'intégration\ntspan = (0.0, 400.0)\ntstep = 0.02\n\n# conditions initiales\nx0 = 1.0    # tordeuses\ny0 = 2.5    # oiseaux\netat0 = [x0, y0]\n\nPuis le modèle :\n\nfunction tord_ois(u, p, t)\n    r, K, α, h, ϵ, n, m = p\n    x = u[1]\n    y = u[2]\n\n    dx = r*x*(1 - x/K) - α*x^2/(h^2 + x^2)*y\n    dy = ϵ*(n*α*x^2/(h^2 + x^2)*y - m*y)\n\n    return [dx, dy]\nend\n\nProblème d’intégration et simulation :\n\nprob_tord_ois = ODEProblem(\n      tord_ois,\n      etat0,\n      tspan,\n      par_tord_ois;\n      saveat = tstep,\n)\n\nsol_tord_ois = solve(prob_tord_ois, reltol = 1e-6)\n\nsol_tord_ois = DataFrame(sol_tord_ois)\nrename!(sol_tord_ois, :timestamp =&gt; :time, :value1 =&gt; :x, :value2 =&gt; :y)\n\nReprésentation graphique contre le temps\n\n# color definitions\nmygreen = palette(:tab10)[3]\nmyorange = palette(:tab10)[2]\nmyblue = palette(:tab10)[1]\nmyred = palette(:tab10)[4]\n\n# initialisation graphique et solution simulée\nfig1 = plot(\n    sol_tord_ois.time,\n    sol_tord_ois.x;\n    color = myblue,\n    linewidth = 2,\n    label = \"tordeuses \\$x\\$\",\n    xlabel = \"temps\",\n    ylabel = \"densités de populations\",\n    title = \"Dynamiques des tordeuses avec\\n population d'oiseaux variable\",\n)\n\nplot!(\n    fig1,\n    sol_tord_ois.time,\n    sol_tord_ois.y ./ 2,  # scale by 2 for aesthetics\n    color = myorange,\n    linewidth = 2,\n    label = \"oiseaux \\$y/2\\$\",\n)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nOn observe ici des bifurcations dynamiques avec le passage de la population de tordeuse d’une branche d’équilibre stable à l’autre, qui créé un comportement de type cycle d’hysteresis.\nLa situation se comprend bien sur le diagramme de bifurcations (y, x). On retrace le diagramme de bifurcations (cf. la page sur les populations exploitées).\n\n\nCode\nusing Symbolics\nusing Polynomials\n\n@variables X\nD = Differential(X)\n\n# lieu des équilibres positifs\nY = r/(α*X)*(1-X/K)*(h^2+X^2)\n\n# dénominateur de la dérivée\ndnumerator = Symbolics.arguments(Symbolics.value(simplify(expand_derivatives(D(Y)))))[1]\n\n# on récupère les coefficients X^k du polynôme\ncoefs_dict = Symbolics.value(dnumerator).dict\ndd = Dict(Symbolics.degree(first(kv)) =&gt; kv[2] for kv ∈ coefs_dict)\n# on rajoute dans le dictionnaire le coefficient constant\ndd[0] = substitute(dnumerator, Dict(X=&gt;0))\n\n# on définit le polynôme à partir du dictionnaire\ndnumpoly = SparsePolynomial(dd, :X)\n\n# on calcule les racines en filtrant les racines entre 0 et K via une fonction anonyme s-&gt; K &gt; s &gt; 0\ndroots = filter(s -&gt; K &gt; s &gt; 0, roots(dnumpoly))\n\n# vecteur pour le tracé du diagramme de bifurcation\nxplot1 = 0.08:.01:droots[1]\nxplot2 = droots[1]:.01:droots[2]\nxplot3 = droots[2]:.01:K\nyeq1 = [r*(1 - x/K)/(α*x)*(h^2 + x^2) for x in xplot1]\nyeq2 = [r*(1 - x/K)/(α*x)*(h^2 + x^2) for x in xplot2]\nyeq3 = [r*(1 - x/K)/(α*x)*(h^2 + x^2) for x in xplot3]\n\n# diagramme de bifurcations\nfigbif = plot(\n    yeq1,\n    xplot1;\n    linewidth = 2,\n    color = mygreen,\n    label = \"équilibres stables\",\n    legend = :left,\n    xlabel = \"population d'oiseaux \\$y\\$\",\n    ylabel = \"population de tordeuses \\$x\\$\",\n    title = \"Diagramme de bifurcations pour le modèle de tordeuses\",\n    margin = .5Plots.cm,\n    topmargin = 1Plots.cm,\n)\n\nplot!(\n    figbif,\n    yeq2,\n    xplot2;\n    linewidth = 2,\n    color = myred,\n    label = \"équilibres instables\",\n)\n\nplot!(\n    figbif,\n    yeq3,\n    xplot3;\n    linewidth = 2,\n    color = mygreen,\n    label = \"\",\n)\n\nplot!(\n    figbif,\n    [0, maximum(yeq1)],\n    [0, 0];\n    color = myred,\n    lw = 2,\n    label = \"\",\n)\n\n\nOn trace sur ce diagramme la trajectoire simulée plus haut :\n\nplot!(\n    figbif,\n    sol_tord_ois.y,\n    sol_tord_ois.x;\n    color = myblue,\n    linewidth = 2,\n    linealpha = 0.5,\n    label = \"trajectoire\",\n)"
  },
  {
    "objectID": "pop_exploitees.html",
    "href": "pop_exploitees.html",
    "title": "Populations exploitées",
    "section": "",
    "text": "Nous reprenons le modèle précédent sur l’effet Allee mais en prenant en compte des prélèvements externes avec un effort (taux) de prélèvement E : \n\\dot x = r x \\left(\\frac{x}{\\epsilon}-1\\right)\\left(1-\\frac{x}{K}\\right)-Ex.\n\\tag{1}\nLa simulation de ce modèle pour différentes valeurs de E (par exemple E=0.2 ou E=0.85) ne présente aucune difficulté supplémentaire.\nNous allons maintenant nous intéresser à une situation où l’effort de prélèvement E varie au cours du temps entre une valeur soutenable E_s (par exemple 0.2), et une valeur excessive E_x (par exemple 0.85).\nL’attendu théorique est que si les prélèvements sont maintenus à une valeur excessive E_x trop longtemps, la population disparait irrémédiablement même si les prélèvements sont par la suite ramenés à une valeur initialement soutenable E_s.\n\n\n\nusing DifferentialEquations\nusing Plots\nusing DataFrames\n\nDéfinissons une fonction effort() dépendant du temps, qui renvoit :\n\nE_s~ si ~t&lt;T_s\nE_x~ si ~t\\in [T_s+T_x[\nà nouveau E_s~ si ~t\\geq T_s+T_x\n\n\n# paramètres\nE_s = 0.2\nE_x = 0.85\nT_s = 10.0\nT_x = 9.0\n\np_effort = [E_s, E_x, T_s, T_x]\n\nfunction effort(t, p)\n    E_s, E_x, T_s, T_x = p\n\n    if t &lt; T_s || t &gt;= T_s + T_x\n        return E_s\n    elseif t &gt;= T_s && t &lt; T_s + T_x\n        return E_x\n    end\nend\n\n\n\n\n\n\n\nNote\n\n\n\nRemarquez les opérateurs booléens “ou” || et “et” &&, ainsi que la structure du test if.\n\n\nLa fonction correspond bien à nos hypothèses :\n\n\nCode\nt2plot = 0: .1: 30\n\nplot(\n    t2plot,                                 # abscisses\n    [effort(t, p_effort) for t in t2plot];  # ordonnées\n    palette = :tab10,\n    linewidth = 2,\n    label = \"\\$E(t)\\$\",\n    xlabel = \"temps\",\n    ylabel = \"\\$E(t)\\$\",\n    title = \"Effort de pêche \\$E(t)\\$\",\n    margin = .5Plots.cm,\n    topmargin = 1Plots.cm,\n)\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nRemarquez la construction des ordonnées correspondant à la fonction effort via une compréhension de liste : [effort(t, p_effort) for t in t2plot].\n\n\n\n\n\nNous définissons les paramètres du modèle, la condition initiale et le temps d’intégration :\n\n\nCode\nx0 = 10.0\n\ntspan = (0.0, 30.0)\ntstep = 0.1\n\nr = 1.0\nK = 10.0\nepsilon = 2.0\np_allee = [r, K, epsilon]\n\n\nNous définissons le système dynamique comme précédemment, à la différence que nous prévoyons de surcharger l’argument p dans le problème d’intégration sous forme d’un vecteur comprennant :\n\nle vecteur de paramètres p_allee en première position\nle vecteur de paramètres p_effort en seconde position\net la fonction effort en troisième position1\n\n1 En Julia tout est passable en argument, des variables aux fonctions et plus.\np_evar = [p_allee, p_effort, effort]\n\n\nfunction allee_evar(u, p, t)\n    r, K, epsilon = p[1]        # unpacking model parameters\n    p_effort = p[2]             # unpacking fishing effort parameters\n    E = p[3]                    # unpacking fishing effort function\n    x = u                    # use x notation\n\n    return dx = r*x*(x/epsilon - 1)*(1 - x/K) - E(t, p_effort)*x\nend\n\nL’intégration en elle-même suit le shéma vu précédemment, si ce n’est que l’argument de paramètres doit bien refléter ce qui est attendu par la fonction allee_evar(). La simulation en elle-même est effectuée avec une modification de la précision relative de l’intégration reltol = 1e-6, la précision par défaut n’étant pas suffisante ici.\n\nprob_allee_evar = ODEProblem(\n      allee_evar,\n      x0,\n      tspan,\n      p_evar;\n      saveat = tstep,\n)\n\nsol_allee_evar = solve(prob_allee_evar; reltol = 1e-6)\n\nsol_allee_evar = DataFrame(sol_allee_evar)\nrename!(sol_allee_evar, :timestamp =&gt; :time, :value =&gt; :x)\n\n\n\n\n\n\n\nNote\n\n\n\nIci nous avons imposé une tolérance plus précise au solver via le keyword argument reltol = 1e-6.\n\n\nFinalement, nous pouvons représenter graphiquement la solution contre le temps. Ici, malgré la perturbation violente induite par la période de surexploitation, le pêcherie retrouve une situation soutenable après un retour à E=E_s.\n\n\nCode\nplot(\n    sol_allee_evar.time,\n    sol_allee_evar.x;\n    label = \"\\$x(t)\\$\",\n    linewidth = 2,\n    xlabel = \"temps\",\n    ylabel = \"densité de population \\$x(t)\\$\",\n    title = \"Effort de pêche variant dans le temps\",\n    palette = :tab10,\n    legend = :left,\n    margin = .5Plots.cm,\n    topmargin = 1Plots.cm,\n)\n\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 1: Persistence dans le modèle avec effet Allee et prélèvements\n\n\n\nLorsque la période de surexploitation de la population est trop longue (e.g. ici T_x=9.2), la population ne parvient pas à récupérer malgré le retour à un effort de prélèvement soutenable.\n\n\nCode\n# change parameter\nT_x2 = 9.2\n\np_effort2 = [E_s, E_x, T_s, T_x2]\np_evar2 = [p_allee, p_effort2, effort]\n\n# define new problem and integrate\nprob_allee_evar2 = ODEProblem(\n      allee_evar,\n      x0,\n      tspan,\n      p_evar2,\n      saveat = tstep\n)\n\nsol_allee_evar2 = solve(prob_allee_evar2, reltol = 1e-6)\n\nsol_allee_evar2 = DataFrame(sol_allee_evar2)\nrename!(sol_allee_evar2, :timestamp =&gt; :time, :value =&gt; :x)\n\n# plot\nplot(\n    sol_allee_evar2.time, sol_allee_evar2.x,\n    label = \"\\$x(t)\\$\";\n    linewidth = 2,\n    xlabel = \"temps\",\n    ylabel = \"densité de population \\$x(t)\\$\",\n    title = \"Effort de pêche variant dans le temps\",\n    palette = :tab10,\n    legend = :left,\n    margin = .5Plots.cm,\n    topmargin = 1Plots.cm,\n)\n\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 2: Extinction dans le modèle avec effet Allee et prélèvements\n\n\n\n\n\n\nIl s’agit ici de représenter dans l’espace (E, x) l’évolution conjointe de l’effort de pêche et de la densité de la population au cours du temps, afin de mieux comprendre le phénomène d’extinction. Dans cet objectif, on tracera aussi le lieu des équilibres de la population x^*(E) en fonction d’une valeur de E constante, i.e. : \nx^*(E) = 0,\n ce qui est équivalent à : \nE = r\\left(\\frac{x^*(E)}{\\epsilon}-1\\right)\\left(1-\\frac{x^*(E)}{K}\\right).\n\nNous allons tracer les deux situations vues à la section précédente dans deux sous figures. Commençons par les lieux des équilibres, qui sont les mêmes dans les deux situations.\nDéfinissons le lieu des équilibres positifs :\n\n# parabole pour les equilibres positifs\nfunction eeqpos(x, par = p_allee)\n    r, K, epsilon = par\n    return r*(x/epsilon -1)*(1-x/K)\nend\n\nPuis traçons ce lieu dans le plan (E,x) (il y a deux branches une stable et une instable pour les équilibres positifs qui se rejoignent en x^* = (K+\\epsilon)/2, nous les traçons séparément)\n\n# vecteurs pour le tracé\ne2plot = 0:.1:1\nx2plot1 = epsilon:.02:(K+epsilon)/2\nx2plot2 = (K+epsilon)/2:.02:K\n\n# on définit des couleurs spécifiques depuis la palette :pal10\nmygreen = palette(:tab10)[3]\nmyorange = palette(:tab10)[2]\nmyblue = palette(:tab10)[1]\nmyred = palette(:tab10)[4]\n\n# plot\nfig1 = plot(\n    e2plot,\n    zeros(length(e2plot));\n    color = mygreen,\n    linewidth = 2,\n    label = \"équilibres stables\",\n    ylabel = \"densité de population \\$x\\$\",\n    xlabel = \"effort de pêche \\$E\\$\",\n    legend = :left,\n)\n\nplot!(\n    fig1,\n    eeqpos.(x2plot1),\n    x2plot1;\n    color= myorange,\n    linewidth = 2,\n    label = \"équilibre instable\",\n)\n\nplot!(\n    fig1,\n    eeqpos.(x2plot2),\n    x2plot2;\n    color= mygreen,\n    linewidth = 2,\n    label =\"\",\n)\n\ndisplay(fig1)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nRemarquez le broadcast (calcul terme à terme) sur les ordonnées des équilibres positifs en utilisant eeqpos.. On aurait pu procéder par compréhension de liste: [eeqpos(x) for x in x2plot2].\n\n\nOn prépare un graphique fig2 avec les mêmes éléments que dans fig1 :\n\nfig2 = deepcopy(fig1) # on fait une copie complète de fig1\n\nFinalement, on complète fig1 et fig2 avec quelques annotations et les trajectoires calculées plus haut en fonction de l’effort de pêche variable au cours du temps, et on trace les résultats en deux sous-figures :\n\n# annotations\nannotate!(fig1, .35, 8.5, Plots.text(\"branche stable\", 10, rotation=-28))\nannotate!(fig1, .4, 2.7, Plots.text(\"branche instable\", 10, rotation=28))\nannotate!(fig2, .4, 2.7, Plots.text(\"branche instable\", 10, rotation=28))\nannotate!(fig2, .35, 8.5, Plots.text(\"branche stable\", 10, rotation=-28))\n\n# peche durable sur fig1\nplot!(\n    fig1,\n    [effort(t, p_effort) for t in sol_allee_evar.time],\n    sol_allee_evar.x;\n    color = myblue,\n    linewidth = 2,\n    label = \"trajectoire\",\n)\n\n# surpeche sur fig2\nplot!(\n    fig2,\n    [effort(t, p_effort2) for t in sol_allee_evar2.time], sol_allee_evar2.x;\n    color = myblue,\n    linewidth = 2,\n    label = \"trajectoire\",\n)\n\n# figure reprenant les deux sous figures fig1 et fig2\nplot(\n    fig1,\n    fig2;\n    suptitle = \"Effets Allee et prélèvements\",\n    margin = .5Plots.cm,\n    topmargin = 1Plots.cm,\n)\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\nFigure 3: bifurcation pli et catastrophe dans le modèle avec effet Allee et prélèvements"
  },
  {
    "objectID": "pop_isolees.html#sec-malthus",
    "href": "pop_isolees.html#sec-malthus",
    "title": "Populations isolées",
    "section": "",
    "text": "Nous considérons le modèle proposé par Malthus (1798) : \n\\dot x = (n-m)x,\n\\tag{1} avec n le taux de natalité, et m le taux de mortalité.\n\n\nPour simuler ce modèle, c’est à dire intégrer numériquement les solutions au problème de Cauchy correspondant à l’Equation 1 avec x(0)=x_0\\geq0, nous allons utiliser les routines de DifferentialEquations.jl avec la méthode par défaut. Nous utiliserons aussi le package Plots.jl pour les représentations graphiques1.1 si vous n’avez jamais installé un package, il faudra commencer par le faire avant de pouvoir l’utiliser…\n\nusing DifferentialEquations\nusing Plots\n\n\n\n\nNous définissions la condition initiale de la simulation :\n\nx0 = 0.1\n\nNous définissons les paramètres, et les encapsulons dans un vecteur de paramètres :\n\nn = 3.0     # natalité\nm = 2.0     # mortalité\npar_malthus = [n, m] # packing in an array\n\nEnfin, les propriétés du temps d’intégration :\n\ntspan = (0.0, 10.0)\ntstep = 0.1\n\n\n\n\nOn définit le modèle comme une fonction renvoyant la dérivée de x en fonction de l’état (u est la notation pour DifferentialEquations.jl), de paramètres (p), et du temps (t). L’ordre des arguments est important, c’est sous cette forme que les routines d’intégration attendent le modèle.\n\nfunction malthus(u, p, t)\n    n, m = p                # unpacking\n    x = u                # use x notation\n    return dx = (n-m)x      # return derivative\nend\n\n\n\n\n\n\n\nNote\n\n\n\nL’ordre des arguments u, p, t est important pour le solver de DifferentialEquations.jl.\n\n\n\n\n\nOn commence par définir le problème de Cauchy à intégrer, comme un ODEProblem avec arguments: le modèle, la condition initiale, les bornes d’intégration, les paramètres ainsi que l’option saveat = tstep permettant de récupérer la solution tout les tstep pas de temps (il y a plein d’options de sortie de l’intégration, dont même une fonction du temps !)\n\nprob_malthus = ODEProblem(\n    malthus,          # modèle\n    x0,               # condition initiale\n    tspan,            # tspan\n    par_malthus;      # paramètres\n    saveat = tstep,   # keyword argument, option de sortie\n)\n\nOn intègre le modèle via solve, défini par DifferentialEquations.jl pour des struct de type ODEProblem :\n\nsol_malthus = solve(prob_malthus)\n\nLe type de solution renvoyé par le solveur est assez complexe et comprend de nombreux champs informatifs sur le calcul. On peut accéder au temps de simulation via sol_malthus.t :\n\nfirst(sol_malthus.t, 3)\n\n3-element Vector{Float64}:\n 0.0\n 0.1\n 0.2\n\n\nainsi qu’aux valeurs de la variable x calculées le long du temps via sol_matlhus.u :\n\nfirst(sol_malthus.u, 3)\n\n3-element Vector{Float64}:\n 0.1\n 0.1105170918098962\n 0.12214028021690636\n\n\nMême si ce n’est pas indispensable, il est possible de transformer la solution renvoyée facilement en DataFrame, qui peut permettre des manipulations plus faciles.\n\nusing DataFrames\n\nsol_malthus = DataFrame(sol_malthus)\nrename!(sol_malthus, :timestamp =&gt; :time, :value =&gt; :x)\n\n\n\n\n\n\n\nNote\n\n\n\nremarquez la fonction rename! qui modifie en place le dataframe. Par convention les fonctions dont le nom finit par ! modifient leur argument en place.\n\n\nsi bien que :\n\nfirst(sol_malthus, 3)\n\n3×2 DataFrame\n\n\n\nRow\ntime\nx\n\n\n\nFloat64\nFloat64\n\n\n\n\n1\n0.0\n0.1\n\n\n2\n0.1\n0.110517\n\n\n3\n0.2\n0.12214\n\n\n\n\n\n\n\n\n\nOn peut représenter graphiquement la simulation de la croissance de la population au cours du temps (ici via le dataframe).\n\nplot(\n    sol_malthus.time,                   # abscisses\n    sol_malthus.x;                      # ordonnées\n    palette = :tab10,                   # palette de couleurs\n    linewidth = 2,\n    title = \"\\n Modèle de Malthus \\$n=$n, m=$m\\$\",\n    label = \"population \\$x\\$\",\n    ylabel = \"densité de population \\$x(t)\\$\",\n    xlabel = \"temps \\$t\\$\",\n    margin = .5Plots.cm,\n    topmargin = 1Plots.cm,\n)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nLes titres et autres chaînes de caractères peuvent utiliser des formules LaTeX via \\$, e.g. \"\\$x\\$\".\nLa notation \"$m\" accède à la valeur du paramètre m et la renvoit dans la chaine de caractères."
  },
  {
    "objectID": "pop_isolees.html#préliminaires",
    "href": "pop_isolees.html#préliminaires",
    "title": "Populations isolées",
    "section": "Préliminaires",
    "text": "Préliminaires\nPour simuler ce modèle, c’est à dire intégrer numériquement les solutions au problème de Cauchy correspondant à l’Equation 1 avec x(0)=x_0\\geq0, nous allons utiliser les routines de DifferentialEquations.jl avec une méthode utilisant des tableaux statiques pour la rapidité d’exécution (package StaticArrays.jl). Nous utiliserons aussi le package Plots.jl pour les représentations graphiques.\n\nusing Plots, DifferentialEquations, StaticArrays"
  },
  {
    "objectID": "pop_isolees.html#conditions-initiales-paramètres-et-temps",
    "href": "pop_isolees.html#conditions-initiales-paramètres-et-temps",
    "title": "Populations isolées",
    "section": "Conditions initiales, paramètres et temps",
    "text": "Conditions initiales, paramètres et temps\nNous définissions la condition initiale de la simulation, et l’assignons dans un vecteur statique etat0 :\n\nx0 = 0.1\netat0 = @SVector [x0]\n\nNous définissons les paramètres, et les encapsulons dans un vecteur de paramètres :\n\nn = 3.0     # natalité\nm = 2.0     # morrtalité\npar_malthus = [n, m]\n\nEnfin, les propriétés du temps d’intégration :\n\ntspan = (0.0, 5.0)\ntstep = 0.1"
  },
  {
    "objectID": "pop_isolees.html#section",
    "href": "pop_isolees.html#section",
    "title": "Populations isolées",
    "section": "",
    "text": "On peut représenter graphiquement la simulation de la croissance de la population au cours du temps (ici via le dataframe).\n\nplot(sol_malthus.time, sol_malthus.x,\n    palette = :tab10,\n    linewidth = 2,\n    title = \"\\n Modèle de Malthus\",\n    label = \"population \" * L\"x\",  # latex strings, makrdown latex is off in labels\n    ylabel = \"densité de population \\$x(t)\\$\", # latex markdown is ok in axis label\n    xlabel = \"temps \\$t\\$\",\n    margin = .5Plots.cm,\n    topmargin = 1Plots.cm)"
  },
  {
    "objectID": "pop_isolees.html#sec-logistic",
    "href": "pop_isolees.html#sec-logistic",
    "title": "Populations isolées",
    "section": "Le modèle logistique",
    "text": "Le modèle logistique\nNous considérons ici le modèle “logistique” proposé par Verhulst (1838) :\n\n\\dot x = r x \\left(1-\\frac{x}{K}\\right),\n\\tag{2} avec r le taux de croissance intrinsèque de la population et K la capacité de charge de l’environnement.\nIl n’y a pas de difficulté particulière par rapport aux simulations précedentes. On va réutiliser la condition initiale et les paramètres de temps définis précédemment.\nIl faut cependant définir les paramètres du modèle Equation 2 :\n\n\nCode\nr = 1.0      # natalité\nK = 10.0     # mortalité\npar_logistic = [r, K] # packing\n\n\nainsi que le nouveau système dynamique :\n\n\nCode\nfunction logistic(u, p, t)\n    r, K = p            # unpacking\n    x = u            # use x notation\n    return dx = r*x*(1-x/K)    # return derivative\nend\n\n\net le problème de Cauchy correspondant :\n\n\nCode\nprob_logistic = ODEProblem(\n    logistic,         # modèle\n    x0,               # condition initiale\n    tspan,            # tspan\n    par_logistic;     # paramètres\n    saveat = tstep,   # option de sortie\n)\n\n\nOn simule et on transforme la solution en dataframe :\n\n\nCode\nsol_logistic = solve(prob_logistic)\n\nsol_logistic = DataFrame(sol_logistic)\nrename!(sol_logistic, :timestamp =&gt; :time, :value =&gt; :x)\n\n\nOn trace la solution, en rajoutant les équilibres stable (x=K) et instable (x=0) :\n\n# solution\nplot(\n    sol_logistic.time,\n    sol_logistic.x;\n    palette = :tab10,\n    linewidth = 2,\n    title = \"\\n Modèle logistique \\$r=$r, K=$K\\$\",\n    label = \"population \\$x\\$\",\n    legend = :right,\n    ylabel = \"densité de population \\$x(t)\\$\",\n    xlabel = \"temps \\$t\\$\",\n    margin = .5Plots.cm,\n    topmargin = 1Plots.cm,\n)\n\n# équilibre 0\nplot!(\n    sol_logistic.time,\n    zeros(length(sol_logistic.time));\n    color = \"red\",\n    linewidth = 2,\n    linestyle = :dash,\n    linealpha = .5,\n    label = \"équilibre instable\",\n)\n\n# équilibre K\nplot!(\n    sol_logistic.time,\n    ones(length(sol_logistic.time)).*K;\n    color = \"green\",\n    linewidth = 2,\n    linestyle = :dash,\n    linealpha = .5,\n    label = \"équilibre stable\",\n)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nRemarquez l’utilisation de plot! qui modifie en place la première figure en rajoutant des éléments (ici les équilibres et leurs labels)."
  },
  {
    "objectID": "pop_isolees.html#effets-allee",
    "href": "pop_isolees.html#effets-allee",
    "title": "Populations isolées",
    "section": "Effets Allee",
    "text": "Effets Allee"
  },
  {
    "objectID": "pop_isolees.html#sec-allee",
    "href": "pop_isolees.html#sec-allee",
    "title": "Populations isolées",
    "section": "Effets Allee",
    "text": "Effets Allee\nOn s’intéresse à un modèle de dynamique de population avec “effets Allee forts”, souvent attribué à Gruntfest, Arditi, and Dombrovsky (1997)2 :2 mais de nombreuses variations de cette forme polynomiale existent dans la littérature depuis Bazykin (1985)\n\n\\dot x = r x \\left(\\frac{x}{\\epsilon}-1\\right)\\left(1-\\frac{x}{K}\\right),\n\\tag{3} avec r le taux de croissance intrinsèque de la population (par analogie avec la logistique), K la capacité de charge de l’environnement et \\epsilon le seuil en dessous duquel la population n’est pas viable (‘seuil de Allee’).\nNous souhaitons illustrer la bistabilité caractéristique du comportement de ce modèle à partir de la simulation depuis plusieurs conditions initiales.\nCommençons par définir le modèle et les paramètres (en conservant les r et K précédents):\n\n\nCode\nepsilon = 2                 # seuil de Allee\npar_allee = [r, K, epsilon] # packing\ntspan_allee = (0.0, 3.0)\n\nfunction allee(u, p, t)\n    r, K, epsilon = p        # unpacking\n    x = u                 # use x notation\n    return dx = r*x*(x/epsilon - 1)*(1 - x/K)     # derivative\nend\n\n\nNous définissons une fonction qui réalise une simulation en un seul appel depuis une condition initiale x_0 :\n\nfunction int_allee(x0, tspan = tspan_allee, param = par_allee)\n    prob_allee = ODEProblem(\n        allee,            # modèle\n        x0,               # condition initiale\n        tspan,            # tspan\n        param;            # paramètres\n        saveat = tstep,   # option de sortie\n        )\n\n    sol_allee = solve(prob_allee)\n    sol_allee = DataFrame(sol_allee)\n    rename!(sol_allee, :timestamp =&gt; :time, :value =&gt; :x)\n\n    return sol_allee\nend\n\n\n\n\n\n\n\nNote\n\n\n\nLa fonction int_allee comporte un nombre d’arguments variable: int_allee(x0) renverra la solution avec les arguments tspan et param à leurs valeurs par défaut (ce sont des vararg); c’est le même appel que int_allee(x0, tspan_allee, par_allee).\n\n\nNous définissons un vecteur de conditions initiales différentes :\n\nx0step = 1.35\nx0vec = x0step:x0step:K     # range de valeur\n\nFinalement on réalise la figure. La stratégie diffère un peu de ce qui a été vu ci-dessus. Nous commençons par initier un graphique fig, et faisons une boucle for pour tracer chacune des simulations correspondant aux différentes conditions initiales3 :3 la palette de couleur est accessoire, juste pour l’esthétique\n\n# custom color palette\ninit_cgrad = palette([:steelblue, :lightblue], length(x0vec))\n\n# initialisation du graphique\nfig = plot(;          # on initie uniquement le graphique\n    palette = init_cgrad,\n    title = \"\\n Modèle à effets Allee \\$r=$r, K=$K\\$, \\$ϵ=$epsilon\\$\",\n    legend = :right,\n    ylabel = \"densité de population \\$x(t)\\$\",\n    xlabel = \"temps \\$t\\$\",\n    margin = .5Plots.cm,\n    topmargin = 1Plots.cm,\n    )\n\n# boucle de plot avec intégration pour differentes conditions initiales\nfor x0 in x0vec         # x0 parcourt l'array x0vec\n    plot!(\n        fig,              # on modifie fig\n        int_allee(x0).time, # abscisses\n        int_allee(x0).x;    # ordonnées\n        linewidth = 2,      # keyword arguments après ;\n        label = \"\",\n    )\nend\n\n# équilibre 0\nplot!(\n    fig,\n    int_allee(0).time,\n    zeros(length(int_allee(0).time));\n    color = \"green\",\n    linewidth = 2,\n    linestyle = :dash,\n    linealpha = .5,\n    label = \"équilibre stable\",\n)\n\n# équilibre epsilon\nplot!(\n    fig,\n    int_allee(0).time,\n    ones(length(int_allee(0).time)).*epsilon;\n    color = \"red\",\n    linewidth = 2,\n    linestyle = :dash,\n    linealpha = .5,\n    label = \"équilibre instable\",\n)\n\n# équilibre K\nplot!(\n    fig,\n    int_allee(0).time,\n    ones(length(int_allee(0).time)).*K;\n    color = \"green\",\n    linewidth = 2,\n    linestyle = :dash,\n    linealpha = .5,\n    label = \"\",\n)\n\ndisplay(fig)      # actually shows the plot P\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nOn peut sauvegarder la figure dans différents formats (e.g. png, pdf) :\n\nsavefig(fig, \"dyn_allee.pdf\")\nsavefig(fig, \"dyn_allee.png\")\n\nPassons aux populations exploitées."
  },
  {
    "objectID": "pop_exploitees.html#sec-allee-prelev",
    "href": "pop_exploitees.html#sec-allee-prelev",
    "title": "Populations exploitées",
    "section": "",
    "text": "Nous reprenons le modèle précédent sur l’effet Allee mais en prenant en compte des prélèvements externes avec un effort (taux) de prélèvement E : \n\\dot x = r x \\left(\\frac{x}{\\epsilon}-1\\right)\\left(1-\\frac{x}{K}\\right)-Ex.\n\\tag{1}\nLa simulation de ce modèle pour différentes valeurs de E (par exemple E=0.2 ou E=0.85) ne présente aucune difficulté supplémentaire.\nNous allons maintenant nous intéresser à une situation où l’effort de prélèvement E varie au cours du temps entre une valeur soutenable E_s (par exemple 0.2), et une valeur excessive E_x (par exemple 0.85).\nL’attendu théorique est que si les prélèvements sont maintenus à une valeur excessive E_x trop longtemps, la population disparait irrémédiablement même si les prélèvements sont par la suite ramenés à une valeur initialement soutenable E_s.\n\n\n\nusing DifferentialEquations\nusing Plots\nusing DataFrames\n\nDéfinissons une fonction effort() dépendant du temps, qui renvoit :\n\nE_s~ si ~t&lt;T_s\nE_x~ si ~t\\in [T_s+T_x[\nà nouveau E_s~ si ~t\\geq T_s+T_x\n\n\n# paramètres\nE_s = 0.2\nE_x = 0.85\nT_s = 10.0\nT_x = 9.0\n\np_effort = [E_s, E_x, T_s, T_x]\n\nfunction effort(t, p)\n    E_s, E_x, T_s, T_x = p\n\n    if t &lt; T_s || t &gt;= T_s + T_x\n        return E_s\n    elseif t &gt;= T_s && t &lt; T_s + T_x\n        return E_x\n    end\nend\n\n\n\n\n\n\n\nNote\n\n\n\nRemarquez les opérateurs booléens “ou” || et “et” &&, ainsi que la structure du test if.\n\n\nLa fonction correspond bien à nos hypothèses :\n\n\nCode\nt2plot = 0: .1: 30\n\nplot(\n    t2plot,                                 # abscisses\n    [effort(t, p_effort) for t in t2plot];  # ordonnées\n    palette = :tab10,\n    linewidth = 2,\n    label = \"\\$E(t)\\$\",\n    xlabel = \"temps\",\n    ylabel = \"\\$E(t)\\$\",\n    title = \"Effort de pêche \\$E(t)\\$\",\n    margin = .5Plots.cm,\n    topmargin = 1Plots.cm,\n)\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nRemarquez la construction des ordonnées correspondant à la fonction effort via une compréhension de liste : [effort(t, p_effort) for t in t2plot].\n\n\n\n\n\nNous définissons les paramètres du modèle, la condition initiale et le temps d’intégration :\n\n\nCode\nx0 = 10.0\n\ntspan = (0.0, 30.0)\ntstep = 0.1\n\nr = 1.0\nK = 10.0\nepsilon = 2.0\np_allee = [r, K, epsilon]\n\n\nNous définissons le système dynamique comme précédemment, à la différence que nous prévoyons de surcharger l’argument p dans le problème d’intégration sous forme d’un vecteur comprennant :\n\nle vecteur de paramètres p_allee en première position\nle vecteur de paramètres p_effort en seconde position\net la fonction effort en troisième position1\n\n1 En Julia tout est passable en argument, des variables aux fonctions et plus.\np_evar = [p_allee, p_effort, effort]\n\n\nfunction allee_evar(u, p, t)\n    r, K, epsilon = p[1]        # unpacking model parameters\n    p_effort = p[2]             # unpacking fishing effort parameters\n    E = p[3]                    # unpacking fishing effort function\n    x = u                    # use x notation\n\n    return dx = r*x*(x/epsilon - 1)*(1 - x/K) - E(t, p_effort)*x\nend\n\nL’intégration en elle-même suit le shéma vu précédemment, si ce n’est que l’argument de paramètres doit bien refléter ce qui est attendu par la fonction allee_evar(). La simulation en elle-même est effectuée avec une modification de la précision relative de l’intégration reltol = 1e-6, la précision par défaut n’étant pas suffisante ici.\n\nprob_allee_evar = ODEProblem(\n      allee_evar,\n      x0,\n      tspan,\n      p_evar;\n      saveat = tstep,\n)\n\nsol_allee_evar = solve(prob_allee_evar; reltol = 1e-6)\n\nsol_allee_evar = DataFrame(sol_allee_evar)\nrename!(sol_allee_evar, :timestamp =&gt; :time, :value =&gt; :x)\n\n\n\n\n\n\n\nNote\n\n\n\nIci nous avons imposé une tolérance plus précise au solver via le keyword argument reltol = 1e-6.\n\n\nFinalement, nous pouvons représenter graphiquement la solution contre le temps. Ici, malgré la perturbation violente induite par la période de surexploitation, le pêcherie retrouve une situation soutenable après un retour à E=E_s.\n\n\nCode\nplot(\n    sol_allee_evar.time,\n    sol_allee_evar.x;\n    label = \"\\$x(t)\\$\",\n    linewidth = 2,\n    xlabel = \"temps\",\n    ylabel = \"densité de population \\$x(t)\\$\",\n    title = \"Effort de pêche variant dans le temps\",\n    palette = :tab10,\n    legend = :left,\n    margin = .5Plots.cm,\n    topmargin = 1Plots.cm,\n)\n\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 1: Persistence dans le modèle avec effet Allee et prélèvements\n\n\n\nLorsque la période de surexploitation de la population est trop longue (e.g. ici T_x=9.2), la population ne parvient pas à récupérer malgré le retour à un effort de prélèvement soutenable.\n\n\nCode\n# change parameter\nT_x2 = 9.2\n\np_effort2 = [E_s, E_x, T_s, T_x2]\np_evar2 = [p_allee, p_effort2, effort]\n\n# define new problem and integrate\nprob_allee_evar2 = ODEProblem(\n      allee_evar,\n      x0,\n      tspan,\n      p_evar2,\n      saveat = tstep\n)\n\nsol_allee_evar2 = solve(prob_allee_evar2, reltol = 1e-6)\n\nsol_allee_evar2 = DataFrame(sol_allee_evar2)\nrename!(sol_allee_evar2, :timestamp =&gt; :time, :value =&gt; :x)\n\n# plot\nplot(\n    sol_allee_evar2.time, sol_allee_evar2.x,\n    label = \"\\$x(t)\\$\";\n    linewidth = 2,\n    xlabel = \"temps\",\n    ylabel = \"densité de population \\$x(t)\\$\",\n    title = \"Effort de pêche variant dans le temps\",\n    palette = :tab10,\n    legend = :left,\n    margin = .5Plots.cm,\n    topmargin = 1Plots.cm,\n)\n\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 2: Extinction dans le modèle avec effet Allee et prélèvements\n\n\n\n\n\n\nIl s’agit ici de représenter dans l’espace (E, x) l’évolution conjointe de l’effort de pêche et de la densité de la population au cours du temps, afin de mieux comprendre le phénomène d’extinction. Dans cet objectif, on tracera aussi le lieu des équilibres de la population x^*(E) en fonction d’une valeur de E constante, i.e. : \nx^*(E) = 0,\n ce qui est équivalent à : \nE = r\\left(\\frac{x^*(E)}{\\epsilon}-1\\right)\\left(1-\\frac{x^*(E)}{K}\\right).\n\nNous allons tracer les deux situations vues à la section précédente dans deux sous figures. Commençons par les lieux des équilibres, qui sont les mêmes dans les deux situations.\nDéfinissons le lieu des équilibres positifs :\n\n# parabole pour les equilibres positifs\nfunction eeqpos(x, par = p_allee)\n    r, K, epsilon = par\n    return r*(x/epsilon -1)*(1-x/K)\nend\n\nPuis traçons ce lieu dans le plan (E,x) (il y a deux branches une stable et une instable pour les équilibres positifs qui se rejoignent en x^* = (K+\\epsilon)/2, nous les traçons séparément)\n\n# vecteurs pour le tracé\ne2plot = 0:.1:1\nx2plot1 = epsilon:.02:(K+epsilon)/2\nx2plot2 = (K+epsilon)/2:.02:K\n\n# on définit des couleurs spécifiques depuis la palette :pal10\nmygreen = palette(:tab10)[3]\nmyorange = palette(:tab10)[2]\nmyblue = palette(:tab10)[1]\nmyred = palette(:tab10)[4]\n\n# plot\nfig1 = plot(\n    e2plot,\n    zeros(length(e2plot));\n    color = mygreen,\n    linewidth = 2,\n    label = \"équilibres stables\",\n    ylabel = \"densité de population \\$x\\$\",\n    xlabel = \"effort de pêche \\$E\\$\",\n    legend = :left,\n)\n\nplot!(\n    fig1,\n    eeqpos.(x2plot1),\n    x2plot1;\n    color= myorange,\n    linewidth = 2,\n    label = \"équilibre instable\",\n)\n\nplot!(\n    fig1,\n    eeqpos.(x2plot2),\n    x2plot2;\n    color= mygreen,\n    linewidth = 2,\n    label =\"\",\n)\n\ndisplay(fig1)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nRemarquez le broadcast (calcul terme à terme) sur les ordonnées des équilibres positifs en utilisant eeqpos.. On aurait pu procéder par compréhension de liste: [eeqpos(x) for x in x2plot2].\n\n\nOn prépare un graphique fig2 avec les mêmes éléments que dans fig1 :\n\nfig2 = deepcopy(fig1) # on fait une copie complète de fig1\n\nFinalement, on complète fig1 et fig2 avec quelques annotations et les trajectoires calculées plus haut en fonction de l’effort de pêche variable au cours du temps, et on trace les résultats en deux sous-figures :\n\n# annotations\nannotate!(fig1, .35, 8.5, Plots.text(\"branche stable\", 10, rotation=-28))\nannotate!(fig1, .4, 2.7, Plots.text(\"branche instable\", 10, rotation=28))\nannotate!(fig2, .4, 2.7, Plots.text(\"branche instable\", 10, rotation=28))\nannotate!(fig2, .35, 8.5, Plots.text(\"branche stable\", 10, rotation=-28))\n\n# peche durable sur fig1\nplot!(\n    fig1,\n    [effort(t, p_effort) for t in sol_allee_evar.time],\n    sol_allee_evar.x;\n    color = myblue,\n    linewidth = 2,\n    label = \"trajectoire\",\n)\n\n# surpeche sur fig2\nplot!(\n    fig2,\n    [effort(t, p_effort2) for t in sol_allee_evar2.time], sol_allee_evar2.x;\n    color = myblue,\n    linewidth = 2,\n    label = \"trajectoire\",\n)\n\n# figure reprenant les deux sous figures fig1 et fig2\nplot(\n    fig1,\n    fig2;\n    suptitle = \"Effets Allee et prélèvements\",\n    margin = .5Plots.cm,\n    topmargin = 1Plots.cm,\n)\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\nFigure 3: bifurcation pli et catastrophe dans le modèle avec effet Allee et prélèvements"
  },
  {
    "objectID": "pop_exploitees.html#prélèvements-variables-dans-le-temps",
    "href": "pop_exploitees.html#prélèvements-variables-dans-le-temps",
    "title": "Populations exploitées",
    "section": "",
    "text": "using DifferentialEquations, Plots, DataFrames\n\nDéfinissons une fonction effort() dépendant du temps, qui renvoit :\n\nE_s~ si ~t&lt;T_s\nE_x~ si ~t\\in [T_s+T_x[\nà nouveau E_s~ si ~t\\geq T_s+T_x\n\n\n# paramètres\nE_s = 0.2\nE_x = 0.85\nT_s = 10.0\nT_x = 9.0\n\npar_effort = [E_s, E_x, T_s, T_x]\n\nfunction effort(t, pars)\n    E_s, E_x, T_s, T_x = pars\n\n    if t &lt; T_s || t &gt;= T_s + T_x\n        return E_s\n    elseif t &gt;= T_s && t &lt; T_s + T_x\n        return E_x\n    end\nend\n\nLa fonction correspond bien à nos hypothèses :\n\n\nCode\ntime2plot = 0: .1: 30\n\nplot(time2plot, [effort(t, par_effort) for t in time2plot],\n     palette = :tab10,\n     linewidth = 2,\n     label = \"\\$E(t)\\$\",\n     xlabel = \"temps\",\n     ylabel = \"\\$E(t)\\$\",\n     title = \"Effort de pêche \\$E(t)\\$\",\n     margin = .5Plots.cm,\n     topmargin = 1Plots.cm)"
  },
  {
    "objectID": "pop_exploitees.html#simulations-en-fonction-du-temps",
    "href": "pop_exploitees.html#simulations-en-fonction-du-temps",
    "title": "Populations exploitées",
    "section": "",
    "text": "Nous définissons les paramètres du modèle, la condition initiale et le temps d’intégration :\n\n\nCode\nx0 = 10.\n\ntspan = (0.0, 30.0)\ntstep = 0.1\n\nr = 1.\nK = 10.\nepsilon = 2.                 # seuil de Allee\npar_allee = [r, K, epsilon] # packing\ntspan_allee = (0.0, 3.0)\n\n\nNous définissons le système dynamique comme précédemment, à la différence que nous prévoyons de surcharger l’argument p dans le problème d’intégration sous forme d’un vecteur comprennant :\n\nle vecteur de paramètres par_allee en première position\nle vecteur de paramètres par_effort en seconde position\net la fonction effort en troisième position\n\n\nfunction allee_evar(u, p, t)\n    r, K, epsilon = p[1]        # unpacking model parameters\n    par_effort = p[2]           # unpacking fishing effort parameters\n    E = p[3]                    # unpacking fishing effort function\n    x = u[1]                    # use x notation\n    \n    dx = r*x*(x/epsilon - 1)*(1 - x/K) - E(t, par_effort)*x\nend\n\nL’intégration en elle-même suit le shéma vu précédemment, si ce n’est que l’argument de paramètres doit bien refléter ce qui est attendu par la fonction allee_evar(). La simulation en elle-même est effectuée avec une modification de la précision relative de l’intégration reltol = 1e-6, la précision par défaut n’étant pas suffisante ici.\n\nprob_allee_evar = ODEProblem(allee_evar, \n                             x0, \n                             tspan, \n                             [par_allee, par_effort, effort], \n                             saveat = tstep)\n\nsol_allee_evar = solve(prob_allee_evar, reltol = 1e-6)\n\nsol_allee_evar = DataFrame(sol_allee_evar)\nrename!(sol_allee_evar, :timestamp =&gt; :time, :value =&gt; :x)\n\nFinalement, nous pouvons représenter graphiquement la solution contre le temps. Ici, malgré la perturbation violente induite par la période de surexploitation, le pêcherie retrouve une situation soutenable après un retour à E=E_s.\n\n\nCode\nplot(sol_allee_evar.time, sol_allee_evar.x,\n     label = \"\\$x(t)\\$\",\n     linewidth = 2,\n     xlabel = \"temps\",\n     ylabel = \"densité de population \\$x(t)\\$\",\n     title = \"Effort de pêche variant dans le temps\",\n     palette = :tab10,\n     legend = :left,\n     margin = .5Plots.cm,\n     topmargin = 1Plots.cm)\n\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 1: Persistence dans le modèle avec effet Allee et prélèvements\n\n\n\n\n\nLorsque la période de surexploitation de la population est trop longue (e.g. ici T_x=9.2), la population ne parvient pas à récupérer malgré le retour à un effort de prélèvements soutenable.\n\n\nCode\n# change parameter\nT_x2 = 9.2\n\npar_effort2 = [E_s, E_x, T_s, T_x2]\n\n# define new problem and integrate\nprob_allee_evar2 = ODEProblem(allee_evar, \n                             x0, \n                             tspan, \n                             [par_allee, par_effort2, effort], \n                             saveat = tstep)\n\nsol_allee_evar2 = solve(prob_allee_evar2, reltol = 1e-7)\n\nsol_allee_evar2 = DataFrame(sol_allee_evar2)\nrename!(sol_allee_evar2, :timestamp =&gt; :time, :value =&gt; :x)\n\n# plot\nplot(sol_allee_evar2.time, sol_allee_evar2.x,\n     label = \"\\$x(t)\\$\",\n     linewidth = 2,\n     xlabel = \"temps\",\n     ylabel = \"densité de population \\$x(t)\\$\",\n     title = \"Effort de pêche variant dans le temps\",\n     palette = :tab10,\n     legend = :left,\n     margin = .5Plots.cm,\n     topmargin = 1Plots.cm)\n\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 2: Extinction dans le modèle avec effet Allee et prélèvements"
  },
  {
    "objectID": "pop_exploitees.html#simulations-dans-lespace-e-x",
    "href": "pop_exploitees.html#simulations-dans-lespace-e-x",
    "title": "Populations exploitées",
    "section": "",
    "text": "Il s’agit ici de représenter dans l’espace (E, x) l’évolution conjointe de l’effort de pêche et de la densité de la population au cours du temps, afin de mieux comprendre le phénomène d’extinction. Dans cet objectif, on tracera aussi le lieu des équilibres de la population x^*(E) en fonction d’une valeur de E constante, i.e. : \nx^*(E) = 0,\n ou : \nE = r\\left(\\frac{x^*(E)}{\\epsilon}-1\\right)\\left(1-\\frac{x^*(E)}{K}\\right).\n\nNous allons tracer les situations dans 2 sous figures. Commençons par les lieux des équilibres :\n\n# vecteurs pour le tracé\ne2plot = 0:.1:1\nx2plot1 = epsilon:.02:(K+epsilon)/2\nx2plot2 = (K+epsilon)/2:.02:K\n\n# parabole pour les equilibres positifs\nfunction eeqpos(x, par = par_allee)\n        r, K, epsilon = par\n\n        r*(x/epsilon -1)*(1-x/K)\nend\n\n# on définit des couleurs spécifiques depuis la palette :pal10\nmygreen = palette(:tab10)[3]\nmyorange = palette(:tab10)[2]\nmyblue = palette(:tab10)[1]\n\n# plot\nP1 = plot(e2plot, zeros(length(e2plot)),\n          color = mygreen,\n          linewidth = 2,\n          label = \"équilibres stables\",\n          ylabel = \"densité de population \\$x\\$\",\n          xlabel = \"effort de pêche \\$E\\$\",\n          legend = :left)\n        #   margin = .5Plots.cm,\n        #   topmargin = 1Plots.cm)\n\nplot!(P1, eeqpos.(x2plot1), x2plot1, \n          color= myorange,\n          linewidth = 2,\n          label = \"équilibre instable\")\n\nplot!(P1, eeqpos.(x2plot2), x2plot2, \n          color= mygreen,\n          linewidth = 2,\n          label =\"\")\n\ndisplay(P1)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nOn prépare un graphique P2 avec les mêmes éléments :\n\nP2 = deepcopy(P1) # évite de tout retaper...\n\nOn complète P1 et P2 avec quelques annotations et les trajectoires calculées plus haut en fonction de l’effort de pêche variable au cours du temps, et on trace les résultats en deux sous-figures :\n\nannotate!(P1, .35, 8.5, Plots.text(\"branche stable\", 10, rotation=-28))\nannotate!(P1, .4, 2.7, Plots.text(\"branche instable\", 10, rotation=28))\nannotate!(P2, .4, 2.7, Plots.text(\"branche instable\", 10, rotation=28))\nannotate!(P2, .35, 8.5, Plots.text(\"branche stable\", 10, rotation=-28))\n\nplot!(P1, [effort(t, par_effort) for t in sol_allee_evar.time], sol_allee_evar.x,\n      color = myblue, \n      linewidth = 2,\n      label = \"trajectory\")\n\nplot!(P2, [effort(t, par_effort2) for t in sol_allee_evar2.time], sol_allee_evar2.x,\n      color = myblue, \n      linewidth = 2,\n      label = \"trajectory\")\n\nplot(P1, P2, suptitle = \"Effets Allee et prélèvements\",\n     margin = .5Plots.cm,\n     topmargin = 1Plots.cm)\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\nFigure 3: bifurcation pli et catastrophe dans le modèle avec effet Allee et prélèvements"
  },
  {
    "objectID": "pop_exploitees.html#la-tordeuse-du-bourgeon-de-lépinette",
    "href": "pop_exploitees.html#la-tordeuse-du-bourgeon-de-lépinette",
    "title": "Populations exploitées",
    "section": "La tordeuse du bourgeon de l’épinette",
    "text": "La tordeuse du bourgeon de l’épinette\n\nModèle\nNous considérons le modèle de dynamique de populations suivant, inspiré de Ludwig, Jones, and Holling (1978) :\n\n\\dot x =rx\\left(1-\\frac{x}{K}\\right) - \\frac{\\alpha x^2}{h^2+x^2}\\ y,\n\\tag{2}\navec x la densité de tordeuses et y la densité d’oiseaux. La croissance des tordeuses suit une loi logistique et la prédation des oiseaux une réponse fonctionnelle de type Holling III.\n\n\nSimulations\nOn procède classiquement, en ajustant les valeurs de paramètres pour mettre en évidence les phénomènes dynamiques attendus :\n\n# paramètres\nr = 5.0      # natalité\nK = 10.0     # mortalité\nα = 1.0      # taux max de prédation, \\alpha + TAB\nh = 0.5      # constante de demi-saturation\nyc = 7.0     # densité de prédateurs\n\npar_tordeuse = [r, K, α, h, yc]\n\n# temps d'intégration\ntspan = (0.0, 3.0)\ntstep = 0.02\n\nPuis on définit le modèle :\n\nfunction tordeuse(u, p, t)\n    r, K, α, h, yc = p\n    x = u\n    return dx = r*x*(1 - x/K) - α*x^2/(h^2 + x^2)*yc\nend\n\nComme pour le modèle avec effets Allee, on définit une fonction qui redéfinit le problème d’intégration à chaque fois, et simule et renvoit la solution pour pouvoir illustrer la bi-stabilité2 :2 des méthodes alternative utilisant l’interface integrator de DifferentialEquations.jl ou la redéfinition du problème d’intégration via remake sont proposées en annexe\n\nfunction int_tordeuse(x0, tspan = tspan, param = par_tordeuse)\n    prob_tordeuse = ODEProblem(\n      tordeuse,       # modèle\n      x0,               # condition initiale\n      tspan,            # tspan\n      param;            # paramètres\n      saveat = tstep,\n    )\n\n    sol_tordeuse = solve(prob_tordeuse)\n    sol_tordeuse = DataFrame(sol_tordeuse)\n    rename!(sol_tordeuse, :timestamp =&gt; :time, :value =&gt; :x)\nend\n\nNous simulons le modèle depuis différentes conditions intiales, et traçons les résultats via une boucle for.\n\n# conditions initiales\nx0step = 1.35\nx0vec = x0step:x0step:K\n\n# custom color palette\ninit_cgrad = palette([:steelblue, :lightblue], length(x0vec))\n\n# initialisation du graphique, équilibre nul\nfig3 = plot(;         # seulement des kwargs: on initialise le graphique\n    palette = init_cgrad,\n    legend = :right,\n    label =\"équilibres instables\",\n    title = \"Tordeuse du bourgeon de l\\'épinette\",\n    ylabel = \"densité de population \\$x(t)\\$\",\n    xlabel = \"temps \\$t\\$\",\n    margin = .5Plots.cm,\n    topmargin = 1Plots.cm,\n)\n\n# boucle de plot avec intégration pour differentes conditions initiales\nfor x0 in x0vec\n    plot!(\n        fig3,\n        int_tordeuse(x0).time,\n        int_tordeuse(x0).x,\n        linewidth = 2,\n        label = \"\",\n    )\nend\n\ndisplay(fig3)      # actually shows the plot fig3\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nEquilibres\nLes valeurs des équilibres positifs du modèle Equation 2 n’ont pas d’écriture mathématique simple. Nous allons calculer numériquement les racines du polynôme dont ils sont solution : \nr\\left(1-\\frac{x^*}{K}\\right)\\left(h^2+x^{*2}\\right)-\\alpha x^* y = 0\n\\tag{3}\nPour cela, on utilise le package Polynomials.jl :\n\nusing Polynomials\n\n# définition du monôme X\nX = Polynomial([0, 1])\n\n# définition du polynôme\npol = r*(1-X/K)*(h^2 + X^2)-α*X*yc\n\n# calcul des racines, réelles, positives et plus petites que K\neq_pos = roots(pol)                         # calcul des racines\neq_pos = real.(eq_pos[isreal.(eq_pos)])     # filtrage des racines réelles\neq_pos = eq_pos[(eq_pos .&gt; 0) .& (eq_pos .&lt;= K)] # filtrage des racines &gt;0 et &lt;K\n\n3-element Vector{Float64}:\n 0.20406511760131657\n 1.4717313636879934\n 8.324203518710693\n\n\n\n\n\n\n\n\nNote\n\n\n\nA partir de la définition du monôme de degré 1, on écrit assez naturellement un polynôme et on en extrait les racines via roots.\nLa partie filtrage des racines réelles prend la partie réelle des racines qui sont rendues sous forme d’un type complexe (même si la partie imaginaire est nulle).\nRemarquez les broadcasting divers, notamment .&gt; et .& qui testent les conditions terme à terme sur le vecteur eq_pos.\n\n\nEt on trace les différents équilibres :\n\nt2plot = collect(tspan)\n\n# initialisation du graphique, équilibre nul\nplot!(\n    fig3,\n    t2plot,\n    zeros(length(t2plot));\n    linewidth = 2,\n    linestyle = :dash,\n    color = myorange,\n    palette = init_cgrad,\n    legend = :right,\n    label =\"équilibres instables\",\n    ylabel = \"densité de population \\$x(t)\\$\",\n    xlabel = \"temps \\$t\\$\",\n    margin = .5Plots.cm,\n    topmargin = 1Plots.cm,\n)\n\n# équilibres positifs, différents cas\nif length(eq_pos) == 1\n    plot!(\n      fig3,\n      t2plot, ones(length(t2plot)).*eq_pos;\n      color = mygreen,\n      label =\"équilibre stable\",\n    )\nelseif length(eq_pos) == 3\n    plot!(\n      fig3,\n      t2plot,\n      ones(length(t2plot)).*eq_pos[1];\n      lw=2,\n      linestyle = :dash,\n      color = mygreen,\n      label =\"équilibres stables\",\n    )\n    plot!(\n      fig3,\n      t2plot,\n      ones(length(t2plot)).*eq_pos[2];\n      lw=2,\n      linestyle = :dash,\n      color = myorange,\n      label = \"\",\n    )\n    plot!(\n      fig3,\n      t2plot,\n      ones(length(t2plot)).*eq_pos[3];\n      lw=2,\n      linestyle = :dash,\n      color = mygreen,\n      label = \"\",\n    )\nelse\n    println(\"Cette situation est non générique (2 équilibres positifs à la bifurcation)\")\nend\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 4: bistabilité dans le modèle de la tordeuse du bourgeon de l’épinette\n\n\n\n\n\nDiagramme de bifurcations\n\n\n\n\n\n\nWarning\n\n\n\nLe début de cette partie est assez technique et a pour objectif principal de montrer ce qu’il est possible de faire en manipulant des expressions symboliques.\n\n\nFinalement nous traçons dans le plan (y, x) le lieu des points d’équilibres en fonction de la taille de la population d’oiseaux:\n\ny = \\frac{r}{\\alpha x^*}\\left(1-\\frac{x^*}{K}\\right)(h^2+x^{*2})\n\\tag{4}\nComme nous l’avons vu en cours cette fonction est non monotone avec une branche décroissante, une branche croissante puis à nouveau une branche décroissante, le sens de variation de la branche déterminant la stabilité de l’équilibre correspondant.\nPour déterminer ces différentes branches et les représenter de différentes couleurs de façon à illustrer leur stabilité, nous allons dériver l’Equation 4 par rapport à x^* en utilisant le package Symbolics.jl et chercher les racines de la dérivée3.3 si l’Equation 4 avait été un polynôme nous aurions utilisé les outils pour les polynômes, mais il s’agit d’une fraction rationnelle\n\nusing Symbolics\n\n@variables X\nD = Differential(X)\n\n# on définit le lieu des équilibres selon l'équation ci-dessus\nY = r/(α*X)*(1-X/K)*(h^2+X^2)\n\n \\begin{equation}\n\\frac{5 \\left( 1 - 0.1 X \\right) \\left( 0.25 + X^{2} \\right)}{X}\n\\end{equation}\n\n\n\nLes racines de la dérivée, sont les racines du numérateur de la dérivée, donc on dérive:\n\n# Dérivée de Y, distribuée et simplifiée\nderY = simplify(expand_derivatives(D(Y)))\n\n \\begin{equation}\n\\frac{-1.25 + 5 X^{2} - X^{3}}{X^{2}}\n\\end{equation}\n\n\n\n\n\net on récupère ce numérateur:\n\ndnumerator = Symbolics.arguments(Symbolics.value(derY))[1]\n\n \\begin{equation}\n-1.25 + 5.0 X^{2} - X^{3}\n\\end{equation}\n\n\n\n\n\nComme ce numérateur est un polynôme, on peut utiliser le polynôme symbolique de Symbolics.jl pour regénérer un polynôme et utiliser la méthode roots() de Polynomials.jl44 il faut l’admettre, ce serait plus simple d’avoir directement une façon de trouver les racines d’un polynôme symbolique, mais ça ne semble pas implémenté pour l’instant (fin 2023)\n\n# on récupère les coefficients X^k du polynôme\ncoefs_dict = Symbolics.value(dnumerator).dict\n\n# on crée un dictionnaire rassemblant les coefficients du polynôme\npoldict = Dict(Symbolics.degree(first(kv)) =&gt; kv[2] for kv in coefs_dict)\n\n# on rajoute dans le dictionnaire le coefficient constant de dnumerator\npoldict[0] = substitute(dnumerator, Dict( X=&gt; 0))\n\n# on définit le polynôme à partir du dictionnaire\ndnumpoly = SparsePolynomial(poldict, :X)\n\nFinalement, on calcule les solutions (racines de la dérivée de y) en prenant soin de filtrer celles entre 0 et K.\n\n# on calcule les solutions en filtrant les racines entre 0 et K via une fonction anonyme s-&gt; K &gt; s &gt; 0\ndyroots = filter(s -&gt; K &gt; s &gt; 0, roots(dnumpoly))\n\n\n\n\n\n\n\nNote\n\n\n\nIci nous utilisons une fonction anonyme s -&gt; K &gt; s &gt; 0 qui renvoit true ou false selon que la condition est vérifiée par l’argument, et qui appliquée à roots(dnumpoly), “filtre” les valeurs vérifiant la condition.\nOn aurait pu faire un filtrage comme vu plus haut.\n\n\nOn calcule les branches du lieu des équilibres correspondantes, et on peut les tracer dans le plan (y,x) pour illustrer le diagramme de bifurcations.\n\n# on calcule chacune des branches\nxplot1 = 0.08:.01:dyroots[1]\nxplot2 = dyroots[1]:.01:dyroots[2]\nxplot3 = dyroots[2]:.01:K\nyeq1 = [r*(1 - x/K)/(α*x)*(h^2 + x^2) for x in xplot1]\nyeq2 = [r*(1 - x/K)/(α*x)*(h^2 + x^2) for x in xplot2]\nyeq3 = [r*(1 - x/K)/(α*x)*(h^2 + x^2) for x in xplot3]\n\n# diagramme de bifurcations\n# branche stable 1 et initialisation\nfigbif = plot(\n      yeq1,\n      xplot1;\n      linewidth = 2,\n      color = mygreen,\n      label = \"équilibres stables\",\n      legend = :left,\n      xlabel = \"population d'oiseaux \\$y\\$\",\n      ylabel = \"population de tordeuses \\$x\\$\",\n      title = \"Diagramme de bifurcations pour le modèle de tordeuses\",\n      margin = .5Plots.cm,\n      topmargin = 1Plots.cm,\n)\n\n# branche instable\nplot!(\n    figbif,\n    yeq2,\n    xplot2;\n    linewidth = 2,\n    color = myred,\n    label = \"équilibres instables\",\n)\n\n# branche stable 2\nplot!(\n    figbif,\n    yeq3,\n    xplot3;\n    linewidth = 2,\n    color = mygreen,\n    label = \"\",\n)\n\n# équilibre nul\nplot!(\n    figbif,\n    [0, maximum(yeq1)],\n    [0, 0];\n    color = myred,\n    lw = 2,\n    label = \"\",\n)\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 5: bifurcations dans le modèle de la tordeuse du bourgeon de l’épinette\n\n\n\nNous verrons sur la page des populations en interactions le cas où la population d’oiseaux varie lentement au cours du temps."
  },
  {
    "objectID": "pop_interactions.html#la-tordeuse-du-bourgeon-de-lépinette-suite",
    "href": "pop_interactions.html#la-tordeuse-du-bourgeon-de-lépinette-suite",
    "title": "Populations en interaction (1)",
    "section": "",
    "text": "Pour débuter cette partie sur les populations en interactions, nous reprenons le modèle de tordeuse de Ludwig, Jones, and Holling (1978) en supposant que la population d’oiseaux réagit (lentement) à la démographie des tordeuses, via la prédation.\nLe changement principal ici est la dimension du modèle (dimension 2) : les tailles de populations de tordeuses x et d’oiseaux y varient toutes deux au cours du temps en s’influençant l’une l’autre, avec une population d’oiseaux qui varie lentement (d’où le paramètre \\varepsilon supposé petit) par rapport à celle des tordeuses.\nLe modèle prend la forme : \n\\left\\{\n\\begin{array}{l}\n\\displaystyle \\dot x = rx\\left(1-\\frac{x}{K}\\right) - \\frac{\\alpha x^2}{h^2+x^2}\\ y \\\\[.3cm]\n\\displaystyle \\dot y = \\varepsilon \\left(\\frac{n \\alpha x^2}{h^2+x^2}\\ y -m y\\right)\n\\end{array}\n\\right.\n\\tag{1}\nIl faut ajuster un peu la manière de coder pour prendre en compte ces deux dimensions. Commençons par les paramètres divers.\n\nusing DifferentialEquations\nusing Plots\nusing DataFrames\n\n# paramètres\nr = 5.0      # natalité\nK = 10.0     # mortalité\nα = 1.0      # taux max de prédation\nh = 0.5      # constante de demi-saturation\n\nϵ = 0.01     # timescale, \\epsilon + TAB\nn = 5.0      # gain à la prédation\nm = 3.0      # mortalité\n\npar_tord_ois = [r, K, α, h, ϵ, n, m]\n\n# temps d'intégration\ntspan = (0.0, 400.0)\ntstep = 0.02\n\n# conditions initiales\nx0 = 1.0    # tordeuses\ny0 = 2.5    # oiseaux\netat0 = [x0, y0]\n\nPuis le modèle :\n\nfunction tord_ois(u, p, t)\n    r, K, α, h, ϵ, n, m = p\n    x = u[1]\n    y = u[2]\n\n    dx = r*x*(1 - x/K) - α*x^2/(h^2 + x^2)*y\n    dy = ϵ*(n*α*x^2/(h^2 + x^2)*y - m*y)\n\n    return [dx, dy]\nend\n\nProblème d’intégration et simulation :\n\nprob_tord_ois = ODEProblem(\n      tord_ois,\n      etat0,\n      tspan,\n      par_tord_ois;\n      saveat = tstep,\n)\n\nsol_tord_ois = solve(prob_tord_ois, reltol = 1e-6)\n\nsol_tord_ois = DataFrame(sol_tord_ois)\nrename!(sol_tord_ois, :timestamp =&gt; :time, :value1 =&gt; :x, :value2 =&gt; :y)\n\nReprésentation graphique contre le temps\n\n# color definitions\nmygreen = palette(:tab10)[3]\nmyorange = palette(:tab10)[2]\nmyblue = palette(:tab10)[1]\nmyred = palette(:tab10)[4]\n\n# initialisation graphique et solution simulée\nfig1 = plot(\n    sol_tord_ois.time,\n    sol_tord_ois.x;\n    color = myblue,\n    linewidth = 2,\n    label = \"tordeuses \\$x\\$\",\n    xlabel = \"temps\",\n    ylabel = \"densités de populations\",\n    title = \"Dynamiques des tordeuses avec\\n population d'oiseaux variable\",\n)\n\nplot!(\n    fig1,\n    sol_tord_ois.time,\n    sol_tord_ois.y ./ 2,  # scale by 2 for aesthetics\n    color = myorange,\n    linewidth = 2,\n    label = \"oiseaux \\$y/2\\$\",\n)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nOn observe ici des bifurcations dynamiques avec le passage de la population de tordeuse d’une branche d’équilibre stable à l’autre, qui créé un comportement de type cycle d’hysteresis.\nLa situation se comprend bien sur le diagramme de bifurcations (y, x). On retrace le diagramme de bifurcations (cf. la page sur les populations exploitées).\n\n\nCode\nusing Symbolics\nusing Polynomials\n\n@variables X\nD = Differential(X)\n\n# lieu des équilibres positifs\nY = r/(α*X)*(1-X/K)*(h^2+X^2)\n\n# dénominateur de la dérivée\ndnumerator = Symbolics.arguments(Symbolics.value(simplify(expand_derivatives(D(Y)))))[1]\n\n# on récupère les coefficients X^k du polynôme\ncoefs_dict = Symbolics.value(dnumerator).dict\ndd = Dict(Symbolics.degree(first(kv)) =&gt; kv[2] for kv ∈ coefs_dict)\n# on rajoute dans le dictionnaire le coefficient constant\ndd[0] = substitute(dnumerator, Dict(X=&gt;0))\n\n# on définit le polynôme à partir du dictionnaire\ndnumpoly = SparsePolynomial(dd, :X)\n\n# on calcule les racines en filtrant les racines entre 0 et K via une fonction anonyme s-&gt; K &gt; s &gt; 0\ndroots = filter(s -&gt; K &gt; s &gt; 0, roots(dnumpoly))\n\n# vecteur pour le tracé du diagramme de bifurcation\nxplot1 = 0.08:.01:droots[1]\nxplot2 = droots[1]:.01:droots[2]\nxplot3 = droots[2]:.01:K\nyeq1 = [r*(1 - x/K)/(α*x)*(h^2 + x^2) for x in xplot1]\nyeq2 = [r*(1 - x/K)/(α*x)*(h^2 + x^2) for x in xplot2]\nyeq3 = [r*(1 - x/K)/(α*x)*(h^2 + x^2) for x in xplot3]\n\n# diagramme de bifurcations\nfigbif = plot(\n    yeq1,\n    xplot1;\n    linewidth = 2,\n    color = mygreen,\n    label = \"équilibres stables\",\n    legend = :left,\n    xlabel = \"population d'oiseaux \\$y\\$\",\n    ylabel = \"population de tordeuses \\$x\\$\",\n    title = \"Diagramme de bifurcations pour le modèle de tordeuses\",\n    margin = .5Plots.cm,\n    topmargin = 1Plots.cm,\n)\n\nplot!(\n    figbif,\n    yeq2,\n    xplot2;\n    linewidth = 2,\n    color = myred,\n    label = \"équilibres instables\",\n)\n\nplot!(\n    figbif,\n    yeq3,\n    xplot3;\n    linewidth = 2,\n    color = mygreen,\n    label = \"\",\n)\n\nplot!(\n    figbif,\n    [0, maximum(yeq1)],\n    [0, 0];\n    color = myred,\n    lw = 2,\n    label = \"\",\n)\n\n\nOn trace sur ce diagramme la trajectoire simulée plus haut :\n\nplot!(\n    figbif,\n    sol_tord_ois.y,\n    sol_tord_ois.x;\n    color = myblue,\n    linewidth = 2,\n    linealpha = 0.5,\n    label = \"trajectoire\",\n)"
  },
  {
    "objectID": "pop_interactions.html#sec-lv",
    "href": "pop_interactions.html#sec-lv",
    "title": "Populations en interaction (1)",
    "section": "Le modèle proie-prédateur de Lotka et Volterra",
    "text": "Le modèle proie-prédateur de Lotka et Volterra\nNous considérons le modèle de dynamique de populations de Lotka (1925) et Volterra (1926) :\n\n\\left\\{\\begin{array}{l}\n\\dot x = rx - c xy,\\\\\n\\dot y = bxy - m y.\n\\end{array}\\right.\n\\tag{2}\nAvec x la population de proies et y la population de prédateurs.\n\nDynamiques\nIl n’y a pas de difficulté particulière à la simulation par rapport au modèle de la tordeuse du bourgeon de l’épinette avec population d’oiseaux variables.\n\n\nCode\n# conditions initiales\nx0 = 1.0\ny0 = 1.95\netat0 = [x0, y0]\n\n# paramètres\nr = 1.0\nc = 1.0\nb = 1.0\nm = 1.0\npar_lovo = [r, c, b, m]\n\n# temps d'integration\ntspan = (0.0, 30.0)\ntstep = .01\n\n# définition du modèle\nfunction lovo(u, par, t)\n    r, c, b, m = par\n    x = u[1]\n    y = u[2]\n    dx = r*x - c*x*y\n    dy = b*x*y - m*y\n    return [dx, dy]\nend\n\n# problème\nprob_lovo = ODEProblem(lovo, etat0, tspan, par_lovo, saveat = tstep)\n\n# intégration\nsol_lovo = solve(prob_lovo, reltol = 1e-6)\n\n# dataframe\nsol_lovo = DataFrame(sol_lovo)\nrename!(sol_lovo, :timestamp =&gt; :time, :value1 =&gt; :x, :value2 =&gt; :y)\n\nfiglv = plot(\n    sol_lovo.time,\n    sol_lovo.x;\n    linewidth = 2,\n    color = myblue,\n    label = \"proies\",\n    xlabel = \"temps\",\n    ylabel = \"densité de populations\",\n    title = \"Modèle de Lotka Volterra\",\n    margin = .5Plots.cm,\n    topmargin = 1Plots.cm,\n)\n\nplot!(\n    figlv,\n    sol_lovo.time,\n    sol_lovo.y;\n    linewidth = 2,\n    color = myorange,\n    label = \"prédateurs\",\n)\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nEspace d’état\nCommençons par tracer les isoclines nulles ainsi que l’orientation du champs de vecteur dans l’espace d’état. Ce dernier utilise la fonction quiver().\n\n\n\n\n\n\nCaution\n\n\n\nCe qui suit fonctionne avec Plots.jl, néanmoins la façon de tracer le champs de vecteurs semble vraiment peu naturelle. La librairie graphique Makie que nous verrons un peu plus loin permet de faire ces représentations bien plus facilement, comme nous le voyons ici.\n\n\n\n# fonctions qui renvoient les composantes de la dérivée mises à l'échelle\nscale = 10\nder_x(x, y) = lovo([x y], par_lovo, 0)[1]/scale\nder_y(x, y) = lovo([x y], par_lovo, 0)[2]/scale\n\n# valeur de x et y formant une grille sur laquelle évaluer le champs de vecteurs\nxrange = range(0., 2, length=11)'  # note the quote : broadcast pour créer une grille via der_x.() et der_y.()\nyrange = range(0. ,2, length=11)\n\n# champs de vecteurs\nfigplan = quiver(\n    xrange,\n    yrange,\n    quiver = (der_x.(xrange, yrange), der_y.(xrange, yrange));\n    ylim = (-0.05, 2),\n    xlim = (-0.05, 2),\n    color = :lightgray,\n    grid = false,\n    title = \"Modèle de Lotka Volterra\",\n    xlabel = \"proies\",\n    ylabel = \"prédateurs\",\n    margin = .5Plots.cm,\n    topmargin = 1Plots.cm,\n)\n\nOn rajoute les isoclines nulles et les équilibres :\n\n\nCode\n# isoclines nulles\nxplot = 0:2\nyplot = 0:2\n\n# dot x = 0\nplot!(\n    figplan,\n    xplot,\n    ones(length(xplot)).*r./c;\n    linewidth = 2,\n    color = mygreen,\n    label = \"\\$\\\\dot x = 0\\$\",\n)\nplot!(\n    figplan,\n    zeros(length(yplot)),\n    yplot;\n    linewidth = 2,\n    color = mygreen,\n    label = \"\",\n)\n\n# dot y = 0\nplot!(\n    figplan,\n    ones(length(yplot)).*m./b,\n    yplot;\n    linewidth = 2,\n    color = myred,\n    label = \"\\$\\\\dot y = 0\\$\",\n)\nplot!(\n    figplan,\n    xplot,\n    zeros(length(xplot));\n    linewidth = 2,\n    color = myred,\n    label = \"\",\n)\n\n# équilibres\nplot!(\n    figplan,\n    (0, 0);\n    markershape = :circle,\n    color= myred,\n    label = \"\",\n)\nplot!(\n    figplan,\n    (m/b, r/c);\n    markershape = :circle,\n    color= myorange,\n    label = \"\",\n)\n\n\nEt enfin la trajectoire :\n\n\nCode\n# trajectoire\nplot!(\n    figplan,\n    sol_lovo.x,\n    sol_lovo.y;\n    color = myblue,\n    linewidth = 2,\n    label = \"trajectoire\",\n)\n\ndisplay(figplan)\n\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 1: Plan de phase du modèle de Lotka Volterra\n\n\n\n\n\nIntégrale première\nNous illustrons en 3D l’intégrale première du modèle et superposons la trajectoire simulée plus haut sur ce graphique. L’intégrale première s’écrit : \nH(x,y)= -r\\log(y)+c y-m\\log(x) + bx\n\n\n# l'intégrale première\nfunction int_prem(x, y, par = par_lovo)\n    r, c, b, m = par\n    return -r*log(y) + c*y - m*log(x) + b*x\nend\n\nPour tracer le graphique en 3D, nous utilisons le backend plotly.\n\nplotly()\n\n# x, y\nxsurf = 0.2:0.1:3.0\nysurf = 0.2:0.1:3.0\n\n# calcul de la surface via une compréhension de liste\nzsurf = [int_prem(x, y, par_lovo) for x in xsurf, y in ysurf]\n# et H(x0, y0)\nzplane = [int_prem(x0, y0, par_lovo) for x in xsurf, y in ysurf]\n\n# on trace H(x0, y0)\nfigsurf = plot(\n    xsurf,\n    ysurf,\n    zplane; # array de taille length(xsurf) x length(ysurf)\n    st = :surface,\n    color = myorange,\n    alpha =.5,\n    label = \"\",\n)\n\n# l'intégrale première H(x,y)\nplot!(\n    figsurf,\n    xsurf,\n    ysurf,\n    zsurf; # array de taille length(xsurf) x length(ysurf)\n    st=:surface,\n    alpha = .6,\n    camera = (30, 10),\n    color = :viridis, # colormap\n    xlabel = \"proies\",\n    ylabel = \"prédateurs\",\n    title = \"Intégrale première du modèle de Lotka Volterra\",\n)\n\n# la trajectoire\n# un simple plot avec 3 coordonnees: x et y de la solution, et z = H(x,y)\nplot!(\n    figsurf,\n    sol_lovo.x,\n    sol_lovo.y,\n    ones(length(sol_lovo.x)).*int_prem(x0, y0, par_lovo);\n    color = myred,\n    lw=4,\n    label = \"\",\n)\n\n    \n    \n\n\n\n\nAllons plus loin en étudiant le modèle de Rosenzweig MacArthur, par ici."
  },
  {
    "objectID": "pop_interactions2.html",
    "href": "pop_interactions2.html",
    "title": "Populations en interaction (2)",
    "section": "",
    "text": "Nous considérons le modèle de dynamique de populations attribué à Rosenzweig et MacArthur (voir Rosenzweig and MacArthur (1963), Turchin (2003), Smith (2008)).\n\n\\left\\{\\begin{array}{l}\n\\dot x = \\displaystyle rx\\left(1-\\frac{x}{K}\\right) - c \\frac{x}{h+x} y\\\\[.3cm]\n\\dot y = b\\displaystyle \\frac{x}{h+x} y - m y\n\\end{array}\\right.\n\\tag{1}\n\n\nIl n’y a pas de difficulté particulière à la simulation par rapport au modèle de Lotka Volterra.\n\n\nCode\nusing DifferentialEquations\nusing DataFrames\n\n# conditions initiales\nx0 = 1.0\ny0 = 1.95\netat0 = [x0, y0]\n\n# paramètres\nr = 1.0\nK = 10.0\nc = 1.0\nh = 2.0\nb = 2.0\nm = 1.0\npar_rma = [r, K, c, h, b, m]\n\n# temps d'integration\ntspan = (0.0, 55.0)\ntstep = .01\n\n# définition du modèle\nfunction rma(u, par, t)\n    r, K, c, h, b, m = par\n    x = u[1]\n    y = u[2]\n\n    dx = r*x*(1-x/K) - c*x/(h+x)*y\n    dy = b*x/(h+x)*y - m*y\n\n    return [dx, dy]\nend\n\n# problème d'intégration\nprob_rma = ODEProblem(\n    rma,\n    etat0,\n    tspan,\n    par_rma;\n    saveat = tstep,\n)\n\n# intégration\nsol_rma = solve(prob_rma, reltol = 1e-6)\n\n# dataframe\nsol_rma = DataFrame(sol_rma)\nrename!(sol_rma, :timestamp =&gt; :time, :value1 =&gt; :x, :value2 =&gt; :y)\n\n\nNous utiliserons ici le package de visualisation graphique Makie.jl1 à la place de Plots.jl. Makie.jl permet un contrôle très approfondi des graphiques. Commençons par tracer les dynamiques contre le temps dans une figure simple.1 entièrement écrit en Julia, présenté comme “le futur” de la représentation graphique avec Julia. Une bonne introduction à Makie.\nNous utiliserons le backend CairoMakie pour la visualisation en 2D.\n\nusing CairoMakie\n\nUn peu comme Matplotlib en Python, Makie définit un triplet FigureAxisPlot : la figure est le conteneur de (éventuellement) plusieurs systèmes d’axes qui contiennent chacun un ou plusieurs graphiques (ligne, point, etc.).\n\n# on crée la figure\nfig1 = Figure(;\n    backgroundcolor = :transparent,\n    size = (600,400),\n    fontsize = 18,\n)\n\n# on crée un système d'axes en position [1,1] dans la figure\nax1 = Axis(\n    fig1[1,1];\n    xlabel = \"temps\",\n    ylabel = \"densités de populations\",\n    title = \"Modèle de Rosenzweig MacArthur\",\n)\n\n# on trace la population x contre le temps sur le système d'axe ax1\nlines!(\n    ax1,\n    sol_rma.time,\n    sol_rma.x;\n    linewidth = 2,\n    linestyle = :solid,\n    label = L\"x(t)\",   # formule Latex dans la chaine de caractère\n)\n\n# on rajoute la population y\nlines!(\n    ax1,\n    sol_rma.time,\n    sol_rma.y;\n    linewidth = 2,\n    linestyle = :solid,\n    label = L\"y(t)\",\n)\n\n# légende\naxislegend(position = :lt)   # position left top\n\n# on affiche la figure, pas de display() ici\nfig1\n\n\n\n\nFigure 1: Une première figure avec Makie.jl\n\n\n\n\n\n\n\n\n\nNous allons maintenant tracer un graphique plus complexe comprenant en colonne de droite les dynamiques des proies et des prédateurs sur deux lignes et en colonne de gauche le plan de phase. Préparons la figure et les systèmes d’axes.\n\n# figure\nfig2 = Figure(;\n    backgroundcolor = :transparent,\n    size = (800,500),\n    fontsize = 20,\n)\n\n# 3 systèmes d'axes\n# position 1e ligne 1e colonne\nax21 = Axis(fig2[1,1]; title = \"Dynamiques\")\n\n# position 2e ligne 1e colonne\nax22 = Axis(fig2[2,1]; xlabel = \"temps\")\n\nax23 = Axis(\n    fig2[:,2];       # position toutes les lignes, 2e colonne\n    xlabel = \"proies\",\n    ylabel = \"prédateurs\",\n    title = \"Plan de phase\",\n)\n\n# on agrandi un peu la deuxième colonne de la figure\ncolsize!(fig2.layout, 2, Auto(1.5))\n\n# ajout d'un titre\nsupertitle = Label(\n    fig2[0, :],      # position ligne \"0\" toutes les colonnes\n    \"Modèle de Rosenzweig MacArthur\";\n    fontsize = 26,\n)\n\n# ajout d'un label d'axes commun à la première colonne\nsideinfo = Label(\n    fig2[1:2, 0],    # position toutes les lignes, 1e colonne\n    \"densités de populations\";\n    rotation = π/2,  # \\pi + TAB, pi/2 fonctionne aussi ici\n)\n\n# on affiche la figure\nfig2\n\n\n\n\n\n\n\nOn rajoute les dynamiques :\n\n# la courbe de dynamique de x sur ax21\nlines!(\n    ax21,\n    sol_rma.time,\n    sol_rma.x;\n    color = Cycled(1),  # pick color 1 in the colorcycle\n    linewidth = 2,\n    linestyle = :solid,\n    label = L\"x\",\n)\n\n# légende pour ce système d'axe\naxislegend(ax21, position = :lt, labelsize = 14)\n\n# la courbe de dynamique de y sur ax22\nlines!(\n    ax22,\n    sol_rma.time,\n    sol_rma.y;\n    color = Cycled(2),\n    linewidth = 2,\n    linestyle = :solid,\n    label = L\"y\",\n)\n\n# légende pour ce système d'axe\naxislegend(ax22, position = :lt, labelsize = 14)\n\n# on enlève les labels de l'axe des x de ax21 (redondants)\nhidexdecorations!(ax21, ticks = false)\n\n# affiche la figure\nfig2\n\n\n\n\n\n\n\nPassons maintenant au plan de phase dans le dernier système d’axes. Commençons par les isoclines nulles de \\dot x et \\dot y :\n\n# calcul des isoclines nulles\n# vecteurs pour le plot\nxplot = LinRange(0.0, K+.1, 30)\nyplot = xplot\n\n# isoclines nulles de xdot\nnull_x_x = ones(length(yplot)).*0        # x = 0 isocline nulle de xdot\nnull_x_y = [r/c*(h+x)*(1-x/K) for x in xplot]  # y = f(x) isocline nulle de xdot\n\n# isoclines nulles de ydot\nnull_y_y = ones(length(xplot)).*0     # y = 0 isocline nulle de ydot\nnull_y_x = [m*h/(b-m) for x in yplot] # x = mh/(b-m) isocline nulle de ydot\n\n# tracé des isoclines nulle de x\nlines!(\n    ax23,\n    null_x_x,\n    yplot;\n    color = Cycled(2),\n    linewidth = 2,\n    linestyle = :solid,\n)\n\nlines!(\n    ax23,\n    xplot,\n    null_x_y;\n    color = Cycled(2),\n    linewidth = 2,\n    linestyle = :solid,\n    label = L\"nullcline de $x$\",\n)\n\n# tracé des isoclines nulle de y\nlines!(\n    ax23,\n    xplot,\n    null_y_y;\n    color = Cycled(3),\n    linewidth = 2,\n    linestyle = :solid,\n)\n\nlines!(\n    ax23,\n    null_y_x,\n    yplot;\n    color = Cycled(3),\n    linewidth = 2,\n    linestyle = :solid,\n    label = L\"nullcline de $y$\",\n)\n\nPuis nous ajoutons les équilibres:\n\n# tracé des équilibres\n# équilibre d'extinction\nscatter!(            # scatter pour des points\n    ax23,\n    0,\n    0;\n    color = Cycled(4),\n    label = L\"équilibres$$\",\n)\n\n# prey only\nscatter!(ax23, K, 0, color = Cycled(4))\n\n# équilibre de coexistence\neq_coex = [m*h/(b-m), r/c*(h+m*h/(b-m))*(1-m*h/(b-m)/K)]\n\nscatter!(ax23, eq_coex[1], eq_coex[2]; color = Cycled(4))\n\nPour tracer le champs de vecteurs, nous créons deux vecteurs de coordonnées x et y, et calculons par compréhension de liste des matrices de taille correspondante indiquant les composantes x et y des vecteurs vitesse. Les vecteurs de coordonnées et les matrices de composante des vitesses sont ensuite passées comme argument à la fonction arrows.\n\n# champs de vecteur\nscale = 10           # il faut mettre à l'échelle sinon on voit rien\nxrange = range(1, 10, length=11)\nyrange = range(1. ,10, length=11)\n\n# composantes des vecteurs vitesses par compréhension de liste\nderx = [rma([x y], par_rma, 0)[1]/scale for x in xrange, y in yrange]\ndery = [rma([x y], par_rma, 0)[2]/scale for x in xrange, y in yrange]\n\n# champs de vecteurs\narrows!(\n    ax23,\n    xrange,          # coordonnée x du début d'une flèche\n    yrange,          # coordonnée y du début d'une flèche\n    derx,            # x fin de la flèche (relativement au debut)\n    dery;            # y fin de la flèche (relativement au debut)\n    color = :lightgray,\n    arrowsize = 10,\n)\n\n\n\n\n\n\n\nCaution\n\n\n\nDans les compréhensions de listes à plusieurs variables/itérateurs, la syntaxe a son importance:\n\n[1 for x in xrange, y in yrange] crée un array de taille length(xrange) par length(yrange)\n[1 for x in xrange for y in yrange] crée un vecteur de taille length(xrange) + length(yrange)\n\n\n\net enfin la trajectoire :\n\n# trajectoire dans le plan de phase\nlines!(\n    ax23,\n    sol_rma.x,\n    sol_rma.y;\n    color = Cycled(1),\n    linewidth = 2,\n    linestyle = :solid,\n    label = L\"trajectoire $$\",\n)\n\n# ajuste l'espacement des colonnes et lignes\ncolgap!(fig2.layout, 20)\nrowgap!(fig2.layout, 20)\n\n# affiche la figure\nfig2\n\n\n\n\nFigure 2: Une figure plus complexe avec Makie.jl\n\n\n\n\nOn peut sauvegarder la figure dans différents formats (e.g. png, pdf)\n\nsave(\"rma_fig.png\", fig2)\nsave(\"rma_fig.pdf\", fig2)\n\n\n\n\n\nPour finir, nous allons tracer le diagramme de bifurcation du modèle de Rosenzweig MacArthur: asymptotiques des prédateurs y^* en fonction de K, en identifiant les bifurcations transcritique et de Hopf vues en cours, et en estimant et représentant les extremas du cycle limite apparaissant pour K grand.\nPour rappel, il y a 3 situations asymptotiques distinctes pour le modèle de Rosenzweig MacArthur :\n\nsi : 0&lt;K&lt;\\displaystyle\\frac{mh}{b-m} : les prédateurs s’éteignent et les proies convergent vers K, l’équilibre d’extinction des deux populations est instable.\nsi : \\displaystyle\\frac{mh}{b-m} &lt;K&lt; h+\\frac{2mh}{b-m} : proies et prédateurs co-existent à un équilibre globalement asymptotiquement stable, l’équilibre d’extinction des prédateurs est instable, l’équilibre d’extinction des deux populations est instable.\nsi : h+\\displaystyle\\frac{2mh}{b-m}&lt;K: proies et prédateurs co-existent le long d’un cycle limite globalement asymptotiquement stable, l’équilibre d’extinction des prédateurs est instable, l’équilibre d’extinction des deux populations est instable.\n\nDans un premier temps nous allons calculer et représenter les différents équilibres et leur stabilité dans le plan (K, y), puis nous calculerons et rajouterons une représentation du cycle limite.\n\n\nNous faisons une boucle sur les valeurs de K et calculons les équilibres.\n\nK_step = 0.1\n\n# before transcritical\nK_plot1 = 0:K_step:m*h/(b-m)\ny_eq01 = ones(length(K_plot1)).*0\n\n# between transcritical and Hopf\nK_plot2 = m*h/(b-m):K_step:h+2*m*h/(b-m)\ny_eq02 = ones(length(K_plot2)).*0\ny_co2 = [r/c*(h+m*h/(b-m))*(1-m*h/(b-m)/K_p) for K_p in K_plot2]\n\n# above Hopf\nK_plot3 = h+2*m*h/(b-m)-K_step/5:(K_step/10):8\ny_eq03 = ones(length(K_plot3)).*0\ny_co3 = [r/c*(h+m*h/(b-m))*(1-m*h/(b-m)/K_p) for K_p in K_plot3]\n\nEt nous commençons le tracé de la figure :\n\n\nCode\n# création d'une figure\nfig3 = Figure(;\n    backgroundcolor = :transparent,\n    size = (600,400),\n    fontsize = 18,\n)\n\n# on crée un système d'axes en position [1,1] dans la figure\nax31 = Axis(\n    fig3[1,1];\n    xlabel = L\"capacité de charge $K$\",\n    ylabel = L\"densité de population $y^*$\",\n    title = \"Diagramme de bifurcations pour le\\n modèle de Rosenzweig MacArthur\",\n)\n\n# on trace la population x su ax31\n# left of transcritical\nlines!(\n    ax31,\n    K_plot1,\n    y_eq01;\n    color = Cycled(1),\n    linewidth = 2,\n    label = L\"branche stable$$\", # $$ to keep the latex font\n)\n\n# between transcritical and Hopf\nlines!(\n    ax31,\n    K_plot2,\n    y_eq02;\n    color = Cycled(2),\n    linewidth = 2,\n    label = L\"branche instable$$\",\n)\n\nlines!(\n    ax31,\n    K_plot2,\n    y_co2;\n    color = Cycled(1),\n    linewidth = 2,\n)\n\n# right of Hopf\nlines!(\n    ax31,\n    K_plot3,\n    y_eq03;\n    color = Cycled(2),\n    linewidth = 2,\n)\n\nlines!(\n    ax31,\n    K_plot3,\n    y_co3;\n    color = Cycled(2),\n    linewidth = 2,\n)\n\nfig3\n\n\n\n\n\n\n\n\nPour estimer le cycle limite pour chaque la valeur de K nous allons simuler le modèle pendant un transitoire assez long, puis repartir de cette valeur de l’état, simuler un cycle et récupérer les extremas pour les tracer. Nous utilisons une méthode basée sur remake pour modifier le problème d’intégration2.2 voir aussi l’annexe\n\n# \"long\" transient integration time\nt_trans = (0.0, 8000.0)\n\n# for storage\ny_cmin = zero(K_plot3)\ny_cmax = zero(K_plot3)\n\n\n# define generic simulation problem\nrma_pbe = ODEProblem(rma, etat0, t_trans, par_rma)\n\n# estimate limit cycle through loop on K\n@time for (i, Kc) in enumerate(K_plot3)     # loop on (index, K) values of K_plot3\n    par_rmac = [r, Kc, c, h, b, m]    # set parameters\n\n    # transient initial value problem; remake problem with par = par_rmac\n    rma_trans_pbe =  remake(rma_pbe; p = par_rmac)\n    # with such arguments `solve` yields only final value of simulation\n    post_trans2 = solve(\n        rma_trans_pbe;\n        save_everystep = false,\n        save_start = false,\n        abstol=1e-6,\n        reltol=1e-6,\n    )\n\n    # limit cycle initial value problem; simulation\n    rma_cycle_pbe =  remake(\n        rma_pbe;\n        p = par_rmac,\n        u0 = post_trans2[:,1], # initial condition from transient simulation\n        tspan = tspan,\n        saveat = tstep,\n    )\n    # simulation\n    sol_cycle = solve(rma_cycle_pbe; abstol=1e-6, reltol=1e-6)\n\n    # get the extrema of y, store at index i\n    y_cmin[i] = minimum(sol_cycle[2,:])\n    y_cmax[i] = maximum(sol_cycle[2,:])\nend\n\n 10.583470 seconds (325.91 M allocations: 24.391 GiB, 13.43% gc time, 10.65% compilation time)\n\n\n\n\n\nFinalement, on inclut les branches calculées dans le diagramme de bifurcations.\n\n\nCode\nlines!(\n    ax31,\n    K_plot3,\n    y_cmin;\n    color = Cycled(3),\n    linewidth = 2,\n    label = L\"cycle limite$$\",\n)\n\nlines!(\n    ax31,\n    K_plot3,\n    y_cmax;\n    color = Cycled(3),\n    linewidth = 2,\n)\n\naxislegend(ax31, position = :lt, labelsize = 14)\n\nfig3\n\n\n\n\n\nFigure 3: Diagramme de bifurcations du modèle de Rosenzweig MacArthur.\n\n\n\n\n\n\nThat’s all folks!"
  },
  {
    "objectID": "pop_interactions2.html#sec-rma",
    "href": "pop_interactions2.html#sec-rma",
    "title": "Populations en interaction (2)",
    "section": "",
    "text": "Nous considérons le modèle de dynamique de populations attribué à Rosenzweig et MacArthur (voir Rosenzweig and MacArthur (1963), Turchin (2003), Smith (2008)).\n\n\\left\\{\\begin{array}{l}\n\\dot x = \\displaystyle rx\\left(1-\\frac{x}{K}\\right) - c \\frac{x}{h+x} y\\\\[.3cm]\n\\dot y = b\\displaystyle \\frac{x}{h+x} y - m y\n\\end{array}\\right.\n\\tag{1}\n\n\nIl n’y a pas de difficulté particulière à la simulation par rapport au modèle de Lotka Volterra.\n\n\nCode\nusing DifferentialEquations\nusing DataFrames\n\n# conditions initiales\nx0 = 1.0\ny0 = 1.95\netat0 = [x0, y0]\n\n# paramètres\nr = 1.0\nK = 10.0\nc = 1.0\nh = 2.0\nb = 2.0\nm = 1.0\npar_rma = [r, K, c, h, b, m]\n\n# temps d'integration\ntspan = (0.0, 55.0)\ntstep = .01\n\n# définition du modèle\nfunction rma(u, par, t)\n    r, K, c, h, b, m = par\n    x = u[1]\n    y = u[2]\n\n    dx = r*x*(1-x/K) - c*x/(h+x)*y\n    dy = b*x/(h+x)*y - m*y\n\n    return [dx, dy]\nend\n\n# problème d'intégration\nprob_rma = ODEProblem(\n    rma,\n    etat0,\n    tspan,\n    par_rma;\n    saveat = tstep,\n)\n\n# intégration\nsol_rma = solve(prob_rma, reltol = 1e-6)\n\n# dataframe\nsol_rma = DataFrame(sol_rma)\nrename!(sol_rma, :timestamp =&gt; :time, :value1 =&gt; :x, :value2 =&gt; :y)\n\n\nNous utiliserons ici le package de visualisation graphique Makie.jl1 à la place de Plots.jl. Makie.jl permet un contrôle très approfondi des graphiques. Commençons par tracer les dynamiques contre le temps dans une figure simple.1 entièrement écrit en Julia, présenté comme “le futur” de la représentation graphique avec Julia. Une bonne introduction à Makie.\nNous utiliserons le backend CairoMakie pour la visualisation en 2D.\n\nusing CairoMakie\n\nUn peu comme Matplotlib en Python, Makie définit un triplet FigureAxisPlot : la figure est le conteneur de (éventuellement) plusieurs systèmes d’axes qui contiennent chacun un ou plusieurs graphiques (ligne, point, etc.).\n\n# on crée la figure\nfig1 = Figure(;\n    backgroundcolor = :transparent,\n    size = (600,400),\n    fontsize = 18,\n)\n\n# on crée un système d'axes en position [1,1] dans la figure\nax1 = Axis(\n    fig1[1,1];\n    xlabel = \"temps\",\n    ylabel = \"densités de populations\",\n    title = \"Modèle de Rosenzweig MacArthur\",\n)\n\n# on trace la population x contre le temps sur le système d'axe ax1\nlines!(\n    ax1,\n    sol_rma.time,\n    sol_rma.x;\n    linewidth = 2,\n    linestyle = :solid,\n    label = L\"x(t)\",   # formule Latex dans la chaine de caractère\n)\n\n# on rajoute la population y\nlines!(\n    ax1,\n    sol_rma.time,\n    sol_rma.y;\n    linewidth = 2,\n    linestyle = :solid,\n    label = L\"y(t)\",\n)\n\n# légende\naxislegend(position = :lt)   # position left top\n\n# on affiche la figure, pas de display() ici\nfig1\n\n\n\n\nFigure 1: Une première figure avec Makie.jl\n\n\n\n\n\n\n\n\n\nNous allons maintenant tracer un graphique plus complexe comprenant en colonne de droite les dynamiques des proies et des prédateurs sur deux lignes et en colonne de gauche le plan de phase. Préparons la figure et les systèmes d’axes.\n\n# figure\nfig2 = Figure(;\n    backgroundcolor = :transparent,\n    size = (800,500),\n    fontsize = 20,\n)\n\n# 3 systèmes d'axes\n# position 1e ligne 1e colonne\nax21 = Axis(fig2[1,1]; title = \"Dynamiques\")\n\n# position 2e ligne 1e colonne\nax22 = Axis(fig2[2,1]; xlabel = \"temps\")\n\nax23 = Axis(\n    fig2[:,2];       # position toutes les lignes, 2e colonne\n    xlabel = \"proies\",\n    ylabel = \"prédateurs\",\n    title = \"Plan de phase\",\n)\n\n# on agrandi un peu la deuxième colonne de la figure\ncolsize!(fig2.layout, 2, Auto(1.5))\n\n# ajout d'un titre\nsupertitle = Label(\n    fig2[0, :],      # position ligne \"0\" toutes les colonnes\n    \"Modèle de Rosenzweig MacArthur\";\n    fontsize = 26,\n)\n\n# ajout d'un label d'axes commun à la première colonne\nsideinfo = Label(\n    fig2[1:2, 0],    # position toutes les lignes, 1e colonne\n    \"densités de populations\";\n    rotation = π/2,  # \\pi + TAB, pi/2 fonctionne aussi ici\n)\n\n# on affiche la figure\nfig2\n\n\n\n\n\n\n\nOn rajoute les dynamiques :\n\n# la courbe de dynamique de x sur ax21\nlines!(\n    ax21,\n    sol_rma.time,\n    sol_rma.x;\n    color = Cycled(1),  # pick color 1 in the colorcycle\n    linewidth = 2,\n    linestyle = :solid,\n    label = L\"x\",\n)\n\n# légende pour ce système d'axe\naxislegend(ax21, position = :lt, labelsize = 14)\n\n# la courbe de dynamique de y sur ax22\nlines!(\n    ax22,\n    sol_rma.time,\n    sol_rma.y;\n    color = Cycled(2),\n    linewidth = 2,\n    linestyle = :solid,\n    label = L\"y\",\n)\n\n# légende pour ce système d'axe\naxislegend(ax22, position = :lt, labelsize = 14)\n\n# on enlève les labels de l'axe des x de ax21 (redondants)\nhidexdecorations!(ax21, ticks = false)\n\n# affiche la figure\nfig2\n\n\n\n\n\n\n\nPassons maintenant au plan de phase dans le dernier système d’axes. Commençons par les isoclines nulles de \\dot x et \\dot y :\n\n# calcul des isoclines nulles\n# vecteurs pour le plot\nxplot = LinRange(0.0, K+.1, 30)\nyplot = xplot\n\n# isoclines nulles de xdot\nnull_x_x = ones(length(yplot)).*0        # x = 0 isocline nulle de xdot\nnull_x_y = [r/c*(h+x)*(1-x/K) for x in xplot]  # y = f(x) isocline nulle de xdot\n\n# isoclines nulles de ydot\nnull_y_y = ones(length(xplot)).*0     # y = 0 isocline nulle de ydot\nnull_y_x = [m*h/(b-m) for x in yplot] # x = mh/(b-m) isocline nulle de ydot\n\n# tracé des isoclines nulle de x\nlines!(\n    ax23,\n    null_x_x,\n    yplot;\n    color = Cycled(2),\n    linewidth = 2,\n    linestyle = :solid,\n)\n\nlines!(\n    ax23,\n    xplot,\n    null_x_y;\n    color = Cycled(2),\n    linewidth = 2,\n    linestyle = :solid,\n    label = L\"nullcline de $x$\",\n)\n\n# tracé des isoclines nulle de y\nlines!(\n    ax23,\n    xplot,\n    null_y_y;\n    color = Cycled(3),\n    linewidth = 2,\n    linestyle = :solid,\n)\n\nlines!(\n    ax23,\n    null_y_x,\n    yplot;\n    color = Cycled(3),\n    linewidth = 2,\n    linestyle = :solid,\n    label = L\"nullcline de $y$\",\n)\n\nPuis nous ajoutons les équilibres:\n\n# tracé des équilibres\n# équilibre d'extinction\nscatter!(            # scatter pour des points\n    ax23,\n    0,\n    0;\n    color = Cycled(4),\n    label = L\"équilibres$$\",\n)\n\n# prey only\nscatter!(ax23, K, 0, color = Cycled(4))\n\n# équilibre de coexistence\neq_coex = [m*h/(b-m), r/c*(h+m*h/(b-m))*(1-m*h/(b-m)/K)]\n\nscatter!(ax23, eq_coex[1], eq_coex[2]; color = Cycled(4))\n\nPour tracer le champs de vecteurs, nous créons deux vecteurs de coordonnées x et y, et calculons par compréhension de liste des matrices de taille correspondante indiquant les composantes x et y des vecteurs vitesse. Les vecteurs de coordonnées et les matrices de composante des vitesses sont ensuite passées comme argument à la fonction arrows.\n\n# champs de vecteur\nscale = 10           # il faut mettre à l'échelle sinon on voit rien\nxrange = range(1, 10, length=11)\nyrange = range(1. ,10, length=11)\n\n# composantes des vecteurs vitesses par compréhension de liste\nderx = [rma([x y], par_rma, 0)[1]/scale for x in xrange, y in yrange]\ndery = [rma([x y], par_rma, 0)[2]/scale for x in xrange, y in yrange]\n\n# champs de vecteurs\narrows!(\n    ax23,\n    xrange,          # coordonnée x du début d'une flèche\n    yrange,          # coordonnée y du début d'une flèche\n    derx,            # x fin de la flèche (relativement au debut)\n    dery;            # y fin de la flèche (relativement au debut)\n    color = :lightgray,\n    arrowsize = 10,\n)\n\n\n\n\n\n\n\nCaution\n\n\n\nDans les compréhensions de listes à plusieurs variables/itérateurs, la syntaxe a son importance:\n\n[1 for x in xrange, y in yrange] crée un array de taille length(xrange) par length(yrange)\n[1 for x in xrange for y in yrange] crée un vecteur de taille length(xrange) + length(yrange)\n\n\n\net enfin la trajectoire :\n\n# trajectoire dans le plan de phase\nlines!(\n    ax23,\n    sol_rma.x,\n    sol_rma.y;\n    color = Cycled(1),\n    linewidth = 2,\n    linestyle = :solid,\n    label = L\"trajectoire $$\",\n)\n\n# ajuste l'espacement des colonnes et lignes\ncolgap!(fig2.layout, 20)\nrowgap!(fig2.layout, 20)\n\n# affiche la figure\nfig2\n\n\n\n\nFigure 2: Une figure plus complexe avec Makie.jl\n\n\n\n\nOn peut sauvegarder la figure dans différents formats (e.g. png, pdf)\n\nsave(\"rma_fig.png\", fig2)\nsave(\"rma_fig.pdf\", fig2)\n\n\n\n\n\nPour finir, nous allons tracer le diagramme de bifurcation du modèle de Rosenzweig MacArthur: asymptotiques des prédateurs y^* en fonction de K, en identifiant les bifurcations transcritique et de Hopf vues en cours, et en estimant et représentant les extremas du cycle limite apparaissant pour K grand.\nPour rappel, il y a 3 situations asymptotiques distinctes pour le modèle de Rosenzweig MacArthur :\n\nsi : 0&lt;K&lt;\\displaystyle\\frac{mh}{b-m} : les prédateurs s’éteignent et les proies convergent vers K, l’équilibre d’extinction des deux populations est instable.\nsi : \\displaystyle\\frac{mh}{b-m} &lt;K&lt; h+\\frac{2mh}{b-m} : proies et prédateurs co-existent à un équilibre globalement asymptotiquement stable, l’équilibre d’extinction des prédateurs est instable, l’équilibre d’extinction des deux populations est instable.\nsi : h+\\displaystyle\\frac{2mh}{b-m}&lt;K: proies et prédateurs co-existent le long d’un cycle limite globalement asymptotiquement stable, l’équilibre d’extinction des prédateurs est instable, l’équilibre d’extinction des deux populations est instable.\n\nDans un premier temps nous allons calculer et représenter les différents équilibres et leur stabilité dans le plan (K, y), puis nous calculerons et rajouterons une représentation du cycle limite.\n\n\nNous faisons une boucle sur les valeurs de K et calculons les équilibres.\n\nK_step = 0.1\n\n# before transcritical\nK_plot1 = 0:K_step:m*h/(b-m)\ny_eq01 = ones(length(K_plot1)).*0\n\n# between transcritical and Hopf\nK_plot2 = m*h/(b-m):K_step:h+2*m*h/(b-m)\ny_eq02 = ones(length(K_plot2)).*0\ny_co2 = [r/c*(h+m*h/(b-m))*(1-m*h/(b-m)/K_p) for K_p in K_plot2]\n\n# above Hopf\nK_plot3 = h+2*m*h/(b-m)-K_step/5:(K_step/10):8\ny_eq03 = ones(length(K_plot3)).*0\ny_co3 = [r/c*(h+m*h/(b-m))*(1-m*h/(b-m)/K_p) for K_p in K_plot3]\n\nEt nous commençons le tracé de la figure :\n\n\nCode\n# création d'une figure\nfig3 = Figure(;\n    backgroundcolor = :transparent,\n    size = (600,400),\n    fontsize = 18,\n)\n\n# on crée un système d'axes en position [1,1] dans la figure\nax31 = Axis(\n    fig3[1,1];\n    xlabel = L\"capacité de charge $K$\",\n    ylabel = L\"densité de population $y^*$\",\n    title = \"Diagramme de bifurcations pour le\\n modèle de Rosenzweig MacArthur\",\n)\n\n# on trace la population x su ax31\n# left of transcritical\nlines!(\n    ax31,\n    K_plot1,\n    y_eq01;\n    color = Cycled(1),\n    linewidth = 2,\n    label = L\"branche stable$$\", # $$ to keep the latex font\n)\n\n# between transcritical and Hopf\nlines!(\n    ax31,\n    K_plot2,\n    y_eq02;\n    color = Cycled(2),\n    linewidth = 2,\n    label = L\"branche instable$$\",\n)\n\nlines!(\n    ax31,\n    K_plot2,\n    y_co2;\n    color = Cycled(1),\n    linewidth = 2,\n)\n\n# right of Hopf\nlines!(\n    ax31,\n    K_plot3,\n    y_eq03;\n    color = Cycled(2),\n    linewidth = 2,\n)\n\nlines!(\n    ax31,\n    K_plot3,\n    y_co3;\n    color = Cycled(2),\n    linewidth = 2,\n)\n\nfig3\n\n\n\n\n\n\n\n\nPour estimer le cycle limite pour chaque la valeur de K nous allons simuler le modèle pendant un transitoire assez long, puis repartir de cette valeur de l’état, simuler un cycle et récupérer les extremas pour les tracer. Nous utilisons une méthode basée sur remake pour modifier le problème d’intégration2.2 voir aussi l’annexe\n\n# \"long\" transient integration time\nt_trans = (0.0, 8000.0)\n\n# for storage\ny_cmin = zero(K_plot3)\ny_cmax = zero(K_plot3)\n\n\n# define generic simulation problem\nrma_pbe = ODEProblem(rma, etat0, t_trans, par_rma)\n\n# estimate limit cycle through loop on K\n@time for (i, Kc) in enumerate(K_plot3)     # loop on (index, K) values of K_plot3\n    par_rmac = [r, Kc, c, h, b, m]    # set parameters\n\n    # transient initial value problem; remake problem with par = par_rmac\n    rma_trans_pbe =  remake(rma_pbe; p = par_rmac)\n    # with such arguments `solve` yields only final value of simulation\n    post_trans2 = solve(\n        rma_trans_pbe;\n        save_everystep = false,\n        save_start = false,\n        abstol=1e-6,\n        reltol=1e-6,\n    )\n\n    # limit cycle initial value problem; simulation\n    rma_cycle_pbe =  remake(\n        rma_pbe;\n        p = par_rmac,\n        u0 = post_trans2[:,1], # initial condition from transient simulation\n        tspan = tspan,\n        saveat = tstep,\n    )\n    # simulation\n    sol_cycle = solve(rma_cycle_pbe; abstol=1e-6, reltol=1e-6)\n\n    # get the extrema of y, store at index i\n    y_cmin[i] = minimum(sol_cycle[2,:])\n    y_cmax[i] = maximum(sol_cycle[2,:])\nend\n\n 10.583470 seconds (325.91 M allocations: 24.391 GiB, 13.43% gc time, 10.65% compilation time)\n\n\n\n\n\nFinalement, on inclut les branches calculées dans le diagramme de bifurcations.\n\n\nCode\nlines!(\n    ax31,\n    K_plot3,\n    y_cmin;\n    color = Cycled(3),\n    linewidth = 2,\n    label = L\"cycle limite$$\",\n)\n\nlines!(\n    ax31,\n    K_plot3,\n    y_cmax;\n    color = Cycled(3),\n    linewidth = 2,\n)\n\naxislegend(ax31, position = :lt, labelsize = 14)\n\nfig3\n\n\n\n\n\nFigure 3: Diagramme de bifurcations du modèle de Rosenzweig MacArthur.\n\n\n\n\n\n\nThat’s all folks!"
  },
  {
    "objectID": "annexe_integrator.html",
    "href": "annexe_integrator.html",
    "title": "Simulations multiples",
    "section": "",
    "text": "Nous abordons ici brièvement les méthodes integrator et remake de DifferentialEquations.jl pour les simulations multiples."
  },
  {
    "objectID": "annexe_integrator.html#utilisation-de-linterface-integrator",
    "href": "annexe_integrator.html#utilisation-de-linterface-integrator",
    "title": "Matériel supplémentaire",
    "section": "",
    "text": "Lors de simulations multiples1, la stratégie choisie a été de redéfinir un nouveau problème d’intégration ODEProblem pour chaque condition initiale. Cette procédure est a priori très peu efficace, et DifferentialEquations.jl permet de modifier un problème d’intégration via la Integrator Interface.1 par exemple pour plusieurs conditions initiales pour le modèle avec effets Allee ou celui de la tordeuse du bourgeon de l’épinette\nLa même approche peut être utilisée pour redéfinir un problème d’intégration en modifiant les paramètres plutôt que la condition initiale, par exemple pour calculer un diagramme de bifurcations par force brute comme pour le modèle de Rosenzweig MacArthur.\nRépliquons la figure des dynamiques de la tordeuse du bourgeon de l’épinette avec cette méthode. On commence par définir les paramètres et le modèle:\n\n\nCode\nusing DifferentialEquations, Plots, DataFrames\n\n# paramètres\nr = 5.0      # natalité\nK = 10.0     # mortalité\nα = 1.0      # taux max de prédation\nh = 0.5      # constante de demi-saturation\nyc = 7.0     # densité de prédateurs\n\npar_tordeuse = [r, K, α, h, yc] \n\n# temps d'intégration\ntspan = (0.0, 3.0)\ntstep = 0.02\n\n# condition initale\nx0step = 1.35\n\n# modèle\nfunction tordeuse(u, p, t)\n    r, K, α, h, yc = p\n    x = u[1]\n    dx = r*x*(1 - x/K) - α*x^2/(h^2 + x^2)*yc\nend\n\n\nNous définissons ensuite le problème d’intégration ainsi que l’intégrateur integrator:\n\nprob_tordeuse = ODEProblem(tordeuse,         # modèle\n                           x0step,           # condition initiale\n                           tspan,            # tspan\n                           par_tordeuse,     # paramètres\n                           saveat = tstep)   # option de sortie\n\nintegrator = init(prob_tordeuse)\n\nPour une utilisation dans une boucle pour simuler les trajectoires depuis différentes conditions initiales, nous définissons une fonction qui réinitialise l’intégrateur à la nouvelle condition, effectue la simulation (et transforme la solution en dataframe).\n\nfunction int_tordeuse(x0, integrator)\n    reinit!(integrator, x0)\n\n    sol_tordeuse = solve!(integrator)\n    sol_tordeuse = DataFrame(sol_tordeuse)\n    rename!(sol_tordeuse, :timestamp =&gt; :time, :value =&gt; :x)\nend\n\nOn construit ensuite le graphique et on fait une boucle pour intégrer et tracer les résultats:\n\n# conditions initiales\nx0vec = x0step:x0step:K\n\n# custom color palette\ninit_cgrad = palette([:steelblue, :lightblue], length(x0vec))\n\n# initialisation du graphique, équilibre nul\nP = plot(palette = init_cgrad,\n         legend = :right, \n         label = \"équilibres instables\",\n         title = \"Tordeuse du bourgeon de l\\'épinette\",\n         ylabel = \"densité de population \\$x(t)\\$\", \n         xlabel = \"temps \\$t\\$\",\n         margin = .5Plots.cm,\n         topmargin = 1Plots.cm)\n\n# boucle de plot avec intégration pour differentes conditions initiales\nfor x0 in x0vec\n    plot!(P, int_tordeuse(x0, integrator).time, \n          int_tordeuse(x0, integrator).x,\n          linewidth = 2,\n          label = \"\")\nend\n\ndisplay(P)      # actually shows the plot P\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nOn peut compléter la figure comme vu précédemment.\n\n\nCode\n# on définit des couleurs spécifiques depuis la palette :pal10\nmygreen = palette(:tab10)[3]\nmyorange = palette(:tab10)[2]\nmyblue = palette(:tab10)[1]\nmyred = palette(:tab10)[4]\n\nusing Polynomials\n\n# définition du monôme X\nX = Polynomial([0, 1])\n\n# définition du polynôme \npol = r*(1-X/K)*(h^2 + X^2)-α*X*yc\n\n# calcul des racines, réelles, positives et plus petites que K\neq_pos = roots(pol)                         # calcul des racines\neq_pos = real.(eq_pos[isreal.(eq_pos)])     # filtrage des racines réelles\neq_pos = eq_pos[(eq_pos .&gt; 0) .& (eq_pos .&lt;= K)] # filtrage des racines &gt;0 et &lt;K\n\nt2plot = collect(tspan)\n\n# initialisation du graphique, équilibre nul\nplot!(P, t2plot, zeros(length(t2plot)), \n         lw=2, \n         linestyle = :dash, \n         color = myorange, \n         palette = init_cgrad,\n         legend = :right, \n         label =\"équilibres instables\",\n         ylabel = \"densité de population \\$x(t)\\$\", \n         xlabel = \"temps \\$t\\$\",\n         margin = .5Plots.cm,\n         topmargin = 1Plots.cm)\n\n# équilibres positifs\nif length(eq_pos) == 1\n    plot!(P, t2plot, ones(length(t2plot)).*eq_pos, \n          color = mygreen, \n          label =\"équilibre stable\")\nelseif length(eq_pos) == 3\n    plot!(P, t2plot, ones(length(t2plot)).*eq_pos[1], \n          lw=2, \n          linestyle = :dash, \n          color = mygreen, \n          label =\"équilibres stables\")\n    plot!(P, t2plot, ones(length(t2plot)).*eq_pos[2], \n          lw=2, \n          linestyle = :dash, \n          color = myorange, \n          label = \"\")\n    plot!(P, t2plot, ones(length(t2plot)).*eq_pos[3], \n          lw=2, \n          linestyle = :dash, \n          color = mygreen, \n          label = \"\")\nend\n\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 1: bistabilité dans le modèle de la tordeuse du bourgeon de l’épinette\n\n\n\n\n\nLe code de la fonction int_tordeuse est plus simple avec l’integrator interface qu’en redéfinissant le problème d’intégration à chaque fois. Néanmoins, sur un problème avec x0step= 0.1 (soit ~100 trajectoires calculées), le gain en temps de calcul de cette méthode est marginal : 123ms contre 128ms avec la méthode précédente. Le gain en mémoire est plus sensible : 4.28 mO contre 7,26 mO, mais finalement marginal aussi sur des machines modernes pour de si petits problèmes d’intégration."
  },
  {
    "objectID": "annexe_integrator.html#interface-integrator-pour-simulations-multiples",
    "href": "annexe_integrator.html#interface-integrator-pour-simulations-multiples",
    "title": "Simulations multiples",
    "section": "Interface Integrator pour simulations multiples",
    "text": "Interface Integrator pour simulations multiples\nLors de simulations multiples1, la stratégie choisie a été de redéfinir un nouveau problème d’intégration ODEProblem pour chaque condition initiale. Cette procédure est a priori peu efficace, et DifferentialEquations.jl permet de modifier un problème d’intégration via la Integrator Interface.1 par exemple pour plusieurs conditions initiales pour le modèle avec effets Allee ou celui de la tordeuse du bourgeon de l’épinette\nRépliquons la figure des dynamiques de la tordeuse du bourgeon de l’épinette avec cette méthode. On commence par définir les paramètres et le modèle:\n\n\nCode\nusing DifferentialEquations\nusing Plots\nusing DataFrames\n\n# paramètres\nr = 5.0      # natalité\nK = 10.0     # mortalité\nα = 1.0      # taux max de prédation\nh = 0.5      # constante de demi-saturation\nyc = 7.0     # densité de prédateurs\n\npar_tordeuse = [r, K, α, h, yc]\n\n# temps d'intégration\ntspan = (0.0, 3.0)\ntstep = 0.02\n\n# condition initale\nx0step = 1.35\n\n# modèle\nfunction tordeuse(u, p, t)\n    r, K, α, h, yc = p\n    x = u[1]\n    return dx = r*x*(1 - x/K) - α*x^2/(h^2 + x^2)*yc\nend\n\n\nNous définissons ensuite le problème d’intégration ainsi que l’intégrateur integrator:\n\nprob_tordeuse = ODEProblem(\n    tordeuse,         # modèle\n    x0step,           # condition initiale\n    tspan,            # tspan\n    par_tordeuse;     # paramètres\n    saveat = tstep,\n)   # option de sortie\n\nintegrator = init(prob_tordeuse, Tsit5())  # integrator requires integ algorithm\n\nPour une utilisation dans une boucle pour simuler les trajectoires depuis différentes conditions initiales, nous définissons une fonction qui réinitialise l’intégrateur à la nouvelle condition, effectue la simulation (et transforme la solution en dataframe).\n\nfunction int_tordeuse(x0, integrator)\n    reinit!(integrator, x0)             # la clef de l'interface est ici\n\n    sol_tordeuse = solve!(integrator)   # et là\n    sol_tordeuse = DataFrame(sol_tordeuse)\n    rename!(sol_tordeuse, :timestamp =&gt; :time, :value =&gt; :x)\n\n    return sol_tordeuse\nend\n\nOn construit ensuite le graphique et on fait une boucle pour intégrer et tracer les résultats:\n\n# conditions initiales\nx0vec = x0step:x0step:K\n\n# custom color palette\ninit_cgrad = palette([:steelblue, :lightblue], length(x0vec))\n\n# initialisation du graphique, équilibre nul\nfig = plot(;\n    palette = init_cgrad,\n    legend = :right,\n    label = \"équilibres instables\",\n    title = \"Tordeuse du bourgeon de l\\'épinette\",\n    ylabel = \"densité de population \\$x(t)\\$\",\n    xlabel = \"temps \\$t\\$\",\n    margin = .5Plots.cm,\n    topmargin = 1Plots.cm,\n)\n\n# boucle de plot avec intégration pour differentes conditions initiales\nfor x0 in x0vec\n    plot!(\n        fig,\n        int_tordeuse(x0, integrator).time,\n        int_tordeuse(x0, integrator).x,\n        linewidth = 2,\n        label = \"\",\n    )\nend\n\ndisplay(fig)      # actually shows the plot P\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nOn peut compléter la figure comme vu précédemment, mais cela n’a pas plus d’intéret ici.\n\nCommentaires\nLe code de la fonction int_tordeuse est plus simple avec l’integrator interface qu’en redéfinissant le problème d’intégration à chaque fois. Néanmoins, sur un problème avec x0step= 0.1 (soit ~100 trajectoires calculées), le gain en temps de calcul de cette méthode est marginal : 123 ms contre 128 ms avec la méthode précédente (test avec package BenchmarkTools.jl).\nLe gain en mémoire est plus sensible : 4.28 MiB contre 7.26 MiB, mais finalement marginal aussi sur des machines modernes pour de si petits problèmes d’intégration.\n\n\nRedéfinition du problème d’intégration via remake\nUne autre approche plutôt que de redéfinir un nouveau problème d’intégration à chaque fois, est de modifier le problème d’intégration via la fonction remake.\nOn définit une fonction qui prend pour arguments la condition initiale et un problème d’intégration, et redéfinit le problème d’intégration depuis cette condition initiale :\n\nfunction int_tordeuse2(x0, prob)\n    prob = remake(prob, u0 = x0)       # redéfinition du problème d'intégration\n\n    sol_tordeuse = solve(prob)\n    sol_tordeuse = DataFrame(sol_tordeuse)\n    rename!(sol_tordeuse, :timestamp =&gt; :time, :value =&gt; :x)\nend\n\n# initialisation du graphique\nfig2 = plot(;\n    palette = init_cgrad,\n    legend = :right,\n    label = \"équilibres instables\",\n    title = \"Tordeuse du bourgeon de l\\'épinette\",\n    ylabel = \"densité de population \\$x(t)\\$\",\n    xlabel = \"temps \\$t\\$\",\n    margin = .5Plots.cm,\n    topmargin = 1Plots.cm,\n)\n\nfor x0 in x0vec\n    plot!(\n        fig2,\n        int_tordeuse2(x0, prob_tordeuse).time,\n        int_tordeuse2(x0, prob_tordeuse).x;\n        linewidth = 2,\n        label = \"\",\n    )\nend\n\ndisplay(fig2)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCette méthode est plus rapide que la redéfinition de problème d’intégration ou l’utilisation de l’integrator interface (113 ms dans les conditions vues plus haut) et intermédiaire en termes de mémoire utilisée (6.39 MiB). Le code est aussi simple que pour l’integrator interface.\nPar ailleurs la même approche via remake peut être utilisée pour redéfinir un problème d’intégration en modifiant les paramètres plutôt que la condition initiale, par exemple pour calculer un diagramme de bifurcations par force brute comme pour le modèle de Rosenzweig MacArthur. C’est visiblement la bonne solution algorithmique."
  },
  {
    "objectID": "pop_interactions2.html#bifurcation-diagram-plot",
    "href": "pop_interactions2.html#bifurcation-diagram-plot",
    "title": "Populations en interaction (2)",
    "section": "Bifurcation diagram: plot",
    "text": "Bifurcation diagram: plot\n\n\nCode\nlines!(ax31, K_plot3, y_cmin,\n       color = Cycled(3),\n       linewidth = 2,\n       label = L\"cycle limite$$\")\n\nlines!(ax31, K_plot3, y_cmax,\n       color = Cycled(3),\n       linewidth = 2)\n\n\naxislegend(ax31, position = :lt, labelsize = 14)\n\nfig3"
  },
  {
    "objectID": "pop_interactions2.html#diagramme-de-bifurcation-final",
    "href": "pop_interactions2.html#diagramme-de-bifurcation-final",
    "title": "Populations en interaction (2)",
    "section": "Diagramme de bifurcation final",
    "text": "Diagramme de bifurcation final\nFinalement, on inclut les branches calculées dans le diagramme de bifurcations.\n\n\nCode\nlines!(ax31, K_plot3, y_cmin,\n       color = Cycled(3),\n       linewidth = 2,\n       label = L\"cycle limite$$\")\n\nlines!(ax31, K_plot3, y_cmax,\n       color = Cycled(3),\n       linewidth = 2)\n\n\naxislegend(ax31, position = :lt, labelsize = 14)\n\nfig3\n\n\n\n\n\nFigure 3: Diagramme de bifurcations du modèle de Rosenzweig MacArthur."
  },
  {
    "objectID": "index.html#installation-de-julia",
    "href": "index.html#installation-de-julia",
    "title": "Introduction",
    "section": "Installation de Julia",
    "text": "Installation de Julia\nLa façon la plus simple d’installer Julia est d’utiliser juliaup.\nSur Linux, installez curl sur votre système1. Puis dans un terminal :1 sudo apt install curl sur Ubuntu\n\ncurl -fsSL https://install.julialang.org | sh\n\net procédez à l’installation.\nFermez et réouvrez votre terminal (ou rechargez votre fichier de préférences comme vous l’indique l’installateur de juliaup) pour pouvoir exécuter Julia.\nPuis, si vous souhaitez utiliser Julia dans un notebook jupyter, installez le package IJulia depuis Julia comme suit2:2 si le profil est tout nouvellement, créé un redémarrage peut s’avérer nécessaire si vous rencontrez une erreur à l’exécution de jupyterlab() ci-dessous\n\njulia # executer julia dans un terminal\n   _       _ _(_)_     |  Documentation: https://docs.julialang.org\n  (_)     | (_) (_)    |\n   _ _   _| |_  __ _   |  Type \"?\" for help, \"]?\" for Pkg help.\n  | | | | | | |/ _` |  |\n  | | |_| | | | (_| |  |  Version 1.10.0 (2023-12-25)\n _/ |\\__'_|_|_|\\__'_|  |  Official https://julialang.org/ release\n|__/                   |\n\njulia&gt; ]  # package mode\n(@v1.10) pkg&gt; add IJulia\n(@v1.10) pkg&gt; build IJulia\n\nLa première commande add IJulia peut prendre un peu de temps.\nSi vous avez déjà jupyterlab installé, un noyau Julia est ensuite disponible. Sinon vous pouvez l’installer et le démarrer directement depuis Julia :\n\njulia&gt; using IJulia # tapez backspace d'abord\n                    # pour sortir du package mode\njulia&gt; jupyterlab()\n\n\n\nJulia vous propose alors d’installer jupyterlab via miniconda, ce que vous accepterez, et démarre ensuite jupyterlab dans votre navigateur.\n\nUne extension Julia est par ailleurs disponible pour VScode/VScodium, un environnement de développement que je vous conseille et qui permet d’éditer les notebooks jupyter en dehors du navigateur."
  },
  {
    "objectID": "annexe_LV_makieplot.html",
    "href": "annexe_LV_makieplot.html",
    "title": "Lotka Volterra avec Makie.jl",
    "section": "",
    "text": "L’objectif ici est de faire une jolie représentation graphique du modèle de Lotka Volterra avec la librairie graphique Makie.jl.\nOn reprend une partie du code de la page sur les populations en intéractions.\n\n\nCode\nusing DifferentialEquations\n\n# conditions initiales\nx0 = 1.0\ny0 = 2.3\netat0 = [x0, y0]\n\n# paramètres\nr = 1.0\nc = 1.0\nb = 1.0\nm = 1.0\npar_lovo = [r, c, b, m]\n\n# integration plus longue\ntspan = (0.0, 30.0)\ntstep = .01\n\n# définition du modèle\nfunction lovo(u, par, t)\n    r, c, b, m = par\n    x = u[1]\n    y = u[2]\n    dx = r*x - c*x*y\n    dy = b*x*y - m*y\n    [dx, dy]\nend\n\n# problème\nprob_lovo = ODEProblem(lovo, etat0, tspan, par_lovo; saveat = tstep)\n# intégration\nsol_lovo = solve(prob_lovo; reltol = 1e-6)\n\n\nL’objectif est de créer une figure avec trois panels. dans la colonne de gauche, le premier panel représentera la dynamique temporelle, le second le plan de phase, et dans la colonne de droite nous représenterons la figure 3D avec l’intégrale première.\n\nusing CairoMakie\n\n# on crée la figure avec un fond gris clair\nfig = Figure(\n       backgroundcolor = RGBf(0.98, 0.98, 0.98),\n       size = (1000, 600),\n)\n\n# déclare les différents panels comme des éléments gridlayout contenant les plots\npanela = fig[1, 1] = GridLayout()\npanelb = fig[2, 1] = GridLayout()\npanelc = fig[:, 2] = GridLayout()\n\nOn commence par remplir le premier panel avec les dynamiques :\n\nax1 = Axis(\n       panela[1,1],\n       ylabel = L\"densités de populations$$\",\n       title=\"Dynamiques\",\n)\n\n# pour avoir un xlabel plus proche de l'axe on le définit séparément en réglant manuellement l'espacement/padding\nLabel(panela[1,1,Bottom()], L\"temps$$\"; padding=(0,0,0,20))\n\n# dynamiques de populations\nlines!(ax1, sol_lovo.t, sol_lovo[1,:]; linewidth = 2, label = L\"$x(t)$\")\n\nlines!(ax1, sol_lovo.t, sol_lovo[2,:]; linewidth = 2, label = L\"$y(t)$\")\n\n# légende avec quelques ajustements d'espacement interne\naxislegend(ax1; position = :lt, labelsize = 12, padding = (5,5,0,0), rowgap = -5)\n\nfig\n\n\n\n\nPuis on complète le second panel avec le plan de phase :\n\nax2 = Axis(\n       panelb[1,1];\n       xlabel = L\"population $x$\",\n       ylabel = L\"population $y$\",\n       title = \"Plan de phase\",\n       xticks = (0:.5:2),\n       yticks = (0:.5:2),\n)\n\n# champs de vecteur\nscale = 10\nxrange = range(0, 2.75, length=11)\nyrange = range(0, 2.75, length=11)\n\nderx = [lovo([x y], par_lovo, 0)[1]/scale for x in xrange, y in yrange]\ndery = [lovo([x y], par_lovo, 0)[2]/scale for x in xrange, y in yrange]\n\narrows!(ax2, xrange, yrange, derx, dery; color = :lightgray, arrowsize = 10)\n\n# nullclines\nlines!(\n    ax2,\n    xrange,\n    [r/c for x in xrange];\n    color = Cycled(2),\n    linewidth = 2,\n    label = L\"$\\dot{x}$ nullcline\",\n)\n\nlines!(ax2, [0 for y in yrange], yrange; linewidth = 2, color = Cycled(2))\n\nlines!(\n    ax2,\n    [m/b for y in yrange],\n    yrange;\n    color = Cycled(3),\n    linewidth = 2,\n    label = L\"$\\dot{y}$ nullcline\",\n)\n\nlines!(ax2, xrange, [0 for y in yrange]; color = Cycled(3), linewidth = 2)\n\n# équilibres\nscatter!(ax2, Point2f(0,0); color = Cycled(4))\nscatter!(ax2, Point2f(m/b, r/c); color = Cycled(4))\n\n# trajectoire\nlines!(ax2, sol_lovo[1, :], sol_lovo[2, :], color = Cycled(1), linewidth = 2)\n\nxlims!(ax2, -0.1, 2.75)\nylims!(ax2, -0.1, 2.75)\n\naxislegend(ax2; position = :rt, labelsize = 12, padding = (5,5,0,0), rowgap = -5)\n\nfig\n\n\n\n\nFinalement on complète le troisième panel avec la représentation 3D, en commencant par redéfinir l’intégrale première\n\n# l'intégrale première\nfunction int_prem(x, y, par = par_lovo)\n      r, c, b, m = par\n      return -r*log(y) + c*y - m*log(x) + b*x\nend\n\n\n# système d'axe 3D en première colonne de panel c, avec réglage de la caméra\nax3 = Axis3(\n       panelc[1, 1];\n       title = \"Intégrale première\",\n       titlegap = -50,\n       xlabel = L\"population $x$\",\n       ylabel = L\"population $y$\",\n       zlabel = L\"$H(x,y)$\",\n       azimuth = 0.5,\n       elevation = 0.2,\n)\n\n# grille x, y\nxsurf = 0.2:0.1:3.0\nysurf = 0.2:0.1:3.0\n\n# calcul de la surface via une compréhension de liste\nhsurf = [int_prem(x, y, par_lovo) for x in xsurf, y in ysurf]\nhplane = [int_prem(x0, y0, par_lovo) for x in xsurf, y in ysurf]\n\n# tracé de H(x,y) et du plan z = H(x0,y0)\nhs = surface!(ax3, xsurf, ysurf, hsurf; alpha=.5)\nsurface!(ax3, xsurf, ysurf, hplane; color = fill(:red, 100, 100), alpha = .3)\n\n# ajout de la trajectoire simulée\nlines!(\n    ax3,\n    sol_lovo[1,:],\n    sol_lovo[2,:],\n    [int_prem(x0, y0, par_lovo) for x in sol_lovo[1,:]];\n    color = Cycled(4),\n    linewidth = 3,\n)\n\n# ajout d'une colorbar reprise sur le plot de H(x,y) avec une hauteur relative sur la colonne\n# la colorbar est en 2e colonne du panelc\nColorbar(panelc[1, 2], hs, height = Relative(.55))\n\n# colonne 2 plus large\ncolsize!(fig.layout, 2, Auto(1.5))\n# modification des espacements entre lignes et colonnes\ncolgap!(fig.layout, 60)\ncolgap!(panelc, -10)\nrowgap!(fig.layout, 10)\n\n# titre général en ligne 0\nsupertitle = Label(fig[0, :], \"Modèle de Lotka Volterra\", fontsize = 30)\n\nfig\n\n\n\n\nFigure 1: Figure illustrant le comportement du modèle de Lotka Volterra\n\n\n\n\net voilà !\n\n\n\n\n\nReusehttps://creativecommons.org/licenses/by-nc/4.0/"
  },
  {
    "objectID": "annexe_LV_makieplot.html#lotka-volterra-avec-makie.jl",
    "href": "annexe_LV_makieplot.html#lotka-volterra-avec-makie.jl",
    "title": "Matériel supplémentaire",
    "section": "",
    "text": "Juste une jolie représentation graphique du modèle de Lotka Volterra avec la librairie graphique Makie.jl."
  },
  {
    "objectID": "annexe_FisherKPP.html",
    "href": "annexe_FisherKPP.html",
    "title": "Fisher KPP with Julia",
    "section": "",
    "text": "This implementation of numerical solve of a reaction diffusion equation is based on the presentation of the package MethodOfLines.jl at JuliaCon 2022 by A. Jones."
  },
  {
    "objectID": "annexe_FisherKPP.html#fisher-kpp-equation",
    "href": "annexe_FisherKPP.html#fisher-kpp-equation",
    "title": "Fisher KPP with Julia",
    "section": "Fisher KPP equation",
    "text": "Fisher KPP equation\nThe Fisher KPP equation (Fisher’s version) reads (Fisher (1937), Kolmogorov, Petrovskii, and Piskunov (1937)):\n\n\\frac{\\partial u}{\\partial t} = ru\\left(1-u\\right) + D \\frac{\\partial^2 u}{\\partial x^2},\n\nwith u(t,x) the population density at time t and position x (scaled to the local carrying capacity K), r the intrinsic growth rate of the population, and D the diffusion coefficient."
  },
  {
    "objectID": "annexe_FisherKPP.html#packages",
    "href": "annexe_FisherKPP.html#packages",
    "title": "Fisher KPP with Julia",
    "section": "Packages",
    "text": "Packages\nLet us first import the packages used for the simulation:\n\nusing MethodOfLines\nusing ModelingToolkit\nusing DomainSets\nusing OrdinaryDiffEq\nusing Plots\nusing LaTeXStrings"
  },
  {
    "objectID": "annexe_FisherKPP.html#model-definition",
    "href": "annexe_FisherKPP.html#model-definition",
    "title": "Fisher KPP with Julia",
    "section": "Model definition",
    "text": "Model definition\nMethodsOfLines.jl makes use of ModelingToolkit.jl to symbolically define the model to integrate.\nLet us first define the time and space parameters:\n\n@parameters t x\n\nThe model parameters:\n\n@parameters r D\n\nNow the variable u(t,x):\n\n@variables u(..)\n\nAnd finally the derivatives:\n\nDt = Differential(t)\nDx = Differential(x)\nDxx = Differential(x)^2\n\nWe can now define the model symbolically through:\n\neq = Dt(u(t, x)) ~ r * u(t,x) * (1-u(t,x)) + D * Dxx(u(t,x))\n\n \\begin{equation}\n\\frac{\\mathrm{d}}{\\mathrm{d}t} u\\left( t, x \\right) = D \\frac{\\mathrm{d}}{\\mathrm{d}x} \\frac{\\mathrm{d}}{\\mathrm{d}x} u\\left( t, x \\right) + r u\\left( t, x \\right) \\left( 1 - u\\left( t, x \\right) \\right)\n\\end{equation}"
  },
  {
    "objectID": "annexe_FisherKPP.html#domains-of-integration",
    "href": "annexe_FisherKPP.html#domains-of-integration",
    "title": "Fisher KPP with Julia",
    "section": "Domains of integration",
    "text": "Domains of integration\nLet us introduce some parameters for space and time domains:\n\nx_max = 30.0\nt_max = 14.0\n\nAnd the domains of integration:\n\ndomain = [x ∈ Interval(0.0, x_max),\n          t ∈ Interval(0.0, t_max)]\n\nWe also introduce (initial and) boundary conditions:\n\nic_bc = [u(0.0, x) ~ 0.0,\n         u(t, 0.0) ~ 1.0,\n         u(t, x_max) ~ 0.0]"
  },
  {
    "objectID": "annexe_FisherKPP.html#simulation",
    "href": "annexe_FisherKPP.html#simulation",
    "title": "Fisher KPP with Julia",
    "section": "Simulation",
    "text": "Simulation\nWe define the model to be integrated as a PDESystem, from the equation eq, the initial and boundary conditions ic_bc, the domains of integration domain, the time and space parameters t and x, the solution we want to retrieve u(t,x), and the model parameters r and D:\n\n@named sys = PDESystem(eq, ic_bc, domain, [t, x], [u(t,x)], [r =&gt; 1.0, D =&gt; 1.0])\n\nWe set up the discretization of space, through MethodOfLines.jl:\n\ndx = 0.1\ndiscretization = MOLFiniteDifference([x =&gt; dx], t)\n\nAnd we set up the (ODE) problem to be integrated:\n\nprob = discretize(sys, discretization)\n\nAnd we finally integrate it through the OrdinaryDiffEq.jl solver with Tsit5 algorithm.\n\nsol = solve(prob, Tsit5(), saveat = .1)"
  },
  {
    "objectID": "annexe_FisherKPP.html#graphical-representation",
    "href": "annexe_FisherKPP.html#graphical-representation",
    "title": "Fisher KPP with Julia",
    "section": "Graphical representation",
    "text": "Graphical representation\nWe retrieve the components of the solution for easier manipulation:\n\ngridx = sol[x]\ngridt = sol[t]\nsolu = sol[u(t,x)]\n\nAnd we plot the animation of the solution through time:\n\nanim = @animate for i in eachindex(gridt)\n    plot(\n        gridx,\n        solu[i, :];\n        xlabel = \"position \"*L\"$x$\",\n        ylabel = \"population density \"*L\"$u$\",\n        label = L\"$u(x,t)$\",\n        title = \"t=$(gridt[i])\",\n    )\nend\n\ngif(anim, \"fisherKPP.gif\", fps = 10)\n\n\n\n\nAnd that’s it !"
  },
  {
    "objectID": "annexes.html",
    "href": "annexes.html",
    "title": "Matériel supplémentaire",
    "section": "",
    "text": "Les pages listées ici contiennent du matétiel supplémentaire pour compléments plus avancés :\n\naméliorer la rapidité d’exécution des simulations en utilisant au maximum la définition de struct et de function\ntracer une jolie figure pour Lotka Volterra avec Makie.jl\nutiliser l’interface integrator de DifferentialEquations.jl ou la redéfinition de problèmes d’intégration via remake\nréaliser des graphiques animés avec Makie.jl, un exemple sur Lotka Volterra\nsimuler une équation de réaction-diffusion en une dimension : le modèle de Fisher-KPP\n\nNous n’avons qu’effleuré l’utilisation de Julia, par exemple tout le code présenté est scripté et relativement peu de code est inclus dans des fonctions. Nous n’avons pas non plus abordé les types struct et le multiple dispatch qui sont pourtant au coeur du fonctionnement, de l’efficacité, et de la versatilité de ce langage.\nPour aller plus loin (et aussi revoir quelques bases !), vous pouvez par exemple vous référer à ces tutoriels:\n\nle cours Introduction to computational thinking du MIT (assez long)\nle workshop Julia Zero-to-Hero de Georges Datseris (plus direct)\n\n\n\n\n\n\nReusehttps://creativecommons.org/licenses/by-nc/4.0/"
  },
  {
    "objectID": "annexe_LV_anim.html",
    "href": "annexe_LV_anim.html",
    "title": "Graphiques animés avec Makie.jl",
    "section": "",
    "text": "Nous reprenons le modèle de Lotka Volterra, et testons les capacités de création de graphiques animés avec Makie.jl1. Ce document est largement inspiré par l’excellent tutoriel sur le double pendule chaotique par G. Datseris.1 Il est aussi possible de créér sur le même modèle des graphiques interactifs"
  },
  {
    "objectID": "annexe_LV_anim.html#trajectoire-animée-en-2d",
    "href": "annexe_LV_anim.html#trajectoire-animée-en-2d",
    "title": "Graphiques animés avec Makie.jl",
    "section": "Trajectoire animée en 2D",
    "text": "Trajectoire animée en 2D\n\nObservables\nLe principe tire partie des conteneurs Observable, qui sont des conteneurs mutables que l’on peut donc modifier et dont on peut surveiller l’évènement de modification. Lorsqu’un Observable passé à Makie.jl est modifié, ce dernier le prend en compte et met à jour le graphique correspondant automatiquement. Cela fonctionne particulièrement bien avec le backend GL, qui depuis un script ou un notebook ouvre une fenetre graphique qui se met à jour automatiquement. Sur cette page, il nous faut réafficher la figure.\nPrenons un exemple, sur une simple figure, on définit un Observable random puis on le trace:\n\nusing GLMakie\n\nx = 1:4\ny = Observable(rand(4))\nfig, ax = lines(x, y)\n\n\n\n\nEnsuite on réassigne la valeur de l’observable et on réaffiche la figure qui s’est mise à jour automatiquement, sans retracer la line.\n\n\n\n\n\n\nNote\n\n\n\nOn utilise la syntaxe y[]= qui assigne le contenu de l’observable et informe le système de la mise à jour de l’observable.\n\n\n\ny[] = rand(4)\nfig\n\n\n\n\nIl s’agit d’exploiter ce principe pour créér un graphique animé.\n\n\nTrajectoire de Lotka Volterra\nNous allons représenter la trajectoire au cours du temps comme un point mobile dans l’espace d’état, avec une “queue” qui représente les valeurs de l’état dans le passé proche, comme ceci: \nOn commence par définir les fonctions et paramètres pour simuler le modèle et créer un problème ODE prob_lv.\n\n\nCode\nusing DifferentialEquations\n\n# conditions initiales\nx0 = 1.0\ny0 = 1.95\netat0 = [x0, y0]\n\n# paramètres\nr = 1.0\nc = 1.0\nb = 1.0\nm = 1.0\npar_lovo = [r, c, b, m]\n\n# temps\ntspan = (0.0, 30.0)\ntstep = .01\n\n# définition du modèle\nfunction lovo(u, par, t)\n    r, c, b, m = par\n    x, y = u\n    dx = r*x - c*x*y\n    dy = b*x*y - m*y\n    return [dx, dy]\nend\n\n# define ODE problem\nprob_lv = ODEProblem(lovo, etat0, tspan, par_lovo)\n\n\nNous créons des observables pour l’état et pour la queue de simulation sous la forme d’objets de type Point2f (ou CircularBuffer de Point2f) pour les passer à Makie.\n\n\n\n\n\n\nNote\n\n\n\n\nles objets de type Point2f sont la structure la plus efficace pour tracer des points en 2D pour Makie\nun objet CircularBuffer est un vecteur de taille fixe qu’on remplit par la fin via push!() et qui se vide automatiquement par le début pour garder sa taille\n\n\n\n\n# observable pour l'état\nx, y = etat0\nstate_lv = Observable(Point2f(x, y))     # initialisation\n\n# observable pour la queue\nusing DataStructures: CircularBuffer\n\ntailsize = 600\ntail = CircularBuffer{Point2f}(tailsize)    # une queue de simulation\nfill!(tail, Point2f(x, y))      # que l'on initialize sur la condition initiale\ntail = Observable(tail)         # et que l'on transforme en Observable\n\nL’animation repose sur une simulation de proche en proche pour pouvoir créer l’animation. Pour cela nous utilisons l’interface integrator de DifferentialEquations.jl et la fonction step!(integrator) qui calcule la solution au bout d’un pas de temps (en place). Nous créons une fonction qui effectue ce calcul et met à jour les Observables état (state_lv) et queue (tail) (en place !).\n\nintegrator_lv = init(prob_lv, Tsit5())    # interface integrator\n\nfunction step_lv!(integrator, state_lv, tail)\n    # calcule la solution a t+0.01, en place\n    step!(integrator, 0.01,  true)\n    # assigne la solution à x et y\n    x, y = integrator.u\n\n    # met à jout les\n    state_lv[] = Point2f(x, y)        # met à jour l'Observable\n    push!(tail[], Point2f(x,y))      # assigne la nouvelle valeur dans la queue, en place\n    tail[] = tail[]                  # le push en place n'indique pas la mise à jour de l'Observable\nend\n\nIl faut maintenant définir la figure en elle-même: on trace une position de l’état et de la queue (à ce stade sur la condition initiale):\n\n# Création de Figure, Axis\nfig = Figure()\nax = Axis(fig[1, 1]; xticks = 0:0.5:2, yticks = 0:0.5:2)\n\n# champs de vecteur\nscale = 10\nxrange = range(0, 2.75, length=11)\nyrange = range(0, 2.75, length=11)\n\n# calcule des dérivées sur la grille (xrange, yrange)\nderx = [lovo([x y], par_lovo, 0)[1]/scale for x in xrange, y in yrange]\ndery = [lovo([x y], par_lovo, 0)[2]/scale for x in xrange, y in yrange]\n\n# champs de vecteur\narrows!(\n    ax,\n    xrange,\n    yrange,\n    derx,\n    dery;\n    color = :lightgray,\n    arrowsize = 10,\n)\n\n# positive equilibrium\nscatter!(ax, m/b, r/c; marker = :star, color = :grey, markersize = 14)\n\n# plot of the state\nscatter!(\n    ax,\n    state_lv;\n    marker = :circle,\n    strokewidth = 2,\n    strokecolor = :purple,\n    color = :black,\n    markersize = 8,\n)\n\n# plot of the tail\n# echelle de couleur pour la queue: 100% transparent au purple via parametre alpha\ncol = to_color(:purple)\ntailcol = [RGBAf(col.r, col.g, col.b, (i/tailsize)^2) for i in 1:tailsize]\nlines!(ax, tail; linewidth = 3, color = tailcol)\n\n# enluminures\nax.title = \"Lotka Volterra\"\nax.xlabel = \"Proies\"\nax.ylabel = \"Prédateurs\"\nxlims!(ax, 0, 2.25)\nylims!(ax, 0, 2.25)\n\nfig\n\n\n\n\nPuis on intègre de proche en proche via stepl_lv! :\n\n# test the 2D plot\nfor in in 1:1000\n    step_lv!(integrator_lv, state_lv, tail)\n    sleep(.001)\nend\n\nDepuis un script ou un notebook, la figure proposée par GLMakie devrait s’animer. Sur cette page html, nous ne pouvons qu’afficher la dernière simulation :\n\nfig\n\n\n\n\n\n\nImage animée pour site\nIl faut en fait générer une image animée (typiquement .gif) pour pouvoir visualiser l’animation sur cette page.\nOn peut commencer par réunir tout le code d’initialisation et de génération de figure dans une fonction, pour facilement réinitialiser:\n\nfunction init_anim_lv(etat0, params)\n    # Odeproblem, integrator\n    prob_lv = ODEProblem(lovo, etat0, tspan, params)\n    integrator_lv = init(prob_lv, Tsit5())\n\n    # condition initiale, observables etat et queue\n    x, y = etat0\n    state_lv = Observable(Point2f(x, y))\n    tailsize = 600\n    tail = CircularBuffer{Point2f}(tailsize)\n    fill!(tail, Point2f(x, y))\n    tail = Observable(tail)\n\n    # figure\n    fig = Figure()\n    ax = Axis(fig[1, 1]; xticks = 0:0.5:2, yticks = 0:0.5:2)\n    scale = 10\n\n    xrange = range(0, 2.75, length=11)\n    yrange = range(0, 2.75, length=11)\n    derx = [lovo([x y], params, 0)[1]/scale for x in xrange, y in yrange]\n    dery = [lovo([x y], params, 0)[2]/scale for x in xrange, y in yrange]\n\n    arrows!(\n        ax,\n        xrange,\n        yrange,\n        derx,\n        dery;\n        color = :lightgray,\n        arrowsize = 10,\n    )\n\n    r, c, b, m = params\n    scatter!(ax, m/b, r/c; marker = :star, color = :grey, markersize = 14)\n\n    scatter!(\n        ax,\n        state_lv;\n        marker = :circle,\n        strokewidth = 2,\n        strokecolor = :purple,\n        color = :black,\n        markersize = 8,\n    )\n\n    col = to_color(:purple)\n    tailcol = [RGBAf(col.r, col.g, col.b, (i/tailsize)^2) for i in 1:tailsize]\n    lines!(ax, tail, linewidth = 3, color = tailcol)\n\n    ax.title = \"Lotka Volterra\"\n    ax.xlabel = \"Proies\"\n    ax.ylabel = \"Prédateurs\"\n    xlims!(ax, 0, 2.25)\n    ylims!(ax, 0, 2.25)\n\n    return fig, integrator_lv, state_lv, tail\nend\n\nNous générons la figure animée sous forme d’un gif en utilisant record :\n\n# on crée la figure\nfig, integrator_lv, state_lv, tail = init_anim_lv(etat0, par_lovo)\n\n# on veut 132 images pour l'animation\nframes = 1:132\n# record enregistre la figure fig à chaque fois en itérant frames\n## do i ... end passe une fonction anonyme en premier argument à record() qui crée les images\n## la boucle for sert juste à renvoyer l'image tous les 5 steps\nrecord(fig, \"lv.gif\", frames; framerate = 60) do i\n    for j in 1:5\n        step_lv!(integrator_lv, state_lv, tail)\n    end\nend\n\nEt finalement nous pouvons afficher la figure animée:"
  },
  {
    "objectID": "annexe_LV_anim.html#trajectoire-animée-en-3d",
    "href": "annexe_LV_anim.html#trajectoire-animée-en-3d",
    "title": "Graphiques animés avec Makie.jl",
    "section": "Trajectoire animée en 3D",
    "text": "Trajectoire animée en 3D\nAu prix d’une modification très minime du code ci-dessus, on peut facilement créér une animation de la trajectoire en 3 dimensions (x, y, H(x,y)). Il faut essentiellement remplacer le système d’axe 2D par un système d’axe 3D Axis3 et les objets Point2f par des Point3f.\n\n\nCode\n# on définit l'intégrale première\nfunction int_prem(x, y, par = par_lovo)\n    r, c, b, m = par\n    H = -r*log(y) + c*y - m*log(x) + b*x\n    return H\nend\n\nfunction init_anim3d_lv(etat0, params)\n    # Odeproblem, integrator\n    prob_lv = ODEProblem(lovo, etat0, tspan, params)\n    integrator_lv = init(prob_lv, Tsit5())\n\n    x, y = etat0\n    H0 = int_prem(x, y)\n    state3d_lv = Observable(Point3f(x, y, H0))\n    tailsize = 1000\n    tail3 = CircularBuffer{Point3f}(tailsize)\n    fill!(tail3, Point3f(x, y, H0))\n    tail3 = Observable(tail3)\n\n    fig = Figure()\n    ax = Axis3(\n        fig[1, 1];\n        azimuth = 0.5,\n        elevation = 0.2,\n        xticks = 0:0.5:2,\n        yticks = 0:0.5:2,\n    )\n\n    scatter!(\n        ax,\n        state3d_lv;\n        marker = :circle,\n        strokewidth = 2,\n        strokecolor = :purple,\n        color = :black,\n        markersize = 8,\n    )\n\n    col = to_color(:purple)\n    tailcol = [RGBAf(col.r, col.g, col.b, (i/tailsize)^2) for i in 1:tailsize]\n    lines!(ax, tail3; linewidth = 3, color = tailcol)\n\n    xsurf = 0.25:0.1:2.25\n    ysurf = 0.25:0.1:2.25\n    # calcul de la surface via une compréhension de liste\n    hsurf = [int_prem(x, y, params) for x in xsurf, y in ysurf]\n    # tracé de H(x,y) et du plan z = H(x0,y0)\n    hs = surface!(ax, xsurf, ysurf, hsurf; alpha = 0.2)\n\n    ax.title = \"Lotka Volterra\"\n    ax.xlabel = \"Proies\"\n    ax.ylabel = \"Prédateurs\"\n    ax.zlabel = L\"$H(x,y)$\"\n    xlims!(ax, 0, 2.25)\n    ylims!(ax, 0, 2.25)\n    zlims!(ax, 1.7, 3.5)\n\n    return fig, integrator_lv, state3d_lv, tail3\nend\n\n\nOn adapte la fonction d’animation qui avance d’un pas de temps à la nouvelle structure des observables en 3D.\n\nfunction animsteplv3!(integrator_lv, state3d_lv, tail3)\n    step!(integrator_lv, 0.01,  true)\n    x, y = integrator_lv.u\n    # comme H(x,y) ne varie pas, on ne change pas sa valeur\n    state3d_lv[] = Point3f(x, y, state3d_lv[][3])\n    push!(tail3[], Point3f(x, y, state3d_lv[][3]))\n    tail3[] = tail3[]\nend\n\nEt on génère une figure gif pour afficher sur cette page.\n\n#! output: true\nfig, integrator_lv, state3d_lv, tail3 = init_anim3d_lv(etat0, par_lovo)\n\nframes = 1:132\nrecord(fig, \"lv3d.gif\", frames; framerate = 60) do i\n    for j in 1:5\n        animsteplv3!(integrator_lv, state3d_lv, tail3)\n    end\nend\n\nFinalement:"
  },
  {
    "objectID": "index.html#packages-utilisés",
    "href": "index.html#packages-utilisés",
    "title": "Introduction",
    "section": "Packages utilisés",
    "text": "Packages utilisés\nNous allons utiliser différents package que je vous invite à installer avant de commencer (il est toujours possible de le faire en cours de route, mais cela peut prendre un certain temps selon la connexion internet et la machine).\nPour cela, il faut lancer Julia, entrer dans le package mode en appuyant sur la touche ], puis installer les package via add PackageName:\n\njulia&gt; ]   # package mode\n(@v1.10) pkg&gt; add Plots\n(@v1.10) pkg&gt; add DifferentialEquations\n(@v1.10) pkg&gt; add Dataframes\n(@v1.10) pkg&gt; add Polynomials\n(@v1.10) pkg&gt; add Symbolics\n(@v1.10) pkg&gt; add CairoMakie"
  },
  {
    "objectID": "annexe_swft_rma.html",
    "href": "annexe_swft_rma.html",
    "title": "Simulation optimisée",
    "section": "",
    "text": "Nous considérons le modèle de dynamique de populations de Rosenzweig et MacArthur que nous avons déjà vu (Rosenzweig and MacArthur (1963), Turchin (2003), Smith (2008)).\n\n\\left\\{\\begin{array}{l}\n\\dot x = \\displaystyle rx\\left(1-\\frac{x}{K}\\right) - c \\frac{x}{h+x} y\\\\[.3cm]\n\\dot y = b\\displaystyle \\frac{x}{h+x} y - m y\n\\end{array}\\right.\n\\tag{1}\nL’objectif est de réaliser des simulations performantes, et le tracé du diagramme de bifurcation avec l’estimation par simulation du cycle limite. Ce type de simulations lourdes se prête bien à se genre de benchmark.\n\n\nPour un tel problème de dimension réduite, nous allons utiliser des static arrays (tableaux à adresse fixe dans la mémoire1), ce qui permettra de ne pas crééer une multitude d’objets pour la simulation mais de toujours modifier le même objet en mémoire.1 depuis le package StaticArrays.jl\nPar ailleurs nous allons essayer de nous conformer au maximum aux préconisations :\n\nne pas utiliser de variables globales\ndéfinir des fonctions\nmettre les paramètres dans un nombre limité de variables et les passer en arguments des fonctions\n\nPour ce dernier point, nous allons définir des types (struct) spécifiques.\nNous commençons par importer les packages que nous allons utiliser:\n\nusing StaticArrays\nusing DifferentialEquations\nusing CairoMakie\n\n\n\n\nNous définissons un struct pour les paramètres du modèle de Rosenzweig MacArthur.\nType pour les paramètres :\n\n@kwdef struct ParRma\n    r::Number = 1.0\n    K::Number = 10.0\n    c::Number = 1.0\n    h::Number = 2.0\n    b::Number = 2.0\n    m::Number = 1.0\nend\n\n\n\n\n\n\n\nNote\n\n\n\nLa macro @kwdef permet de renseigner des valeurs par défaut des champs du struct.\n\n\nOn peut créer des objets de type ParRma via les constructor ; on accède à un champ particulier via objet.champ :\n\np_rma = ParRma() # constructor with default values\np_rma2 = ParRma(K = 8.0) # default values except K = 20.0\n\n@show p_rma\n@show p_rma.K\n@show p_rma2.K; # semi colon do not show output of par_rma2.K\n\np_rma = ParRma(1.0, 10.0, 1.0, 2.0, 2.0, 1.0)\np_rma.K = 10.0\np_rma2.K = 8.0\n\n\n\n\n\n\n\n\nNote\n\n\n\nLa macro @show est assez explicite.\n\n\n\n\n\nNous définissons les différentes fonctions impliquées dans le modèle de Rosenzweig MacArthur, la logistique et la réponse fonctionnelle de Holling II.\nPour la logistique :\n\nfunction logistic(x::Number, p::ParRma)\n    (; r, K) = p    # deconstruct/get r and K from p\n    return r*x*(1-x/K)\nend\n\n\n\n\n\n\n\nNote\n\n\n\n\nles notations var::Type permettent de spécifier le type de l’argument\nla notation (; r, K) = p permet d’extraire (deconstruct) les champs r et K du paramètre p\n\n\n\nPour la réponse fonctionnelle (sans le paramètre c) :\n\nfunction holling2(x::Number, p::ParRma)\n    (; h) = p   # deconstruct h from p\n    return x/(x+h)\nend\n\n\n\n\nPour utiliser les static arrays avec DifferentialEquations.jl il faut que la condition initiale (donc l’état) et les dérivées soient des static arrays (ici un SVector)\n\nconst x0 = 1.0\nconst y0 = 1.95\n\n# SVector are immutables\nu0 = SVector(x0, y0)\n\n2-element SVector{2, Float64} with indices SOneTo(2):\n 1.0\n 1.95\n\n\n\n\n\nOn définit les équations du modèle en exploitant les fonctions définies plus haut et la structure des paramètres, en renvoyant les dérivées sous forme de SVector :\n\nfunction mod_rma(u::SVector{2}, p::ParRma, t)\n    (; c, b, m) = p     # get c, b, m from p\n    x = u[1]            # use x, y notations\n    y = u[2]\n\n    dx = logistic(x, p) - c * holling2(x,p) * y\n    dy = b * holling2(x, p) * y - m * y\n\n    return SVector(dx, dy) # return derivatives as SVector\nend\n\n\n\n\nOn définit les paramètres du temps dans un struct :\n\n@kwdef struct ParTime\n    tspan::Tuple{Number, Number} = (0.0, 60.0)\n    tstep::Number = 0.1\nend\n\n# construc a time parameter\np_time = ParTime()\n\nEt on définit une fonction qui définit le problème de simulation, l’intègre et produit un graphique de la simulation contre le temps, avec pour arguments la condition initiale, les paramètres et les paramètres de temps :\n\nfunction plot_rma(u0::SVector{2}, p::ParRma, pt::ParTime)\n    (; tspan, tstep) = pt\n    # define and solve simulation problem\n    prob_rma = ODEProblem(mod_rma, u0, tspan, p; saveat = tstep)\n    sol_rma = solve(prob_rma, reltol = 1e-6)\n\n    # initialize figure\n    fig = Figure(; fontsize = 20)\n    ax = Axis(fig[1,1];\n        title = \"Modèle de Rosenzweig MacArthur\\n \",\n        xlabel = \"temps\",\n        ylabel = \"densités\",\n    )\n\n    # plot solution\n    lines!(ax, sol_rma.t, sol_rma[1,:]; lw = 2, label = \"proies\")\n    lines!(ax, sol_rma.t, sol_rma[2,:]; lw = 2, label = \"prédateurs\")\n    axislegend(; position = :lt)\n\n    return fig\nend\n\nFinalement on exécute cette fonction pour tracer la simulation :\n\n@time plot_rma(u0, p_rma, p_time)\n\n  7.544557 seconds (13.87 M allocations: 933.550 MiB, 3.68% gc time, 92.49% compilation time: &lt;1% of which was recompilation)\n\n\n\n\n\nFigure 1: Simulation des trajectoires du modèle de Rosenzweig MacArthur\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nLa macro @time permet de calculer le temps mis pour calculer la commande qui la suit.\n\n\nAu premier appel de la fonction plot_rma(), il y a un temps de précompilation de la fonction qui amène à un plot en de l’ordre de 7.5s sur ma machine.\nDes appels après précompilation (en changeant les paramètres !) sont de l’ordre de 2 à 3 ordres de grandeurs plus rapides :\n\n@time plot_rma(u0, p_rma2, p_time)\n\n  0.016201 seconds (228.75 k allocations: 10.170 MiB)"
  },
  {
    "objectID": "annexe_swft_rma.html#modèle-de-rosenzweig-macarthur",
    "href": "annexe_swft_rma.html#modèle-de-rosenzweig-macarthur",
    "title": "Simulation optimisée",
    "section": "",
    "text": "Nous considérons le modèle de dynamique de populations de Rosenzweig et MacArthur que nous avons déjà vu (Rosenzweig and MacArthur (1963), Turchin (2003), Smith (2008)).\n\n\\left\\{\\begin{array}{l}\n\\dot x = \\displaystyle rx\\left(1-\\frac{x}{K}\\right) - c \\frac{x}{h+x} y\\\\[.3cm]\n\\dot y = b\\displaystyle \\frac{x}{h+x} y - m y\n\\end{array}\\right.\n\\tag{1}\nL’objectif est de réaliser des simulations performantes, et le tracé du diagramme de bifurcation avec l’estimation par simulation du cycle limite. Ce type de simulations lourdes se prête bien à se genre de benchmark.\n\n\nPour un tel problème de dimension réduite, nous allons utiliser des static arrays (tableaux à adresse fixe dans la mémoire1), ce qui permettra de ne pas crééer une multitude d’objets pour la simulation mais de toujours modifier le même objet en mémoire.1 depuis le package StaticArrays.jl\nPar ailleurs nous allons essayer de nous conformer au maximum aux préconisations :\n\nne pas utiliser de variables globales\ndéfinir des fonctions\nmettre les paramètres dans un nombre limité de variables et les passer en arguments des fonctions\n\nPour ce dernier point, nous allons définir des types (struct) spécifiques.\nNous commençons par importer les packages que nous allons utiliser:\n\nusing StaticArrays\nusing DifferentialEquations\nusing CairoMakie\n\n\n\n\nNous définissons un struct pour les paramètres du modèle de Rosenzweig MacArthur.\nType pour les paramètres :\n\n@kwdef struct ParRma\n    r::Number = 1.0\n    K::Number = 10.0\n    c::Number = 1.0\n    h::Number = 2.0\n    b::Number = 2.0\n    m::Number = 1.0\nend\n\n\n\n\n\n\n\nNote\n\n\n\nLa macro @kwdef permet de renseigner des valeurs par défaut des champs du struct.\n\n\nOn peut créer des objets de type ParRma via les constructor ; on accède à un champ particulier via objet.champ :\n\np_rma = ParRma() # constructor with default values\np_rma2 = ParRma(K = 8.0) # default values except K = 20.0\n\n@show p_rma\n@show p_rma.K\n@show p_rma2.K; # semi colon do not show output of par_rma2.K\n\np_rma = ParRma(1.0, 10.0, 1.0, 2.0, 2.0, 1.0)\np_rma.K = 10.0\np_rma2.K = 8.0\n\n\n\n\n\n\n\n\nNote\n\n\n\nLa macro @show est assez explicite.\n\n\n\n\n\nNous définissons les différentes fonctions impliquées dans le modèle de Rosenzweig MacArthur, la logistique et la réponse fonctionnelle de Holling II.\nPour la logistique :\n\nfunction logistic(x::Number, p::ParRma)\n    (; r, K) = p    # deconstruct/get r and K from p\n    return r*x*(1-x/K)\nend\n\n\n\n\n\n\n\nNote\n\n\n\n\nles notations var::Type permettent de spécifier le type de l’argument\nla notation (; r, K) = p permet d’extraire (deconstruct) les champs r et K du paramètre p\n\n\n\nPour la réponse fonctionnelle (sans le paramètre c) :\n\nfunction holling2(x::Number, p::ParRma)\n    (; h) = p   # deconstruct h from p\n    return x/(x+h)\nend\n\n\n\n\nPour utiliser les static arrays avec DifferentialEquations.jl il faut que la condition initiale (donc l’état) et les dérivées soient des static arrays (ici un SVector)\n\nconst x0 = 1.0\nconst y0 = 1.95\n\n# SVector are immutables\nu0 = SVector(x0, y0)\n\n2-element SVector{2, Float64} with indices SOneTo(2):\n 1.0\n 1.95\n\n\n\n\n\nOn définit les équations du modèle en exploitant les fonctions définies plus haut et la structure des paramètres, en renvoyant les dérivées sous forme de SVector :\n\nfunction mod_rma(u::SVector{2}, p::ParRma, t)\n    (; c, b, m) = p     # get c, b, m from p\n    x = u[1]            # use x, y notations\n    y = u[2]\n\n    dx = logistic(x, p) - c * holling2(x,p) * y\n    dy = b * holling2(x, p) * y - m * y\n\n    return SVector(dx, dy) # return derivatives as SVector\nend\n\n\n\n\nOn définit les paramètres du temps dans un struct :\n\n@kwdef struct ParTime\n    tspan::Tuple{Number, Number} = (0.0, 60.0)\n    tstep::Number = 0.1\nend\n\n# construc a time parameter\np_time = ParTime()\n\nEt on définit une fonction qui définit le problème de simulation, l’intègre et produit un graphique de la simulation contre le temps, avec pour arguments la condition initiale, les paramètres et les paramètres de temps :\n\nfunction plot_rma(u0::SVector{2}, p::ParRma, pt::ParTime)\n    (; tspan, tstep) = pt\n    # define and solve simulation problem\n    prob_rma = ODEProblem(mod_rma, u0, tspan, p; saveat = tstep)\n    sol_rma = solve(prob_rma, reltol = 1e-6)\n\n    # initialize figure\n    fig = Figure(; fontsize = 20)\n    ax = Axis(fig[1,1];\n        title = \"Modèle de Rosenzweig MacArthur\\n \",\n        xlabel = \"temps\",\n        ylabel = \"densités\",\n    )\n\n    # plot solution\n    lines!(ax, sol_rma.t, sol_rma[1,:]; lw = 2, label = \"proies\")\n    lines!(ax, sol_rma.t, sol_rma[2,:]; lw = 2, label = \"prédateurs\")\n    axislegend(; position = :lt)\n\n    return fig\nend\n\nFinalement on exécute cette fonction pour tracer la simulation :\n\n@time plot_rma(u0, p_rma, p_time)\n\n  7.544557 seconds (13.87 M allocations: 933.550 MiB, 3.68% gc time, 92.49% compilation time: &lt;1% of which was recompilation)\n\n\n\n\n\nFigure 1: Simulation des trajectoires du modèle de Rosenzweig MacArthur\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nLa macro @time permet de calculer le temps mis pour calculer la commande qui la suit.\n\n\nAu premier appel de la fonction plot_rma(), il y a un temps de précompilation de la fonction qui amène à un plot en de l’ordre de 7.5s sur ma machine.\nDes appels après précompilation (en changeant les paramètres !) sont de l’ordre de 2 à 3 ordres de grandeurs plus rapides :\n\n@time plot_rma(u0, p_rma2, p_time)\n\n  0.016201 seconds (228.75 k allocations: 10.170 MiB)"
  },
  {
    "objectID": "annexe_swft_rma.html#cas-des-modèles-de-plus-grande-dimension",
    "href": "annexe_swft_rma.html#cas-des-modèles-de-plus-grande-dimension",
    "title": "Simulation optimisée",
    "section": "Cas des modèles de plus grande dimension",
    "text": "Cas des modèles de plus grande dimension\nPour les modèles de plus grande dimension (n&gt;8), l’avantage en performance des static arrays n’est plus si net et la documentation de DifferentialEquations.jl recommande d’utiliser la version en place (is in place, IIP dans le jargon du package) de l’interface problem/solver du package.\nIl s’agit ici de définir le modèle non pas comme renvoyant la dérivée en fonction de l’état, du temps et des paramètres, mais comme une fonction d’arguments la dérivée, l’état, le temps et les paramètres qui modifie en place la dérivée (et ne renvoit rien)). Celà permet de muter un même objet dérivée à chaque fois que le modèle est appelé, plutôt que de créer un nouvel objet dérivé à chaque appel (c’est aussi ce qui est fait, différemment, avec les static arrays plus haut).\nTypiquement ce type de modèle IIP (en place) s’écrit:\n\nfunction mod_rma!(du, u, t, p)\n    return nothing\nend\n\nLa définition du problème d’intégration et l’appel de solve est similaire aux autres méthodes, à ceci près que la condition initiale et la dérivée doit être mutable, ce qui ne permet pas (ou très difficilement) d’utiliser la méthode en dimension 1. En effet une déclaration u0 = 1.0 ou du = 3.0 n’est pas mutable1.1 alors que u0 = [1.0, 2.0] ou du =[2.0, 3.0] le sont. Plus sur la mutabilité dans les Julia notes"
  },
  {
    "objectID": "annexe_swft_rma.html#cas-des-modèles-de-plus-grandes-dimensions",
    "href": "annexe_swft_rma.html#cas-des-modèles-de-plus-grandes-dimensions",
    "title": "Simulation optimisée",
    "section": "Cas des modèles de plus grandes dimensions",
    "text": "Cas des modèles de plus grandes dimensions\nPour les modèles de plus grandes dimensions (n&gt;8), l’avantage en performance des static arrays n’est plus si net et la documentation de DifferentialEquations.jl recommande d’utiliser la version en place (is in place, IIP dans le jargon du package) de l’interface problem/solver du package.\nIl s’agit ici de définir le modèle non pas comme renvoyant la dérivée en fonction de l’état, des paramètres et du temps, mais comme une fonction d’arguments la dérivée, l’état, les paramètres et le temps qui modifie en place la dérivée (et ne renvoie rien)). Celà permet de muter un même objet dérivée du à chaque fois que le modèle est appelé, plutôt que de créer un nouvel objet dérivée du à chaque appel du modèle (c’est aussi ce qui est fait, différemment, avec les static arrays plus haut).\nTypiquement ce type de modèle IIP (en place) s’écrit:\n\nfunction mod_rma!(du, u, p, t)\n    return nothing\nend\n\nLa définition du problème d’intégration et l’appel de solve est similaire aux autres méthodes, à ceci près que la condition initiale et la dérivée doit être mutable, ce qui ne permet pas (ou très difficilement) d’utiliser la méthode en dimension 1. En effet une déclaration u0 = 1.0 ou du = 3.0 n’est pas mutable2.2 alors que u0 = [1.0, 2.0] ou du =[2.0, 3.0] le sont. Plus sur la mutabilité dans les Julia notes."
  },
  {
    "objectID": "annexe_swift_rma.html",
    "href": "annexe_swift_rma.html",
    "title": "Simulation améliorée",
    "section": "",
    "text": "Nous considérons le modèle de dynamique de populations de Rosenzweig et MacArthur que nous avons déjà vu (Rosenzweig and MacArthur (1963), Turchin (2003), Smith (2008)).\n\n\\left\\{\\begin{array}{l}\n\\dot x = \\displaystyle rx\\left(1-\\frac{x}{K}\\right) - c \\frac{x}{h+x} y\\\\[.3cm]\n\\dot y = b\\displaystyle \\frac{x}{h+x} y - m y\n\\end{array}\\right.\n\\tag{1}\nL’objectif est de réaliser des simulations performantes sur le tracé du diagramme de bifurcations, avec l’estimation par simulation du cycle limite. Ce type de simulations lourdes se prête bien à se genre de benchmark.\n\n\nPour un tel problème de dimension réduite, nous allons utiliser des static arrays (tableaux à adresse fixe dans la mémoire1), ce qui permettra de ne pas crééer une multitude d’objets pour la simulation mais de toujours modifier le même objet en mémoire.1 depuis le package StaticArrays.jl\nPar ailleurs nous allons essayer de nous conformer au maximum aux préconisations :\n\nne pas utiliser de variables globales\ndéfinir des fonctions\nmettre les paramètres dans un nombre limité de variables et les passer en arguments des fonctions\n\nPour ce dernier point, nous allons définir des types (struct) spécifiques.\nNous commençons par importer les packages que nous allons utiliser:\n\nusing StaticArrays\nusing DifferentialEquations\nusing CairoMakie\n\n\n\n\nNous définissons un struct pour les paramètres du modèle de Rosenzweig MacArthur.\nType pour les paramètres :\n\n# parameters struct\n@kwdef struct ParRma\n    r::Float64 = 1.0\n    K::Float64 = 10.0\n    c::Float64 = 1.0\n    h::Float64 = 2.0\n    b::Float64 = 2.0\n    m::Float64 = 1.0\nend\n\n\n\n\n\n\n\nNote\n\n\n\nLa macro @kwdef permet de renseigner des valeurs par défaut des champs du struct.\n\n\n\n\n\n\n\n\nImportant\n\n\n\nLors de la création d’un struct, on peut être tenté d’utiliser des types de champs les plus larges possibles, comme par exemple r::Real = 1.0 ou r::Number = 1.0.\nC’est une très mauvaise idée : Real et Number sont des types abstraits qui englobent de nombreux types concrets (e.g. Int64 et Float64). Par construction ils ne permettent pas de spécifier un espace mémoire de taille fixe comme le font les types concrets, et ne permettent donc pas d’optimiser le code à la précompilation2.\nA l’inverse, pour les fonctions, il est préférable de choisir le type le plus large possible pour la spécification des arguments.\n\n\n2 Par exemple, la fonction cy_rma() définie plus bas (la plus coûteuse en temps de calcul) est 70 fois plus lente avec un ParRma qui définit ses champs en Real plutôt qu’en Float64, (exécution de ~0.5s à ~35s après précompilation)On peut créer des objets de type ParRma via les constructor par défaut; on accède à un champ particulier via objet.champ :\n\n# with the struct definition, ParRma objects are immutable\nprma = ParRma() # constructor with default values\nprma2 = ParRma(K = 8.0) # default values except K = 20.0\n\n@show prma\n@show prma.K\n@show prma2.K;\n\nprma = ParRma(1.0, 10.0, 1.0, 2.0, 2.0, 1.0)\nprma.K = 10.0\nprma2.K = 8.0\n\n\n\n\n\n\n\n\nNote\n\n\n\nLa macro @show est assez explicite\nLe ; permet de ne pas renvoyer l’évaluation de la commande prma2.K (qui vaut 8.0) étant donné que nous avons déjà forcé la sortie via @show\n\n\n\n\n\nNous définissons les différentes fonctions impliquées dans le modèle de Rosenzweig MacArthur, la logistique et la réponse fonctionnelle de Holling II.\nPour la logistique :\n\nfunction logistic(x::Real, p::ParRma)\n    (; r, K) = p    # deconstruct/get r and K from p\n    return r*x*(1-x/K)\nend\n\n\n\n\n\n\n\nNote\n\n\n\n\nles notations var::Type permettent de spécifier le type de l’argument de la fonction3\nla notation (; r, K) = p permet d’extraire (deconstruct) les champs r et K du paramètre p qui est un objet de type ParRma\n\n3 C’est une des manières de faire du multiple dispatch, en définissant différentes méthodes pour les fonctions selon le type de l’argument\n\nPour la réponse fonctionnelle (sans le paramètre c) :\n\nfunction holling2(x::Real, p::ParRma)\n    (; h) = p   # deconstruct h from p\n    return x/(x+h)\nend\n\n\n\n\nPour utiliser les static arrays avec DifferentialEquations.jl il faut que l’état (donc la condition initiale) et les dérivées rendues par le modèle soient des static arrays (ici un SVector).\nNous définissons un struct de condition initiales, avec pour champs x0, y0 et un Svector composé de ces deux valeurs :\n\n# initial value struct\n@kwdef struct IniV\n    x0::Float64 = 1.0\n    y0::Float64 = 1.95\n    u0::SVector{2, Float64} = SVector(x0, y0)\nend\n# construct some initial condition\n@show iniv = IniV();\n\niniv = IniV() = IniV(1.0, 1.95, [1.0, 1.95])\n\n\nNous définissons un constructeur additionnel pour le type IniV qui à partir d’un SVector de longueur 2, construit l’objet IniV correspondant4 (nous nous en servirons plus bas dans la fonction cy_rma())4 il s’agit d’une forme de multiple dispatch sur le constructeur, avec plusieurs méthodes différents selon le type d’arguments utilisés\n\n# new constructor method for struct IniV\n# takes a length 2 SVector to construct the object (self definition)\nIniV(u0::SVector{2, Float64}) = IniV(x0 = u0[1], y0 = u0[2])\n\n# construct an initial condition with this constructor\n@show IniV(SVector(3.0, 3.0));\n\nIniV(SVector(3.0, 3.0)) = IniV(3.0, 3.0, [3.0, 3.0])\n\n\n\n\n\nOn définit les équations du modèle en exploitant les fonctions définies plus haut et la structure des paramètres, en renvoyant les dérivées sous forme de SVector :\n\nfunction mod_rma(u::SVector{2}, p::ParRma, t)\n    (; c, b, m) = p     # get c, b, m from p\n    x = u[1]            # use x, y notations\n    y = u[2]\n\n    dx = logistic(x, p) - c * holling2(x,p) * y\n    dy = b * holling2(x, p) * y - m * y\n\n    return SVector(dx, dy) # return derivatives as SVector\nend\n\n\n\n\nOn définit les paramètres du temps dans un struct :\n\n# time parameters struct\n@kwdef struct ParTime\n    tspan::Tuple{Float64, Float64} = (0.0, 60.0)\n    tstep::Float64 = 0.1\nend\n\n# construct a time parameter\nptime = ParTime()\n\nOn définit une fonction qui définit le problème de simulation, l’intègre et retourne la solution, avec pour arguments positionnels la condition initiale, les paramètres et les paramètres de temps, et comme keyword argument le paramètre booléen final.\nLorsque final = false (par défaut), la fonction renvoie toute la solution. Lorsque final  =true la fonction renvoie la valeur finale de la simulation, ce dont nous nous servirons plus bas dans l’estimation des extremas du cycle limite.\n\nfunction sim_rma(iniv::IniV, p::ParRma, pt::ParTime; final::Bool = false)\n    # deconstruct time parameter\n    (; tspan, tstep) = pt\n    (; u0) = iniv\n\n    # define and solve simulation problem\n    prob_rma = ODEProblem(mod_rma, u0, tspan, p)\n    if !final   # if final == false compute whole solution\n        sol_rma = solve(prob_rma; reltol = 1e-6, saveat = tstep)\n    else        # if final == true compute only final state\n        sol_rma = solve(\n            prob_rma;\n            reltol = 1e-6,\n            save_everystep = false,\n            save_start = false,\n        )\n    end\n\n    return sol_rma\nend\n\n@time sim_rma(iniv, prma, ptime);\n\n  1.839824 seconds (5.05 M allocations: 339.069 MiB, 4.31% gc time, 99.97% compilation time: &lt;1% of which was recompilation)\n\n\n\n\n\n\n\n\nNote\n\n\n\nLa macro @time renvoit le temps (et qqes éléments sur la computation) mis pour calculer la commande qui la suit, ici la simulation.\n\n\nUne fois la fonction précompilée à la première exécution, la performance est incomparable (4 ordres de grandeur plus rapide sur la fonction sim_rma()) :\n\n@time sim_rma(iniv, prma2, ptime);\n\n  0.000178 seconds (129 allocations: 42.547 KiB)\n\n\n\n\n\nFinalement, on définit une fonction qui simule et produit un graphique de la solution contre le temps, avec pour arguments la condition initiale, les paramètres et les paramètres de temps :\n\nfunction plot_rma(iniv::IniV, p::ParRma, pt::ParTime)\n    # compute the simulation\n    sol_rma = sim_rma(iniv, p, pt)\n\n    # initialize figure\n    fig = Figure(; fontsize = 20)\n    ax = Axis(fig[1,1];\n        title = \"Modèle de Rosenzweig MacArthur\\n \",\n        xlabel = \"temps\",\n        ylabel = \"densités\",\n    )\n\n    # plot solution\n    lines!(ax, sol_rma.t, sol_rma[1,:]; lw = 2, label = \"proies\")\n    lines!(ax, sol_rma.t,  sol_rma[2,:]; lw = 2, label = \"prédateurs\")\n    axislegend(; position = :lt)\n\n    return fig\nend\n\nFinalement on exécute cette fonction pour tracer la simulation :\n\nplot_rma(iniv, prma, ptime)\n\n\n\n\nFigure 1: Simulation des trajectoires du modèle de Rosenzweig MacArthur\n\n\n\n\n\n\n\nNous calculons ici le diagramme de bifurcations : les asymptotiques des prédateurs y^* en fonction de K.\n\n\nIl n’y a pas besoin de simulation ici puisque les lieux des équilibres sont facilement calculables analytiquement (cf. cette page).\nNous définissons une fonction qui prend les paramètres du modèle et renvoit des tuples définissant les différentes branches d’équilibres (K, y^*) (avec en kwarg un Kmax et un Kstep avec des valeurs par défaut).\n\nfunction eqy_rma(p::ParRma; Kmax::Real = 8.0, Kstep::Real = 0.1)\n    (; r, c, h, b, m) = p # deconstruct p (K is useless since it is varied)\n\n    # define bifurcation K values\n    Ktrans = m*h/(b-m)\n    Khopf = h+2*m*h/(b-m)\n\n    # drops an error if Kmax is too small\n    if Kmax &lt; Khopf\n        error(\"For a full computation of equilibria types, Kmax must be greater than $Khopf\")\n    end\n\n    # y equilibria\n    # below transcritical : only y=0\n    Krg1 = 0:Kstep:Ktrans\n    y01 = ones(length(Krg1)).*0     # broadcasting\n    eqs1 = (Krg = Krg1, y0 = y01, yco = nothing)\n\n    # between transcritical and Hopf : y=0 and y&gt;0\n    Krg2 = Ktrans:Kstep:Khopf\n    y02 = ones(length(Krg2)).*0\n    yco2 = [r/c*(h+m*h/(b-m))*(1-m*h/(b-m)/K) for K in Krg2]\n    eqs2 = (Krg = Krg2, y0 = y02, yco = yco2)\n\n    # above Hopf : y=0 and y&gt;0\n    Krg3 = Khopf:Kstep:Kmax\n    y03 = ones(length(Krg3)).*0\n    yco3 = [r/c*(h+m*h/(b-m))*(1-m*h/(b-m)/K) for K in Krg3]\n    eqs3 = (Krg = Krg3, y0 = y03, yco = yco3)\n\n    return eqs1, eqs2, eqs3\nend\n\n\n\n\nOn définit une fonction qui renvoit un tuple contenant les valeurs de K et les extremas du cycle limite apparaissant pour K &gt; K_{hopf} = h+\\frac{2mh}{b-m}.\nLa fonction prend pour argument les paramètres, et fait appel à la fonction sim_rma() avec les méthodes final = true (pour les transitoires) et final = false (pour les extremas du cycle limite). Elle utilise aussi le constructeur supplémentaire pour les objets IniV.\n\nfunction cy_rma(p::ParRma; Kmax::Float64 = 8.0, Kstep::Float64 = 0.01)\n    # parameters and K range\n    (; r, c, h, b, m) = p # deconstruct p (K is useless since it is varied)\n    Khopf = h+2*m*h/(b-m)\n    Krgh = Khopf-Kstep:Kstep:Kmax\n\n    # drops an error if Kmax is too small\n    if Kmax &lt; Khopf\n        error(\"For a computation of the limit cycle, Kmax must be greater than $Khopf\")\n    end\n\n    # for storage\n    ycmin = zero(Krgh)\n    ycmax = zero(Krgh)\n\n    # initial value and time parameters\n    iniv = IniV()\n    ptime = ParTime()\n\n    # transient integration time\n    ptrans = ParTime(tspan = (0.0, 8000.0))\n\n    for (i, Kh) in enumerate(Krgh)\n        # construct parameter from p, with K = Kh of the loop\n        prmabif = ParRma(r, Kh, c, h, b, m)\n\n        # simulate transient, get final state\n        utr = sim_rma(iniv, prmabif, ptrans; final = true)[:,1]\n        inivtr = IniV(utr) # construct new init value\n\n        # start from end of transient, simulate limit cycle\n        sol_cyc = sim_rma(inivtr, prmabif, ptime)\n\n        # get min and max y along the cycle\n        ycmin[i] = minimum(sol_cyc[2,:])\n        ycmax[i] = maximum(sol_cyc[2,:])\n    end\n\n    cycle = (Krg = Krgh, ycmin = ycmin, ycmax = ycmax)\n    return cycle\nend\n\n@time cy_rma(prma);\n\n  1.096500 seconds (1.16 M allocations: 91.170 MiB, 2.15% gc time, 64.68% compilation time)\n\n\nAprès précompilation, ce calcul est encore plus rapide :\n\n@time cy_rma(prma2);\n\n  0.396381 seconds (51.71 k allocations: 17.591 MiB)\n\n\nA titre d’exemple, la simulation sur cette page prenait de l’ordre de 20 fois plus longtemps pour un calcul similaire.\n\n\n\nFinalement, nous définissons une fonction permettant de représenter le diagramme de bifurcations, qui fait appel aux fonctions eqy_rma() et cy_rma() définies ci-dessus :\n\nfunction plot_bif_rma(p::ParRma; Kmax = 8.0, Kstep = 0.1)\n    # initialize figure\n    fig = Figure(; fontsize = 20)\n    ax = Axis(fig[1,1];\n        title = \"Bifurcations du modèle de Rosenzweig MacArthur\\n \",\n        xlabel = \"capacité de charge 𝐾\",\n        ylabel = \"densités\",\n    )\n\n    # plot equilibria\n    eqs1, eqs2, eqs3 = eqy_rma(p; Kmax = Kmax, Kstep = Kstep)\n    lines!(eqs1.Krg, eqs1.y0; color = Cycled(1), lw = 2, label = \"branche stable\")\n    lines!(eqs2.Krg, eqs2.y0; color = Cycled(2), lw = 2, label = \"branche instable\")\n    lines!(eqs2.Krg, eqs2.yco; color = Cycled(1), lw = 2)\n    lines!(eqs3.Krg, eqs3.y0; color = Cycled(2), lw = 2)\n    lines!(eqs3.Krg, eqs3.yco; color = Cycled(2), lw = 2)\n\n    # plot limit Cycle\n    cycle = cy_rma(p; Kmax = Kmax) # we keep the default Kstep = 0.01 for accuracy\n    lines!(cycle.Krg, cycle.ycmin; color = Cycled(3), lw=2, label = \"cycle limite\")\n    lines!(cycle.Krg, cycle.ycmax; color = Cycled(3), lw=2)\n\n    axislegend(ax, position = :lt, labelsize = 14)\n\n    return fig\nend\n\nCe qui donne :\n\nplot_bif_rma(prma)\n\n\n\n\nFigure 2: Diagramme de bifurcations du modèle de Rosenzweig MacArthur\n\n\n\n\n\n\n\n\nAvec cette écriture de programme exploitant au maximum des structs et des fonctions, il est facile de placer l’ensemble des définitions dans un module dans fichier séparé, et de créer un script principal qui appelle ce module et ne demande que quelques lignes pour effectuer les simulations présentées plus haut sur cette page.\nUne telle architecture fichier/moudle/script principal est présentée sur cette page."
  },
  {
    "objectID": "annexe_swift_rma.html#modèle-de-rosenzweig-macarthur",
    "href": "annexe_swift_rma.html#modèle-de-rosenzweig-macarthur",
    "title": "Simulation améliorée",
    "section": "",
    "text": "Nous considérons le modèle de dynamique de populations de Rosenzweig et MacArthur que nous avons déjà vu (Rosenzweig and MacArthur (1963), Turchin (2003), Smith (2008)).\n\n\\left\\{\\begin{array}{l}\n\\dot x = \\displaystyle rx\\left(1-\\frac{x}{K}\\right) - c \\frac{x}{h+x} y\\\\[.3cm]\n\\dot y = b\\displaystyle \\frac{x}{h+x} y - m y\n\\end{array}\\right.\n\\tag{1}\nL’objectif est de réaliser des simulations performantes sur le tracé du diagramme de bifurcations, avec l’estimation par simulation du cycle limite. Ce type de simulations lourdes se prête bien à se genre de benchmark.\n\n\nPour un tel problème de dimension réduite, nous allons utiliser des static arrays (tableaux à adresse fixe dans la mémoire1), ce qui permettra de ne pas crééer une multitude d’objets pour la simulation mais de toujours modifier le même objet en mémoire.1 depuis le package StaticArrays.jl\nPar ailleurs nous allons essayer de nous conformer au maximum aux préconisations :\n\nne pas utiliser de variables globales\ndéfinir des fonctions\nmettre les paramètres dans un nombre limité de variables et les passer en arguments des fonctions\n\nPour ce dernier point, nous allons définir des types (struct) spécifiques.\nNous commençons par importer les packages que nous allons utiliser:\n\nusing StaticArrays\nusing DifferentialEquations\nusing CairoMakie\n\n\n\n\nNous définissons un struct pour les paramètres du modèle de Rosenzweig MacArthur.\nType pour les paramètres :\n\n# parameters struct\n@kwdef struct ParRma\n    r::Float64 = 1.0\n    K::Float64 = 10.0\n    c::Float64 = 1.0\n    h::Float64 = 2.0\n    b::Float64 = 2.0\n    m::Float64 = 1.0\nend\n\n\n\n\n\n\n\nNote\n\n\n\nLa macro @kwdef permet de renseigner des valeurs par défaut des champs du struct.\n\n\n\n\n\n\n\n\nImportant\n\n\n\nLors de la création d’un struct, on peut être tenté d’utiliser des types de champs les plus larges possibles, comme par exemple r::Real = 1.0 ou r::Number = 1.0.\nC’est une très mauvaise idée : Real et Number sont des types abstraits qui englobent de nombreux types concrets (e.g. Int64 et Float64). Par construction ils ne permettent pas de spécifier un espace mémoire de taille fixe comme le font les types concrets, et ne permettent donc pas d’optimiser le code à la précompilation2.\nA l’inverse, pour les fonctions, il est préférable de choisir le type le plus large possible pour la spécification des arguments.\n\n\n2 Par exemple, la fonction cy_rma() définie plus bas (la plus coûteuse en temps de calcul) est 70 fois plus lente avec un ParRma qui définit ses champs en Real plutôt qu’en Float64, (exécution de ~0.5s à ~35s après précompilation)On peut créer des objets de type ParRma via les constructor par défaut; on accède à un champ particulier via objet.champ :\n\n# with the struct definition, ParRma objects are immutable\nprma = ParRma() # constructor with default values\nprma2 = ParRma(K = 8.0) # default values except K = 20.0\n\n@show prma\n@show prma.K\n@show prma2.K;\n\nprma = ParRma(1.0, 10.0, 1.0, 2.0, 2.0, 1.0)\nprma.K = 10.0\nprma2.K = 8.0\n\n\n\n\n\n\n\n\nNote\n\n\n\nLa macro @show est assez explicite\nLe ; permet de ne pas renvoyer l’évaluation de la commande prma2.K (qui vaut 8.0) étant donné que nous avons déjà forcé la sortie via @show\n\n\n\n\n\nNous définissons les différentes fonctions impliquées dans le modèle de Rosenzweig MacArthur, la logistique et la réponse fonctionnelle de Holling II.\nPour la logistique :\n\nfunction logistic(x::Real, p::ParRma)\n    (; r, K) = p    # deconstruct/get r and K from p\n    return r*x*(1-x/K)\nend\n\n\n\n\n\n\n\nNote\n\n\n\n\nles notations var::Type permettent de spécifier le type de l’argument de la fonction3\nla notation (; r, K) = p permet d’extraire (deconstruct) les champs r et K du paramètre p qui est un objet de type ParRma\n\n3 C’est une des manières de faire du multiple dispatch, en définissant différentes méthodes pour les fonctions selon le type de l’argument\n\nPour la réponse fonctionnelle (sans le paramètre c) :\n\nfunction holling2(x::Real, p::ParRma)\n    (; h) = p   # deconstruct h from p\n    return x/(x+h)\nend\n\n\n\n\nPour utiliser les static arrays avec DifferentialEquations.jl il faut que l’état (donc la condition initiale) et les dérivées rendues par le modèle soient des static arrays (ici un SVector).\nNous définissons un struct de condition initiales, avec pour champs x0, y0 et un Svector composé de ces deux valeurs :\n\n# initial value struct\n@kwdef struct IniV\n    x0::Float64 = 1.0\n    y0::Float64 = 1.95\n    u0::SVector{2, Float64} = SVector(x0, y0)\nend\n# construct some initial condition\n@show iniv = IniV();\n\niniv = IniV() = IniV(1.0, 1.95, [1.0, 1.95])\n\n\nNous définissons un constructeur additionnel pour le type IniV qui à partir d’un SVector de longueur 2, construit l’objet IniV correspondant4 (nous nous en servirons plus bas dans la fonction cy_rma())4 il s’agit d’une forme de multiple dispatch sur le constructeur, avec plusieurs méthodes différents selon le type d’arguments utilisés\n\n# new constructor method for struct IniV\n# takes a length 2 SVector to construct the object (self definition)\nIniV(u0::SVector{2, Float64}) = IniV(x0 = u0[1], y0 = u0[2])\n\n# construct an initial condition with this constructor\n@show IniV(SVector(3.0, 3.0));\n\nIniV(SVector(3.0, 3.0)) = IniV(3.0, 3.0, [3.0, 3.0])\n\n\n\n\n\nOn définit les équations du modèle en exploitant les fonctions définies plus haut et la structure des paramètres, en renvoyant les dérivées sous forme de SVector :\n\nfunction mod_rma(u::SVector{2}, p::ParRma, t)\n    (; c, b, m) = p     # get c, b, m from p\n    x = u[1]            # use x, y notations\n    y = u[2]\n\n    dx = logistic(x, p) - c * holling2(x,p) * y\n    dy = b * holling2(x, p) * y - m * y\n\n    return SVector(dx, dy) # return derivatives as SVector\nend\n\n\n\n\nOn définit les paramètres du temps dans un struct :\n\n# time parameters struct\n@kwdef struct ParTime\n    tspan::Tuple{Float64, Float64} = (0.0, 60.0)\n    tstep::Float64 = 0.1\nend\n\n# construct a time parameter\nptime = ParTime()\n\nOn définit une fonction qui définit le problème de simulation, l’intègre et retourne la solution, avec pour arguments positionnels la condition initiale, les paramètres et les paramètres de temps, et comme keyword argument le paramètre booléen final.\nLorsque final = false (par défaut), la fonction renvoie toute la solution. Lorsque final  =true la fonction renvoie la valeur finale de la simulation, ce dont nous nous servirons plus bas dans l’estimation des extremas du cycle limite.\n\nfunction sim_rma(iniv::IniV, p::ParRma, pt::ParTime; final::Bool = false)\n    # deconstruct time parameter\n    (; tspan, tstep) = pt\n    (; u0) = iniv\n\n    # define and solve simulation problem\n    prob_rma = ODEProblem(mod_rma, u0, tspan, p)\n    if !final   # if final == false compute whole solution\n        sol_rma = solve(prob_rma; reltol = 1e-6, saveat = tstep)\n    else        # if final == true compute only final state\n        sol_rma = solve(\n            prob_rma;\n            reltol = 1e-6,\n            save_everystep = false,\n            save_start = false,\n        )\n    end\n\n    return sol_rma\nend\n\n@time sim_rma(iniv, prma, ptime);\n\n  1.839824 seconds (5.05 M allocations: 339.069 MiB, 4.31% gc time, 99.97% compilation time: &lt;1% of which was recompilation)\n\n\n\n\n\n\n\n\nNote\n\n\n\nLa macro @time renvoit le temps (et qqes éléments sur la computation) mis pour calculer la commande qui la suit, ici la simulation.\n\n\nUne fois la fonction précompilée à la première exécution, la performance est incomparable (4 ordres de grandeur plus rapide sur la fonction sim_rma()) :\n\n@time sim_rma(iniv, prma2, ptime);\n\n  0.000178 seconds (129 allocations: 42.547 KiB)\n\n\n\n\n\nFinalement, on définit une fonction qui simule et produit un graphique de la solution contre le temps, avec pour arguments la condition initiale, les paramètres et les paramètres de temps :\n\nfunction plot_rma(iniv::IniV, p::ParRma, pt::ParTime)\n    # compute the simulation\n    sol_rma = sim_rma(iniv, p, pt)\n\n    # initialize figure\n    fig = Figure(; fontsize = 20)\n    ax = Axis(fig[1,1];\n        title = \"Modèle de Rosenzweig MacArthur\\n \",\n        xlabel = \"temps\",\n        ylabel = \"densités\",\n    )\n\n    # plot solution\n    lines!(ax, sol_rma.t, sol_rma[1,:]; lw = 2, label = \"proies\")\n    lines!(ax, sol_rma.t,  sol_rma[2,:]; lw = 2, label = \"prédateurs\")\n    axislegend(; position = :lt)\n\n    return fig\nend\n\nFinalement on exécute cette fonction pour tracer la simulation :\n\nplot_rma(iniv, prma, ptime)\n\n\n\n\nFigure 1: Simulation des trajectoires du modèle de Rosenzweig MacArthur\n\n\n\n\n\n\n\nNous calculons ici le diagramme de bifurcations : les asymptotiques des prédateurs y^* en fonction de K.\n\n\nIl n’y a pas besoin de simulation ici puisque les lieux des équilibres sont facilement calculables analytiquement (cf. cette page).\nNous définissons une fonction qui prend les paramètres du modèle et renvoit des tuples définissant les différentes branches d’équilibres (K, y^*) (avec en kwarg un Kmax et un Kstep avec des valeurs par défaut).\n\nfunction eqy_rma(p::ParRma; Kmax::Real = 8.0, Kstep::Real = 0.1)\n    (; r, c, h, b, m) = p # deconstruct p (K is useless since it is varied)\n\n    # define bifurcation K values\n    Ktrans = m*h/(b-m)\n    Khopf = h+2*m*h/(b-m)\n\n    # drops an error if Kmax is too small\n    if Kmax &lt; Khopf\n        error(\"For a full computation of equilibria types, Kmax must be greater than $Khopf\")\n    end\n\n    # y equilibria\n    # below transcritical : only y=0\n    Krg1 = 0:Kstep:Ktrans\n    y01 = ones(length(Krg1)).*0     # broadcasting\n    eqs1 = (Krg = Krg1, y0 = y01, yco = nothing)\n\n    # between transcritical and Hopf : y=0 and y&gt;0\n    Krg2 = Ktrans:Kstep:Khopf\n    y02 = ones(length(Krg2)).*0\n    yco2 = [r/c*(h+m*h/(b-m))*(1-m*h/(b-m)/K) for K in Krg2]\n    eqs2 = (Krg = Krg2, y0 = y02, yco = yco2)\n\n    # above Hopf : y=0 and y&gt;0\n    Krg3 = Khopf:Kstep:Kmax\n    y03 = ones(length(Krg3)).*0\n    yco3 = [r/c*(h+m*h/(b-m))*(1-m*h/(b-m)/K) for K in Krg3]\n    eqs3 = (Krg = Krg3, y0 = y03, yco = yco3)\n\n    return eqs1, eqs2, eqs3\nend\n\n\n\n\nOn définit une fonction qui renvoit un tuple contenant les valeurs de K et les extremas du cycle limite apparaissant pour K &gt; K_{hopf} = h+\\frac{2mh}{b-m}.\nLa fonction prend pour argument les paramètres, et fait appel à la fonction sim_rma() avec les méthodes final = true (pour les transitoires) et final = false (pour les extremas du cycle limite). Elle utilise aussi le constructeur supplémentaire pour les objets IniV.\n\nfunction cy_rma(p::ParRma; Kmax::Float64 = 8.0, Kstep::Float64 = 0.01)\n    # parameters and K range\n    (; r, c, h, b, m) = p # deconstruct p (K is useless since it is varied)\n    Khopf = h+2*m*h/(b-m)\n    Krgh = Khopf-Kstep:Kstep:Kmax\n\n    # drops an error if Kmax is too small\n    if Kmax &lt; Khopf\n        error(\"For a computation of the limit cycle, Kmax must be greater than $Khopf\")\n    end\n\n    # for storage\n    ycmin = zero(Krgh)\n    ycmax = zero(Krgh)\n\n    # initial value and time parameters\n    iniv = IniV()\n    ptime = ParTime()\n\n    # transient integration time\n    ptrans = ParTime(tspan = (0.0, 8000.0))\n\n    for (i, Kh) in enumerate(Krgh)\n        # construct parameter from p, with K = Kh of the loop\n        prmabif = ParRma(r, Kh, c, h, b, m)\n\n        # simulate transient, get final state\n        utr = sim_rma(iniv, prmabif, ptrans; final = true)[:,1]\n        inivtr = IniV(utr) # construct new init value\n\n        # start from end of transient, simulate limit cycle\n        sol_cyc = sim_rma(inivtr, prmabif, ptime)\n\n        # get min and max y along the cycle\n        ycmin[i] = minimum(sol_cyc[2,:])\n        ycmax[i] = maximum(sol_cyc[2,:])\n    end\n\n    cycle = (Krg = Krgh, ycmin = ycmin, ycmax = ycmax)\n    return cycle\nend\n\n@time cy_rma(prma);\n\n  1.096500 seconds (1.16 M allocations: 91.170 MiB, 2.15% gc time, 64.68% compilation time)\n\n\nAprès précompilation, ce calcul est encore plus rapide :\n\n@time cy_rma(prma2);\n\n  0.396381 seconds (51.71 k allocations: 17.591 MiB)\n\n\nA titre d’exemple, la simulation sur cette page prenait de l’ordre de 20 fois plus longtemps pour un calcul similaire.\n\n\n\nFinalement, nous définissons une fonction permettant de représenter le diagramme de bifurcations, qui fait appel aux fonctions eqy_rma() et cy_rma() définies ci-dessus :\n\nfunction plot_bif_rma(p::ParRma; Kmax = 8.0, Kstep = 0.1)\n    # initialize figure\n    fig = Figure(; fontsize = 20)\n    ax = Axis(fig[1,1];\n        title = \"Bifurcations du modèle de Rosenzweig MacArthur\\n \",\n        xlabel = \"capacité de charge 𝐾\",\n        ylabel = \"densités\",\n    )\n\n    # plot equilibria\n    eqs1, eqs2, eqs3 = eqy_rma(p; Kmax = Kmax, Kstep = Kstep)\n    lines!(eqs1.Krg, eqs1.y0; color = Cycled(1), lw = 2, label = \"branche stable\")\n    lines!(eqs2.Krg, eqs2.y0; color = Cycled(2), lw = 2, label = \"branche instable\")\n    lines!(eqs2.Krg, eqs2.yco; color = Cycled(1), lw = 2)\n    lines!(eqs3.Krg, eqs3.y0; color = Cycled(2), lw = 2)\n    lines!(eqs3.Krg, eqs3.yco; color = Cycled(2), lw = 2)\n\n    # plot limit Cycle\n    cycle = cy_rma(p; Kmax = Kmax) # we keep the default Kstep = 0.01 for accuracy\n    lines!(cycle.Krg, cycle.ycmin; color = Cycled(3), lw=2, label = \"cycle limite\")\n    lines!(cycle.Krg, cycle.ycmax; color = Cycled(3), lw=2)\n\n    axislegend(ax, position = :lt, labelsize = 14)\n\n    return fig\nend\n\nCe qui donne :\n\nplot_bif_rma(prma)\n\n\n\n\nFigure 2: Diagramme de bifurcations du modèle de Rosenzweig MacArthur\n\n\n\n\n\n\n\n\nAvec cette écriture de programme exploitant au maximum des structs et des fonctions, il est facile de placer l’ensemble des définitions dans un module dans fichier séparé, et de créer un script principal qui appelle ce module et ne demande que quelques lignes pour effectuer les simulations présentées plus haut sur cette page.\nUne telle architecture fichier/moudle/script principal est présentée sur cette page."
  },
  {
    "objectID": "annexe_swift_rma.html#cas-des-modèles-de-plus-grandes-dimensions",
    "href": "annexe_swift_rma.html#cas-des-modèles-de-plus-grandes-dimensions",
    "title": "Simulation améliorée",
    "section": "Cas des modèles de plus grandes dimensions",
    "text": "Cas des modèles de plus grandes dimensions\nPour les modèles de plus grandes dimensions (n&gt;8), l’avantage en performance des static arrays n’est plus si net et la documentation de DifferentialEquations.jl recommande d’utiliser la version en place (is in place, IIP dans le jargon du package) de l’interface problem/solver du package.\nIl s’agit ici de définir le modèle non pas comme renvoyant la dérivée en fonction de l’état, des paramètres et du temps, mais comme une fonction d’arguments la dérivée, l’état, les paramètres et le temps qui modifie en place la dérivée (et ne renvoie rien)). Celà permet de muter un même objet dérivée du à chaque fois que le modèle est appelé, plutôt que de créer un nouvel objet dérivée du à chaque appel du modèle (c’est aussi ce qui est fait, différemment, avec les static arrays plus haut).\nTypiquement ce type de modèle IIP (en place) s’écrit:\n\nfunction mod_rma!(du, u, p, t)\n    return nothing\nend\n\nLa définition du problème d’intégration et l’appel de solve est similaire aux autres méthodes, à ceci près que la condition initiale et la dérivée doit être mutable, ce qui ne permet pas (ou très difficilement) d’utiliser la méthode en dimension 1. En effet une déclaration u0 = 1.0 ou du = 3.0 n’est pas mutable4.4 alors que u0 = [1.0, 2.0] ou du =[2.0, 3.0] le sont. Plus sur la mutabilité dans les Julia notes."
  },
  {
    "objectID": "annexe_swift_rma.html#cas-des-modèles-de-plus-grande-dimension",
    "href": "annexe_swift_rma.html#cas-des-modèles-de-plus-grande-dimension",
    "title": "Simulation améliorée",
    "section": "Cas des modèles de plus grande dimension",
    "text": "Cas des modèles de plus grande dimension\nPour les modèles de plus grande dimension (n&gt;8), l’avantage en performance des static arrays n’est plus si net et la documentation de DifferentialEquations.jl recommande d’utiliser la version en place (is in place, IIP dans le jargon du package) de l’interface problem/solver du package.\nIl s’agit ici de définir le modèle non pas comme renvoyant la dérivée en fonction de l’état, des paramètres et du temps, mais comme une fonction d’arguments la dérivée, l’état, les paramètres et le temps qui modifie en place la dérivée (et ne renvoie rien). Cela permet de muter un même objet dérivée du à chaque fois que le modèle est appelé, plutôt que de créer un nouvel objet dérivée du à chaque appel du modèle (c’est aussi dans le même esprit de ce qui est fait, différemment, avec les static arrays plus haut).\nTypiquement ce type de modèle IIP (en place) s’écrit:\n\nfunction mod_rma!(du, u, p::ParRma, t)\n    (; c, b, m) = p     # get c, b, m from p\n    x = u[1]            # use x, y notations\n    y = u[2]\n\n    # in-place computation of du\n    du[1] = logistic(x, p) - c * holling2(x,p) * y\n    du[2] = b * holling2(x, p) * y - m * y\n    return nothing\nend\n\nLa définition du problème d’intégration et l’appel de solve est similaire aux autres méthodes, à ceci près que la condition initiale et la dérivée doit être mutable, ce qui ne permet pas (ou très difficilement) d’utiliser la méthode en dimension 1. En effet une déclaration u0 = 1.0 ou du = 3.0 n’est pas mutable5.5 alors que u0 = [1.0, 2.0] ou du =[2.0, 3.0] le sont. Plus sur la mutabilité dans les Julia notes."
  },
  {
    "objectID": "annexe_rma_module.html",
    "href": "annexe_rma_module.html",
    "title": "Mon premier module",
    "section": "",
    "text": "Nous exploitons le code produit pour simuler de façon efficace le modèle de Rosenzweig MacArthur (cf. cette page) pour générer un module (essentiellement un ensemble d’objets et de fonctions qui peuvent être utilisés par d’autres programmes).\nUne fois le code entièrement sous forme de struct et de function, la création du module est très simple. On place le module dans un fichier RmaMod.jl avec l’architecture suivante :\n\n# ce code n'est pas exécuté dans cette cellule pour ne pas interférer\n# avec le module que nous importons après\n\"\"\"\nsome help regarding the module...\n\"\"\"\nmodule RmaMod\n\n# import required packages, e.g.\nusing StaticArrays\n\n# export what you want other programs to know when importing through `using`\nexport IniV, logistic\n\n# put structs help and definition, e.g.:\n\"\"\"\nsome help for IniV struct\n\"\"\"\n@kwdef struct IniV\n    x0::Float64 = 1.0\n    y0::Float64 = 1.95\n    u0::SVector{2, Float64} = SVector(x0, y0)\nend\n\n# put functions help and definition, e.g.:\n\"\"\"\nsome help for logistic function\n\"\"\"\nfunction logistic(x::Real, p::ParRma)\n    (; r, K) = p    # deconstruct/get r and K from p\n    return r*x*(1-x/K)\nend\n\nend\n\nLe vrai fichier RmaMod.jl définissant le module RmaMod est disponible ici."
  },
  {
    "objectID": "annexe_rma_module.html#module-rmamod.jl",
    "href": "annexe_rma_module.html#module-rmamod.jl",
    "title": "Mon premier module",
    "section": "",
    "text": "Nous exploitons le code produit pour simuler de façon efficace le modèle de Rosenzweig MacArthur (cf. cette page) pour générer un module (essentiellement un ensemble d’objets et de fonctions qui peuvent être utilisés par d’autres programmes).\nUne fois le code entièrement sous forme de struct et de function, la création du module est très simple. On place le module dans un fichier RmaMod.jl avec l’architecture suivante :\n\n# ce code n'est pas exécuté dans cette cellule pour ne pas interférer\n# avec le module que nous importons après\n\"\"\"\nsome help regarding the module...\n\"\"\"\nmodule RmaMod\n\n# import required packages, e.g.\nusing StaticArrays\n\n# export what you want other programs to know when importing through `using`\nexport IniV, logistic\n\n# put structs help and definition, e.g.:\n\"\"\"\nsome help for IniV struct\n\"\"\"\n@kwdef struct IniV\n    x0::Float64 = 1.0\n    y0::Float64 = 1.95\n    u0::SVector{2, Float64} = SVector(x0, y0)\nend\n\n# put functions help and definition, e.g.:\n\"\"\"\nsome help for logistic function\n\"\"\"\nfunction logistic(x::Real, p::ParRma)\n    (; r, K) = p    # deconstruct/get r and K from p\n    return r*x*(1-x/K)\nend\n\nend\n\nLe vrai fichier RmaMod.jl définissant le module RmaMod est disponible ici."
  },
  {
    "objectID": "annexe_rma_module.html#utilisation-du-module",
    "href": "annexe_rma_module.html#utilisation-du-module",
    "title": "Mon premier module",
    "section": "Utilisation du module",
    "text": "Utilisation du module\nPour utiliser le module contenu dans le fichier RmaMod.jl, nous incluons ce fichier (il est dans le répertoire ./src/ ici) et l’importons avec using :\n\ninclude(\"./src/RmaMod.jl\")\nusing .RmaMod\n\nLe module exporte:\n\nles structs : IniV (conditions initiales), ParRma (paramètres du modèle), ParTime (paramètres de temps),\nles fonctions : plot_rma() et plot_bif_rma(),\n\ncomme nous le confirme l’aide du module (dans la mesure ou elle est bien renseignée).\n\n@doc RmaMod\n\nThe module RmaMod provides structs and functions to simulate and plot the dynamics and bifurcation diagram of the Rosenzweig MacArthur model.\nExported structs are:\n\nIniv initial condition objects\nParRma model parameters objects\nParTime time parameters objects\n\nExported functions are:\n\nplot_rma() to simulate and plot the RMA dynamics against time\nplot_bif_rma() to simulate and plot the RMA bifurcation diagram against K\n\n\n\nOn peut obtenir de l’aide sur ces fonctions (si le module a bien rempli ses docstrings):\n\n@doc plot_rma\n\nplot_rma(iniv, p, pt)\nsimulates and plots predator x and prey y density dynamics against time, given model parameters p and time parameters pt. returns a CairoMakie figure object.\narguments:\n\niniv is an IniV initial value object (defined in this module)\np is a ParRma parameter object (defined in this module)\npt is a ParTime time parameter object (defined in this module)"
  },
  {
    "objectID": "annexe_rma_module.html#simulation-des-dynamiques",
    "href": "annexe_rma_module.html#simulation-des-dynamiques",
    "title": "Mon premier module",
    "section": "Simulation des dynamiques",
    "text": "Simulation des dynamiques\nNous pouvons simuler les dynamiques du modèle en appelant les constructeurs par défaut des objets à la volée :\n\nplot_rma(IniV(), ParRma(), ParTime())\n\n\n\n\nMais aussi en spécifiant certains objets, comme e.g. les paramètres :\n\nplot_rma(IniV(), ParRma(K = 5.0), ParTime())"
  },
  {
    "objectID": "annexe_rma_module.html#diagramme-de-bifurcations",
    "href": "annexe_rma_module.html#diagramme-de-bifurcations",
    "title": "Mon premier module",
    "section": "Diagramme de bifurcations",
    "text": "Diagramme de bifurcations\nDe la même manière, on peut générer un diagramme de bifurcations :\n\nplot_bif_rma(ParRma())"
  },
  {
    "objectID": "index.html#reproductibilité",
    "href": "index.html#reproductibilité",
    "title": "Introduction",
    "section": "Reproductibilité",
    "text": "Reproductibilité\nAu fil du temps les différents packages Julia changent de version, perdant parfois des fonctionnalités ou ayant une interface ou des commandes qui changent. Une manière d’assurer la reproductibilité d’un code est de figer la version des packages (et de Julia) utilisés en spécifiant un environnement/projet de travail. Cela génère deux fichiers Project.toml et Manifest.toml qui décrivent les versions spécifiques de Julia et des packages utilisés par le code lorsque le projet a été créé.\nPour pouvoir utiliser le même environnement que celui utilisé ici, créez un répertoire de travail dans lequel vous placerez vos scripts/notebooks, mettons : ~/some/where/biomaths/ .\nTéléchargez et placez dans ce répertoire les fichiers Project.toml et Manifest.toml. Ouvrez un terminal et démarrez Julia dans ce répertoire:\n\njulia&gt; ]                   # package mode\n(@v1.10) pkg&gt; activate .   # active l'environnement de ./Project.toml\n(@v1.10) pkg&gt; instantiate  # installe ou lie à l'environnement les packages spécifiques\n\nLes packages sont alors installés dans la version spécifiée dans les fichiers Project.toml et Manifest.toml dans l’environnement propre au répertoire biomaths/.\nPar la suite, vos scripts/notebooks commenceront par:\n\nusing Pkg         # utilise le gestionnaire de package\nPkg.activate(\".\") # active l'environnement local\n\n\n\nSi pour vos projets ultérieurs, vous souhaitez créer votre propre environnement, vous pouvez consuter cette page de la documentation.\nAllons-y !"
  }
]