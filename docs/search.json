[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Introduction",
    "section": "",
    "text": "Ces pages proposent une introduction à la simulation d’équations différentielles avec Julia, centrée sur la simulation de modèles classiques en dynamique des populations.\nCes pages sont structurées comme suit :\nLe site contient aussi du matétiel supplémentaire pour compléments plus avancés (graphiques, methodes d’intégration alternatives, équations de réaction-diffusion)."
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "A Propos",
    "section": "",
    "text": "Ces pages ont été générées avec Quarto, et Julia (version 1.9.4).\nLes principaux packages utilisés sont DifferentialEquations.jl, Plots.jl, DataFrames.jl, Makie.jl, Polynomials.jl et Symbolics.jl.\n\n\n\n\n\nReusehttps://creativecommons.org/licenses/by-nc/4.0/"
  },
  {
    "objectID": "pop_isolees.html",
    "href": "pop_isolees.html",
    "title": "Populations isolées",
    "section": "",
    "text": "Nous considérons le modèle proposé par Malthus (1798) : \n\\dot x = (n-m)x,\n\\tag{1} avec n le taux de natalité, et m le taux de mortalité.\n\n\nPour simuler ce modèle, c’est à dire intégrer numériquement les solutions au problème de Cauchy correspondant à l’Equation 1 avec x(0)=x_0\\geq0, nous allons utiliser les routines de DifferentialEquations.jl avec la méthode par défaut. Nous utiliserons aussi le package Plots.jl pour les représentations graphiques1.1 si vous n’avez jamais installé un package, il faudra commencer par le faire avant de pouvoir l’utiliser…\n\nusing Plots, DifferentialEquations\n\n\n\n\nNous définissions la condition initiale de la simulation :\n\nx0 = 0.1\n\nNous définissons les paramètres, et les encapsulons dans un vecteur de paramètres :\n\nn = 3.0     # natalité\nm = 2.0     # morrtalité\npar_malthus = [n, m] # packing\n\nEnfin, les propriétés du temps d’intégration :\n\ntspan = (0.0, 10.0)\ntstep = 0.1\n\n\n\n\nOn définit le modèle comme une fonction renvoyant la dérivée de x (comme SVector) en fonction de l’état, de paramètres, et du temps. L’ordre des arguments est important, c’est sous cette forme que les routines d’intégration attendent le modèle.\n\nfunction malthus(u, p, t)\n    n, m = p        # unpacking\n    x = u[1]        # use x notation\n    dx = (n-m)x     # return derivative\nend\n\n\n\n\nOn commence par définir le problème de Cauchy à intégrer, comme un ODEProblem avec arguments: le modèle, la condition initiale, les bornes d’intégration, les paramètres ainsi que l’option saveat = tstep permettant de récupérer la solution tout les tstep pas de temps (il y a plein d’options de sortie de l’intégration, dont même une fonction du temps !)\n\nprob_malthus = ODEProblem(malthus,          # modèle\n                          x0,               # condition initiale\n                          tspan,            # tspan\n                          par_malthus,      # paramètres\n                          saveat = tstep)   # option de sortie\n\nOn intègre le modèle via solve, défini par DifferentialEquations.jl pour des struct de type ODEProblem :\n\nsol_malthus = solve(prob_malthus)\n\nLe type de solution renvoyée par le solveur est assez complexe et comprend de nombreux champs informatifs sur le calcul. On peut accéder au temps de simulation via sol_malthus.t :\n\nfirst(sol_malthus.t, 3)\n\n3-element Vector{Float64}:\n 0.0\n 0.1\n 0.2\n\n\nainsi qu’aux valeurs de la variable x calculées le long du temps via sol_matlhus.u :\n\nfirst(sol_malthus.u, 3)\n\n3-element Vector{Float64}:\n 0.1\n 0.1105170918098962\n 0.12214028021690636\n\n\nMême si ce n’est pas indispensable, il est possible de transformer la solution renvoyée facilement en DataFrame, qui peut permettre des manipulations plus faciles.\n\nusing DataFrames\n\nsol_malthus = DataFrame(sol_malthus)\nrename!(sol_malthus, :timestamp =&gt; :time, :value =&gt; :x)\n\nsi bien que :\n\nfirst(sol_malthus, 3)\n\n3×2 DataFrame\n\n\n\nRow\ntime\nx\n\n\n\nFloat64\nFloat64\n\n\n\n\n1\n0.0\n0.1\n\n\n2\n0.1\n0.110517\n\n\n3\n0.2\n0.12214\n\n\n\n\n\n\n\n\n\nOn peut représenter graphiquement la simulation de la croissance de la population au cours du temps (ici via le dataframe).\n\nplot(sol_malthus.time, sol_malthus.x,\n    palette = :tab10,\n    linewidth = 2,\n    title = \"\\n Modèle de Malthus \\$n=$n, m=$m\\$\",\n    label = \"population \\$x\\$\",  \n    ylabel = \"densité de population \\$x(t)\\$\", \n    xlabel = \"temps \\$t\\$\",\n    margin = .5Plots.cm,\n    topmargin = 1Plots.cm)"
  },
  {
    "objectID": "pop_interactions.html",
    "href": "pop_interactions.html",
    "title": "Populations en interaction (1)",
    "section": "",
    "text": "Pour débuter cette partie sur les populations en interactions, nous reprenons le modèle de tordeuse de Ludwig, Jones, and Holling (1978) en supposant que la population d’oiseaux réagit (lentement) à la démographie des tordeuses, via la prédation.\nLe changement principal ici est la dimension du modèle (dimension 2) : les tailles de populations de tordeuses x et d’oiseaux y varient toutes deux au cours du temps en s’influençant l’une l’autre, avec une population d’oiseaux qui varie lentement (d’où le paramètre \\varepsilon).\nLe modèle prend la forme :\n\n\\left\\{\n\\begin{array}{l}\n\\displaystyle \\dot x = rx\\left(1-\\frac{x}{K}\\right) - \\frac{\\alpha x^2}{h^2+x^2}\\ y \\\\[.3cm]\n\\displaystyle \\dot y = \\varepsilon \\left(\\frac{n \\alpha x^2}{h^2+x^2}\\ y -m y\\right)\n\\end{array}\n\\right.\n\\tag{1}\nIl faut ajuster un peu la manière de coder pour prendre en compte ces deux dimensions. Commençons par les paramètres divers.\n\nusing DifferentialEquations, Plots, DataFrames\n\n# paramètres\nr = 5.0      # natalité\nK = 10.0     # mortalité\nα = 1.0      # taux max de prédation\nh = 0.5      # constante de demi-saturation\n\nϵ = 0.01     # timescale\nn = 5.0      # gain à la prédation\nm = 3.0      # moralité\n\n\npar_tord_ois = [r, K, α, h, ϵ, n, m] \n\n# temps d'intégration\ntspan = (0.0, 400.0)\ntstep = 0.02\n\n# conditions initiales\nx0 = 1.0    # tordeuses\ny0 = 2.5    # oiseaux\netat0 = [x0, y0]\n\nPuis le modèle :\n\nfunction tord_ois(u, param, t)\n    r, K, α, h, ϵ, n, m = param\n    x = u[1]\n    y = u[2]\n    dx = r*x*(1 - x/K) - α*x^2/(h^2 + x^2) * y\n    dy = ϵ*(n*α*x^2/(h^2 + x^2) * y - m * y)\n    [dx, dy]\nend\n\nProblème d’intégration et simulation :\n\nprob_tord_ois = ODEProblem(tord_ois, \n                           etat0, \n                           tspan, \n                           par_tord_ois, \n                           saveat = tstep)\n\nsol_tord_ois = solve(prob_tord_ois, reltol = 1e-6)\n\nsol_tord_ois = DataFrame(sol_tord_ois)\nrename!(sol_tord_ois, :timestamp =&gt; :time, :value1 =&gt; :x, :value2 =&gt; :y)\n\nReprésentation graphique contre le temps\n\n# color definitions\nmygreen = palette(:tab10)[3]\nmyorange = palette(:tab10)[2]\nmyblue = palette(:tab10)[1]\nmyred = palette(:tab10)[4]\n\nP1 = plot(sol_tord_ois.time, sol_tord_ois.x,\n          color = myblue,\n          linewidth = 2,\n          label = \"tordeuses \\$x\\$\",\n          xlabel = \"temps\",\n          ylabel = \"densités de populations\",\n          title = \"Dynamiques des tordeuses avec\\n population d'oiseaux variable\")\n\nplot!(P1, sol_tord_ois.time, sol_tord_ois.y ./ 2,\n      color = myorange,\n      linewidth = 2,\n      label = \"oiseaux \\$y/2\\$\")\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nOn observe ici des bifurcations dynamiques avec le passage de la population de tordeuse d’une branche d’équilibre stable à l’autre, qui créé un comportement de type cycle d’hysteresis. La situation se comprend bien sur le diagramme de bifurcations (y, x). On retrace le diagramme de bifurcations.\n\n\nCode\nusing Symbolics, Polynomials\n\n@variables X\nD = Differential(X)\n\n# lieu des équilibres positifs\nY = r/(α*X)*(1-X/K)*(h^2+X^2)\n\n# dénominateur de la dérivée\ndnumerator = Symbolics.arguments(Symbolics.value(simplify(expand_derivatives(D(Y)))))[1]\n\n# on récupère les coefficients X^k du polynôme\ncoefs_dict = Symbolics.value(dnumerator).dict\ndd = Dict(Symbolics.degree(first(kv)) =&gt; kv[2] for kv ∈ coefs_dict)\n# on rajoute dans le dictionnaire le coefficient constant\ndd[0] = substitute(dnumerator, Dict(X=&gt;0))\n\n# on définit le polynôme à partir du dictionnaire\ndnumpoly = SparsePolynomial(dd, :X)\n\n# on calcule les racines en filtrant les racines entre 0 et K via une fonction anonyme s-&gt; K &gt; s &gt; 0\ndroots = filter(s -&gt; K &gt; s &gt; 0, roots(dnumpoly))\n\n# vecteur pour le tracé du diagramme de bifurcation\nxplot1 = 0.08:.01:droots[1]\nxplot2 = droots[1]:.01:droots[2]\nxplot3 = droots[2]:.01:K\nyeq1 = r.*(1 .-xplot1./K) ./ (α.*xplot1).*(h^2 .+xplot1.^2)\nyeq2 = r.*(1 .-xplot2./K) ./ (α.*xplot2).*(h^2 .+xplot2.^2)\nyeq3 = r.*(1 .-xplot3./K) ./ (α.*xplot3).*(h^2 .+xplot3.^2)\n\n# diagramme de bifurcations\nPbif = plot(yeq1, xplot1,\n            linewidth = 2,\n            color = mygreen,\n            label = \"équilibres stables\",\n            legend = :left,\n            xlabel = \"population d'oiseaux \\$y\\$\",\n            ylabel = \"population de tordeuses \\$x\\$\",\n            title = \"Diagramme de bifurcations pour le modèle de tordeuses\",\n            margin = .5Plots.cm,\n            topmargin = 1Plots.cm)\n\nplot!(Pbif, yeq2, xplot2,\n      linewidth = 2,\n      color = myred,\n      label = \"équilibres instables\")\n\nplot!(Pbif, yeq3, xplot3,\n      linewidth = 2,\n      color = mygreen,\n      label = \"\")\n\nplot!(Pbif, [0, maximum(yeq1)], [0, 0], \n      color = myred,\n      lw = 2,\n      label = \"\")\n\n\nOn trace sur ce diagramme la trajectoire simulée plus haut :\n\nplot!(Pbif, sol_tord_ois.y, sol_tord_ois.x,\n      color = myblue,\n      linewidth = 2,\n      linealpha = 0.5,\n      label = \"trajectoire\")"
  },
  {
    "objectID": "pop_exploitees.html",
    "href": "pop_exploitees.html",
    "title": "Populations exploitées",
    "section": "",
    "text": "Nous reprenons le modèle précédent sur l’effet Allee mais en prenant en compte des prélèvements externes avec un effort (taux) de prélèvement E : \n\\dot x = r x \\left(\\frac{x}{\\epsilon}-1\\right)\\left(1-\\frac{x}{K}\\right)-Ex.\n\\tag{1}\nLa simulation de ce modèle pour différentes valeurs de E (par exemple E=0.2 ou E=0.85) ne présente aucune difficulté supplémentaire.\nNous allons maintenant nous intéresser à une situation où l’effort de prélèvement E varie au cours du temps entre une valeur soutenable E_s (par exemple 0.2), et une valeur excessive E_x (par exemple 0.85).\nL’attendu théorique est que si les prélèvements sont maintenus à une valeur excessive E_x trop longtemps, la population disparait irrémédiablement même si les prélèvements sont par la suite ramenés à une valeur initialement soutenable E_s.\n\n\n\nusing DifferentialEquations, Plots, DataFrames\n\nDéfinissons une fonction effort() dépendant du temps, qui renvoit :\n\nE_s~ si ~t&lt;T_s\nE_x~ si ~t\\in [T_s+T_x[\nà nouveau E_s~ si ~t\\geq T_s+T_x\n\n\n# paramètres\nE_s = 0.2\nE_x = 0.85\nT_s = 10.0\nT_x = 9.0 \n\npar_effort = [E_s, E_x, T_s, T_x]\n\nfunction effort(t, pars)\n    E_s, E_x, T_s, T_x = pars\n\n    if t &lt; T_s || t &gt;= T_s + T_x\n        return E_s\n    elseif t &gt;= T_s && t &lt; T_s + T_x\n        return E_x\n    end\nend\n\nLa fonction correspond bien à nos hypothèses :\n\n\nCode\ntime2plot = 0: .1: 30\n\nplot(time2plot, [effort(t, par_effort) for t in time2plot],\n     palette = :tab10,\n     linewidth = 2,\n     label = \"\\$E(t)\\$\",\n     xlabel = \"temps\",\n     ylabel = \"\\$E(t)\\$\",\n     title = \"Effort de pêche \\$E(t)\\$\",\n     margin = .5Plots.cm,\n     topmargin = 1Plots.cm)\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNous définissons les paramètres du modèle, la condition initiale et le temps d’intégration :\n\n\nCode\nx0 = 10.\n\ntspan = (0.0, 30.0)\ntstep = 0.1\n\nr = 1.\nK = 10.\nepsilon = 2.                 # seuil de Allee\npar_allee = [r, K, epsilon] # packing\ntspan_allee = (0.0, 3.0)\n\n\nNous définissons le système dynamique comme précédemment, à la différence que nous prévoyons de surcharger l’argument p dans le problème d’intégration sous forme d’un vecteur comprennant :\n\nle vecteur de paramètres par_allee en première position\nle vecteur de paramètres par_effort en seconde position\net la fonction effort en troisième position\n\n\nfunction allee_evar(u, p, t)\n    r, K, epsilon = p[1]        # unpacking model parameters\n    par_effort = p[2]           # unpacking fishing effort parameters\n    E = p[3]                    # unpacking fishing effort function\n    x = u[1]                    # use x notation\n    \n    dx = r*x*(x/epsilon - 1)*(1 - x/K) - E(t, par_effort)*x\nend\n\nL’intégration en elle-même suit le shéma vu précédemment, si ce n’est que l’argument de paramètres doit bien refléter ce qui est attendu par la fonction allee_evar(). La simulation en elle-même est effectuée avec une modification de la précision relative de l’intégration reltol = 1e-6, la précision par défaut n’étant pas suffisante ici.\n\nprob_allee_evar = ODEProblem(allee_evar, \n                             x0, \n                             tspan, \n                             [par_allee, par_effort, effort], \n                             saveat = tstep)\n\nsol_allee_evar = solve(prob_allee_evar, reltol = 1e-6)\n\nsol_allee_evar = DataFrame(sol_allee_evar)\nrename!(sol_allee_evar, :timestamp =&gt; :time, :value =&gt; :x)\n\nFinalement, nous pouvons représenter graphiquement la solution contre le temps. Ici, malgré la perturbation violente induite par la période de surexploitation, le pêcherie retrouve une situation soutenable après un retour à E=E_s.\n\n\nCode\nplot(sol_allee_evar.time, sol_allee_evar.x,\n     label = \"\\$x(t)\\$\",\n     linewidth = 2,\n     xlabel = \"temps\",\n     ylabel = \"densité de population \\$x(t)\\$\",\n     title = \"Effort de pêche variant dans le temps\",\n     palette = :tab10,\n     legend = :left,\n     margin = .5Plots.cm,\n     topmargin = 1Plots.cm)\n\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 1: Persistence dans le modèle avec effet Allee et prélèvements\n\n\n\n\n\nLorsque la période de surexploitation de la population est trop longue (e.g. ici T_x=9.2), la population ne parvient pas à récupérer malgré le retour à un effort de prélèvements soutenable.\n\n\nCode\n# change parameter\nT_x2 = 9.2\n\npar_effort2 = [E_s, E_x, T_s, T_x2]\n\n# define new problem and integrate\nprob_allee_evar2 = ODEProblem(allee_evar, \n                             x0, \n                             tspan, \n                             [par_allee, par_effort2, effort], \n                             saveat = tstep)\n\nsol_allee_evar2 = solve(prob_allee_evar2, reltol = 1e-6)\n\nsol_allee_evar2 = DataFrame(sol_allee_evar2)\nrename!(sol_allee_evar2, :timestamp =&gt; :time, :value =&gt; :x)\n\n# plot\nplot(sol_allee_evar2.time, sol_allee_evar2.x,\n     label = \"\\$x(t)\\$\",\n     linewidth = 2,\n     xlabel = \"temps\",\n     ylabel = \"densité de population \\$x(t)\\$\",\n     title = \"Effort de pêche variant dans le temps\",\n     palette = :tab10,\n     legend = :left,\n     margin = .5Plots.cm,\n     topmargin = 1Plots.cm)\n\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 2: Extinction dans le modèle avec effet Allee et prélèvements\n\n\n\n\n\n\nIl s’agit ici de représenter dans l’espace (E, x) l’évolution conjointe de l’effort de pêche et de la densité de la population au cours du temps, afin de mieux comprendre le phénomène d’extinction. Dans cet objectif, on tracera aussi le lieu des équilibres de la population x^*(E) en fonction d’une valeur de E constante, i.e. : \nx^*(E) = 0,\n ou : \nE = r\\left(\\frac{x^*(E)}{\\epsilon}-1\\right)\\left(1-\\frac{x^*(E)}{K}\\right).\n\nNous allons tracer les situations dans 2 sous figures. Commençons par les lieux des équilibres :\n\n# vecteurs pour le tracé\ne2plot = 0:.1:1\nx2plot1 = epsilon:.02:(K+epsilon)/2\nx2plot2 = (K+epsilon)/2:.02:K\n\n# parabole pour les equilibres positifs\nfunction eeqpos(x, par = par_allee)\n        r, K, epsilon = par\n\n        r*(x/epsilon -1)*(1-x/K)\nend\n\n# on définit des couleurs spécifiques depuis la palette :pal10\nmygreen = palette(:tab10)[3]\nmyorange = palette(:tab10)[2]\nmyblue = palette(:tab10)[1]\nmyred = palette(:tab10)[4]\n\n# plot\nP1 = plot(e2plot, zeros(length(e2plot)),\n          color = mygreen,\n          linewidth = 2,\n          label = \"équilibres stables\",\n          ylabel = \"densité de population \\$x\\$\",\n          xlabel = \"effort de pêche \\$E\\$\",\n          legend = :left)\n        #   margin = .5Plots.cm,\n        #   topmargin = 1Plots.cm)\n\nplot!(P1, eeqpos.(x2plot1), x2plot1, \n          color= myorange,\n          linewidth = 2,\n          label = \"équilibre instable\")\n\nplot!(P1, eeqpos.(x2plot2), x2plot2, \n          color= mygreen,\n          linewidth = 2,\n          label =\"\")\n\ndisplay(P1)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nOn prépare un graphique P2 avec les mêmes éléments :\n\nP2 = deepcopy(P1) # évite de tout retaper...\n\nOn complète P1 et P2 avec quelques annotations et les trajectoires calculées plus haut en fonction de l’effort de pêche variable au cours du temps, et on trace les résultats en deux sous-figures :\n\nannotate!(P1, .35, 8.5, Plots.text(\"branche stable\", 10, rotation=-28))\nannotate!(P1, .4, 2.7, Plots.text(\"branche instable\", 10, rotation=28))\nannotate!(P2, .4, 2.7, Plots.text(\"branche instable\", 10, rotation=28))\nannotate!(P2, .35, 8.5, Plots.text(\"branche stable\", 10, rotation=-28))\n\nplot!(P1, [effort(t, par_effort) for t in sol_allee_evar.time], sol_allee_evar.x,\n      color = myblue, \n      linewidth = 2,\n      label = \"trajectory\")\n\nplot!(P2, [effort(t, par_effort2) for t in sol_allee_evar2.time], sol_allee_evar2.x,\n      color = myblue, \n      linewidth = 2,\n      label = \"trajectory\")\n\nplot(P1, P2, suptitle = \"Effets Allee et prélèvements\",\n     margin = .5Plots.cm,\n     topmargin = 1Plots.cm)\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\nFigure 3: bifurcation pli et catastrophe dans le modèle avec effet Allee et prélèvements"
  },
  {
    "objectID": "pop_isolees.html#sec-malthus",
    "href": "pop_isolees.html#sec-malthus",
    "title": "Populations isolées",
    "section": "",
    "text": "Nous considérons le modèle proposé par Malthus (1798) : \n\\dot x = (n-m)x,\n\\tag{1} avec n le taux de natalité, et m le taux de mortalité.\n\n\nPour simuler ce modèle, c’est à dire intégrer numériquement les solutions au problème de Cauchy correspondant à l’Equation 1 avec x(0)=x_0\\geq0, nous allons utiliser les routines de DifferentialEquations.jl avec la méthode par défaut. Nous utiliserons aussi le package Plots.jl pour les représentations graphiques1.1 si vous n’avez jamais installé un package, il faudra commencer par le faire avant de pouvoir l’utiliser…\n\nusing Plots, DifferentialEquations\n\n\n\n\nNous définissions la condition initiale de la simulation :\n\nx0 = 0.1\n\nNous définissons les paramètres, et les encapsulons dans un vecteur de paramètres :\n\nn = 3.0     # natalité\nm = 2.0     # morrtalité\npar_malthus = [n, m] # packing\n\nEnfin, les propriétés du temps d’intégration :\n\ntspan = (0.0, 10.0)\ntstep = 0.1\n\n\n\n\nOn définit le modèle comme une fonction renvoyant la dérivée de x (comme SVector) en fonction de l’état, de paramètres, et du temps. L’ordre des arguments est important, c’est sous cette forme que les routines d’intégration attendent le modèle.\n\nfunction malthus(u, p, t)\n    n, m = p        # unpacking\n    x = u[1]        # use x notation\n    dx = (n-m)x     # return derivative\nend\n\n\n\n\nOn commence par définir le problème de Cauchy à intégrer, comme un ODEProblem avec arguments: le modèle, la condition initiale, les bornes d’intégration, les paramètres ainsi que l’option saveat = tstep permettant de récupérer la solution tout les tstep pas de temps (il y a plein d’options de sortie de l’intégration, dont même une fonction du temps !)\n\nprob_malthus = ODEProblem(malthus,          # modèle\n                          x0,               # condition initiale\n                          tspan,            # tspan\n                          par_malthus,      # paramètres\n                          saveat = tstep)   # option de sortie\n\nOn intègre le modèle via solve, défini par DifferentialEquations.jl pour des struct de type ODEProblem :\n\nsol_malthus = solve(prob_malthus)\n\nLe type de solution renvoyée par le solveur est assez complexe et comprend de nombreux champs informatifs sur le calcul. On peut accéder au temps de simulation via sol_malthus.t :\n\nfirst(sol_malthus.t, 3)\n\n3-element Vector{Float64}:\n 0.0\n 0.1\n 0.2\n\n\nainsi qu’aux valeurs de la variable x calculées le long du temps via sol_matlhus.u :\n\nfirst(sol_malthus.u, 3)\n\n3-element Vector{Float64}:\n 0.1\n 0.1105170918098962\n 0.12214028021690636\n\n\nMême si ce n’est pas indispensable, il est possible de transformer la solution renvoyée facilement en DataFrame, qui peut permettre des manipulations plus faciles.\n\nusing DataFrames\n\nsol_malthus = DataFrame(sol_malthus)\nrename!(sol_malthus, :timestamp =&gt; :time, :value =&gt; :x)\n\nsi bien que :\n\nfirst(sol_malthus, 3)\n\n3×2 DataFrame\n\n\n\nRow\ntime\nx\n\n\n\nFloat64\nFloat64\n\n\n\n\n1\n0.0\n0.1\n\n\n2\n0.1\n0.110517\n\n\n3\n0.2\n0.12214\n\n\n\n\n\n\n\n\n\nOn peut représenter graphiquement la simulation de la croissance de la population au cours du temps (ici via le dataframe).\n\nplot(sol_malthus.time, sol_malthus.x,\n    palette = :tab10,\n    linewidth = 2,\n    title = \"\\n Modèle de Malthus \\$n=$n, m=$m\\$\",\n    label = \"population \\$x\\$\",  \n    ylabel = \"densité de population \\$x(t)\\$\", \n    xlabel = \"temps \\$t\\$\",\n    margin = .5Plots.cm,\n    topmargin = 1Plots.cm)"
  },
  {
    "objectID": "pop_isolees.html#préliminaires",
    "href": "pop_isolees.html#préliminaires",
    "title": "Populations isolées",
    "section": "Préliminaires",
    "text": "Préliminaires\nPour simuler ce modèle, c’est à dire intégrer numériquement les solutions au problème de Cauchy correspondant à l’Equation 1 avec x(0)=x_0\\geq0, nous allons utiliser les routines de DifferentialEquations.jl avec une méthode utilisant des tableaux statiques pour la rapidité d’exécution (package StaticArrays.jl). Nous utiliserons aussi le package Plots.jl pour les représentations graphiques.\n\nusing Plots, DifferentialEquations, StaticArrays"
  },
  {
    "objectID": "pop_isolees.html#conditions-initiales-paramètres-et-temps",
    "href": "pop_isolees.html#conditions-initiales-paramètres-et-temps",
    "title": "Populations isolées",
    "section": "Conditions initiales, paramètres et temps",
    "text": "Conditions initiales, paramètres et temps\nNous définissions la condition initiale de la simulation, et l’assignons dans un vecteur statique etat0 :\n\nx0 = 0.1\netat0 = @SVector [x0]\n\nNous définissons les paramètres, et les encapsulons dans un vecteur de paramètres :\n\nn = 3.0     # natalité\nm = 2.0     # morrtalité\npar_malthus = [n, m]\n\nEnfin, les propriétés du temps d’intégration :\n\ntspan = (0.0, 5.0)\ntstep = 0.1"
  },
  {
    "objectID": "pop_isolees.html#section",
    "href": "pop_isolees.html#section",
    "title": "Populations isolées",
    "section": "",
    "text": "On peut représenter graphiquement la simulation de la croissance de la population au cours du temps (ici via le dataframe).\n\nplot(sol_malthus.time, sol_malthus.x,\n    palette = :tab10,\n    linewidth = 2,\n    title = \"\\n Modèle de Malthus\",\n    label = \"population \" * L\"x\",  # latex strings, makrdown latex is off in labels\n    ylabel = \"densité de population \\$x(t)\\$\", # latex markdown is ok in axis label\n    xlabel = \"temps \\$t\\$\",\n    margin = .5Plots.cm,\n    topmargin = 1Plots.cm)"
  },
  {
    "objectID": "pop_isolees.html#sec-logistic",
    "href": "pop_isolees.html#sec-logistic",
    "title": "Populations isolées",
    "section": "Le modèle logistique",
    "text": "Le modèle logistique\nNous considérons ici le modèle “logistique” proposé par Verhulst (1838) :\n\n\\dot x = r x \\left(1-\\frac{x}{K}\\right),\n\\tag{2} avec r le taux de croissance intrinsèque de la population et K la capacité de charge de l’environnement.\nIl n’y a pas de difficulté particulière par rapport aux simulations précedentes. On va réutiliser la condition initiale et les paramètres de temps définis précédemment.\nIl faut cependant définir les paramètres du modèle Equation 2 :\n\n\nCode\nr = 1.0      # natalité\nK = 10.0     # morrtalité\npar_logistic = [r, K] # packing\n\n\nainsi que le nouveau système dynamique :\n\n\nCode\nfunction logistic(u, p, t)\n    r, K = p            # unpacking\n    x = u[1]            # use x notation\n    dx = r*x*(1-x/K)    # return derivative\nend\n\n\net le problème de Cauchy correspondant :\n\n\nCode\nprob_logistic = ODEProblem(logistic,        # modèle\n                          x0,               # condition initiale\n                          tspan,            # tspan\n                          par_logistic,     # paramètres\n                          saveat = tstep)   # option de sortie\n\n\nOn simule et on transforme la solution en dataframe :\n\n\nCode\nsol_logistic = solve(prob_logistic)\n\nsol_logistic = DataFrame(sol_logistic)\nrename!(sol_logistic, :timestamp =&gt; :time, :value =&gt; :x)\n\n\nOn trace la solution, en rajoutant les équilibres stable (x=K) et instable (x=0) :\n\n\nCode\n# solution\nplot(sol_logistic.time, sol_logistic.x,\n    palette = :tab10,\n    linewidth = 2,\n    title = \"\\n Modèle logistique \\$r=$r, K=$K\\$\",\n    label = \"population \\$x\\$\",  \n    legend = :right,\n    ylabel = \"densité de population \\$x(t)\\$\", \n    xlabel = \"temps \\$t\\$\",\n    margin = .5Plots.cm,\n    topmargin = 1Plots.cm)\n\n# équilibre 0\nplot!(sol_logistic.time, zeros(length(sol_logistic.time)),\n      color = \"red\",\n      linewidth = 2,\n      linestyle = :dash,\n      linealpha = .5,\n      label = \"équilibre instable\")\n\n# équilibre 1\nplot!(sol_logistic.time, ones(length(sol_logistic.time)).*K,\n      color = \"green\",\n      linewidth = 2,\n      linestyle = :dash,\n      linealpha = .5,\n      label = \"équilibre stable\")"
  },
  {
    "objectID": "pop_isolees.html#effets-allee",
    "href": "pop_isolees.html#effets-allee",
    "title": "Populations isolées",
    "section": "Effets Allee",
    "text": "Effets Allee"
  },
  {
    "objectID": "pop_isolees.html#sec-allee",
    "href": "pop_isolees.html#sec-allee",
    "title": "Populations isolées",
    "section": "Effets Allee",
    "text": "Effets Allee\nOn s’intéresse à un modèle de dynamique de population avec “effets Allee forts”, souvent attribué à Gruntfest, Arditi, and Dombrovsky (1997)2 :2 mais de nombreuses variations de cette forme polynomiale existent dans la littérature depuis Bazykin (1985)\n\n\\dot x = r x \\left(\\frac{x}{\\epsilon}-1\\right)\\left(1-\\frac{x}{K}\\right),\n\\tag{3} avec r le taux de croissance intrinsèque de la population (par analogie avec la logistique), K la capacité de charge de l’environnement et \\epsilon le seuil en dessous duquel la population n’est pas viable (‘seuil de Allee’).\nNous souhaitons illustrer la bistabilité caractéristique du comportement de ce modèle à partir de la simulation depuis plusieurs conditions initiales.\nCommençons par définir le modèle et les paramètres (en conservant les r et K précédents):\n\n\nCode\nepsilon = 2                 # seuil de Allee\npar_allee = [r, K, epsilon] # packing\ntspan_allee = (0.0, 3.0)\n\nfunction allee(u, p, t)\n    r, K, epsilon = p        # unpacking\n    x = u[1]                 # use x notation\n    dx = r*x*(x/epsilon - 1)*(1 - x/K)     # return derivative\nend\n\n\nNous définissons une fonction qui réalise une simulation en un seul appel :\n\nfunction int_allee(x0, tspan = tspan_allee, param = par_allee)\n    prob_allee = ODEProblem(allee,          # modèle\n                          x0,               # condition initiale\n                          tspan,            # tspan\n                          param,            # paramètres\n                          saveat = tstep)   # option de sortie\n    \n    sol_allee = solve(prob_allee)\n    sol_allee = DataFrame(sol_allee)\n    rename!(sol_allee, :timestamp =&gt; :time, :value =&gt; :x)\nend\n\nNous définissons un vecteur de conditions initiales différentes :\n\nx0step = 1.35\nx0vec = x0step:x0step:K\n\nFinalement on réalise la figure, en initiant un graphique P et en faisant une boucle pour tracer chacune des simulations correspondant aux différentes conditions initiales :\n\n# custom color palette\ninit_cgrad = palette([:steelblue, :lightblue], length(x0vec))\n\n# initialisation du graphique\nP = plot(palette = init_cgrad,\n         title = \"\\n Modèle à effets Allee \\$r=$r, K=$K\\$, \\$ϵ=$epsilon\\$\",\n         legend = :right,\n         ylabel = \"densité de population \\$x(t)\\$\", \n         xlabel = \"temps \\$t\\$\",\n         margin = .5Plots.cm,\n         topmargin = 1Plots.cm)\n\n# boucle de plot avec intégration pour differentes conditions initiales\nfor x0 in x0vec\n    plot!(P, int_allee(x0).time, int_allee(x0).x,\n          linewidth = 2,\n          label = \"\")\nend\n\n# équilibres\nplot!(P, int_allee(0).time, zeros(length(int_allee(0).time)),\n      color = \"green\",\n      linewidth = 2,\n      linestyle = :dash,\n      linealpha = .5,\n      label = \"équilibre stable\")\nplot!(P, int_allee(0).time, ones(length(int_allee(0).time)).*epsilon,\n      color = \"red\",\n      linewidth = 2,\n      linestyle = :dash,\n      linealpha = .5,\n      label = \"équilibre instable\")\nplot!(P, int_allee(0).time, ones(length(int_allee(0).time)).*K,\n      color = \"green\",\n      linewidth = 2,\n      linestyle = :dash,\n      linealpha = .5,\n      label = \"\")\n\ndisplay(P)      # actually shows the plot P\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPassons aux populations exploitées."
  },
  {
    "objectID": "pop_exploitees.html#sec-allee-prelev",
    "href": "pop_exploitees.html#sec-allee-prelev",
    "title": "Populations exploitées",
    "section": "",
    "text": "Nous reprenons le modèle précédent sur l’effet Allee mais en prenant en compte des prélèvements externes avec un effort (taux) de prélèvement E : \n\\dot x = r x \\left(\\frac{x}{\\epsilon}-1\\right)\\left(1-\\frac{x}{K}\\right)-Ex.\n\\tag{1}\nLa simulation de ce modèle pour différentes valeurs de E (par exemple E=0.2 ou E=0.85) ne présente aucune difficulté supplémentaire.\nNous allons maintenant nous intéresser à une situation où l’effort de prélèvement E varie au cours du temps entre une valeur soutenable E_s (par exemple 0.2), et une valeur excessive E_x (par exemple 0.85).\nL’attendu théorique est que si les prélèvements sont maintenus à une valeur excessive E_x trop longtemps, la population disparait irrémédiablement même si les prélèvements sont par la suite ramenés à une valeur initialement soutenable E_s.\n\n\n\nusing DifferentialEquations, Plots, DataFrames\n\nDéfinissons une fonction effort() dépendant du temps, qui renvoit :\n\nE_s~ si ~t&lt;T_s\nE_x~ si ~t\\in [T_s+T_x[\nà nouveau E_s~ si ~t\\geq T_s+T_x\n\n\n# paramètres\nE_s = 0.2\nE_x = 0.85\nT_s = 10.0\nT_x = 9.0 \n\npar_effort = [E_s, E_x, T_s, T_x]\n\nfunction effort(t, pars)\n    E_s, E_x, T_s, T_x = pars\n\n    if t &lt; T_s || t &gt;= T_s + T_x\n        return E_s\n    elseif t &gt;= T_s && t &lt; T_s + T_x\n        return E_x\n    end\nend\n\nLa fonction correspond bien à nos hypothèses :\n\n\nCode\ntime2plot = 0: .1: 30\n\nplot(time2plot, [effort(t, par_effort) for t in time2plot],\n     palette = :tab10,\n     linewidth = 2,\n     label = \"\\$E(t)\\$\",\n     xlabel = \"temps\",\n     ylabel = \"\\$E(t)\\$\",\n     title = \"Effort de pêche \\$E(t)\\$\",\n     margin = .5Plots.cm,\n     topmargin = 1Plots.cm)\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNous définissons les paramètres du modèle, la condition initiale et le temps d’intégration :\n\n\nCode\nx0 = 10.\n\ntspan = (0.0, 30.0)\ntstep = 0.1\n\nr = 1.\nK = 10.\nepsilon = 2.                 # seuil de Allee\npar_allee = [r, K, epsilon] # packing\ntspan_allee = (0.0, 3.0)\n\n\nNous définissons le système dynamique comme précédemment, à la différence que nous prévoyons de surcharger l’argument p dans le problème d’intégration sous forme d’un vecteur comprennant :\n\nle vecteur de paramètres par_allee en première position\nle vecteur de paramètres par_effort en seconde position\net la fonction effort en troisième position\n\n\nfunction allee_evar(u, p, t)\n    r, K, epsilon = p[1]        # unpacking model parameters\n    par_effort = p[2]           # unpacking fishing effort parameters\n    E = p[3]                    # unpacking fishing effort function\n    x = u[1]                    # use x notation\n    \n    dx = r*x*(x/epsilon - 1)*(1 - x/K) - E(t, par_effort)*x\nend\n\nL’intégration en elle-même suit le shéma vu précédemment, si ce n’est que l’argument de paramètres doit bien refléter ce qui est attendu par la fonction allee_evar(). La simulation en elle-même est effectuée avec une modification de la précision relative de l’intégration reltol = 1e-6, la précision par défaut n’étant pas suffisante ici.\n\nprob_allee_evar = ODEProblem(allee_evar, \n                             x0, \n                             tspan, \n                             [par_allee, par_effort, effort], \n                             saveat = tstep)\n\nsol_allee_evar = solve(prob_allee_evar, reltol = 1e-6)\n\nsol_allee_evar = DataFrame(sol_allee_evar)\nrename!(sol_allee_evar, :timestamp =&gt; :time, :value =&gt; :x)\n\nFinalement, nous pouvons représenter graphiquement la solution contre le temps. Ici, malgré la perturbation violente induite par la période de surexploitation, le pêcherie retrouve une situation soutenable après un retour à E=E_s.\n\n\nCode\nplot(sol_allee_evar.time, sol_allee_evar.x,\n     label = \"\\$x(t)\\$\",\n     linewidth = 2,\n     xlabel = \"temps\",\n     ylabel = \"densité de population \\$x(t)\\$\",\n     title = \"Effort de pêche variant dans le temps\",\n     palette = :tab10,\n     legend = :left,\n     margin = .5Plots.cm,\n     topmargin = 1Plots.cm)\n\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 1: Persistence dans le modèle avec effet Allee et prélèvements\n\n\n\n\n\nLorsque la période de surexploitation de la population est trop longue (e.g. ici T_x=9.2), la population ne parvient pas à récupérer malgré le retour à un effort de prélèvements soutenable.\n\n\nCode\n# change parameter\nT_x2 = 9.2\n\npar_effort2 = [E_s, E_x, T_s, T_x2]\n\n# define new problem and integrate\nprob_allee_evar2 = ODEProblem(allee_evar, \n                             x0, \n                             tspan, \n                             [par_allee, par_effort2, effort], \n                             saveat = tstep)\n\nsol_allee_evar2 = solve(prob_allee_evar2, reltol = 1e-6)\n\nsol_allee_evar2 = DataFrame(sol_allee_evar2)\nrename!(sol_allee_evar2, :timestamp =&gt; :time, :value =&gt; :x)\n\n# plot\nplot(sol_allee_evar2.time, sol_allee_evar2.x,\n     label = \"\\$x(t)\\$\",\n     linewidth = 2,\n     xlabel = \"temps\",\n     ylabel = \"densité de population \\$x(t)\\$\",\n     title = \"Effort de pêche variant dans le temps\",\n     palette = :tab10,\n     legend = :left,\n     margin = .5Plots.cm,\n     topmargin = 1Plots.cm)\n\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 2: Extinction dans le modèle avec effet Allee et prélèvements\n\n\n\n\n\n\nIl s’agit ici de représenter dans l’espace (E, x) l’évolution conjointe de l’effort de pêche et de la densité de la population au cours du temps, afin de mieux comprendre le phénomène d’extinction. Dans cet objectif, on tracera aussi le lieu des équilibres de la population x^*(E) en fonction d’une valeur de E constante, i.e. : \nx^*(E) = 0,\n ou : \nE = r\\left(\\frac{x^*(E)}{\\epsilon}-1\\right)\\left(1-\\frac{x^*(E)}{K}\\right).\n\nNous allons tracer les situations dans 2 sous figures. Commençons par les lieux des équilibres :\n\n# vecteurs pour le tracé\ne2plot = 0:.1:1\nx2plot1 = epsilon:.02:(K+epsilon)/2\nx2plot2 = (K+epsilon)/2:.02:K\n\n# parabole pour les equilibres positifs\nfunction eeqpos(x, par = par_allee)\n        r, K, epsilon = par\n\n        r*(x/epsilon -1)*(1-x/K)\nend\n\n# on définit des couleurs spécifiques depuis la palette :pal10\nmygreen = palette(:tab10)[3]\nmyorange = palette(:tab10)[2]\nmyblue = palette(:tab10)[1]\nmyred = palette(:tab10)[4]\n\n# plot\nP1 = plot(e2plot, zeros(length(e2plot)),\n          color = mygreen,\n          linewidth = 2,\n          label = \"équilibres stables\",\n          ylabel = \"densité de population \\$x\\$\",\n          xlabel = \"effort de pêche \\$E\\$\",\n          legend = :left)\n        #   margin = .5Plots.cm,\n        #   topmargin = 1Plots.cm)\n\nplot!(P1, eeqpos.(x2plot1), x2plot1, \n          color= myorange,\n          linewidth = 2,\n          label = \"équilibre instable\")\n\nplot!(P1, eeqpos.(x2plot2), x2plot2, \n          color= mygreen,\n          linewidth = 2,\n          label =\"\")\n\ndisplay(P1)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nOn prépare un graphique P2 avec les mêmes éléments :\n\nP2 = deepcopy(P1) # évite de tout retaper...\n\nOn complète P1 et P2 avec quelques annotations et les trajectoires calculées plus haut en fonction de l’effort de pêche variable au cours du temps, et on trace les résultats en deux sous-figures :\n\nannotate!(P1, .35, 8.5, Plots.text(\"branche stable\", 10, rotation=-28))\nannotate!(P1, .4, 2.7, Plots.text(\"branche instable\", 10, rotation=28))\nannotate!(P2, .4, 2.7, Plots.text(\"branche instable\", 10, rotation=28))\nannotate!(P2, .35, 8.5, Plots.text(\"branche stable\", 10, rotation=-28))\n\nplot!(P1, [effort(t, par_effort) for t in sol_allee_evar.time], sol_allee_evar.x,\n      color = myblue, \n      linewidth = 2,\n      label = \"trajectory\")\n\nplot!(P2, [effort(t, par_effort2) for t in sol_allee_evar2.time], sol_allee_evar2.x,\n      color = myblue, \n      linewidth = 2,\n      label = \"trajectory\")\n\nplot(P1, P2, suptitle = \"Effets Allee et prélèvements\",\n     margin = .5Plots.cm,\n     topmargin = 1Plots.cm)\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\nFigure 3: bifurcation pli et catastrophe dans le modèle avec effet Allee et prélèvements"
  },
  {
    "objectID": "pop_exploitees.html#prélèvements-variables-dans-le-temps",
    "href": "pop_exploitees.html#prélèvements-variables-dans-le-temps",
    "title": "Populations exploitées",
    "section": "",
    "text": "using DifferentialEquations, Plots, DataFrames\n\nDéfinissons une fonction effort() dépendant du temps, qui renvoit :\n\nE_s~ si ~t&lt;T_s\nE_x~ si ~t\\in [T_s+T_x[\nà nouveau E_s~ si ~t\\geq T_s+T_x\n\n\n# paramètres\nE_s = 0.2\nE_x = 0.85\nT_s = 10.0\nT_x = 9.0\n\npar_effort = [E_s, E_x, T_s, T_x]\n\nfunction effort(t, pars)\n    E_s, E_x, T_s, T_x = pars\n\n    if t &lt; T_s || t &gt;= T_s + T_x\n        return E_s\n    elseif t &gt;= T_s && t &lt; T_s + T_x\n        return E_x\n    end\nend\n\nLa fonction correspond bien à nos hypothèses :\n\n\nCode\ntime2plot = 0: .1: 30\n\nplot(time2plot, [effort(t, par_effort) for t in time2plot],\n     palette = :tab10,\n     linewidth = 2,\n     label = \"\\$E(t)\\$\",\n     xlabel = \"temps\",\n     ylabel = \"\\$E(t)\\$\",\n     title = \"Effort de pêche \\$E(t)\\$\",\n     margin = .5Plots.cm,\n     topmargin = 1Plots.cm)"
  },
  {
    "objectID": "pop_exploitees.html#simulations-en-fonction-du-temps",
    "href": "pop_exploitees.html#simulations-en-fonction-du-temps",
    "title": "Populations exploitées",
    "section": "",
    "text": "Nous définissons les paramètres du modèle, la condition initiale et le temps d’intégration :\n\n\nCode\nx0 = 10.\n\ntspan = (0.0, 30.0)\ntstep = 0.1\n\nr = 1.\nK = 10.\nepsilon = 2.                 # seuil de Allee\npar_allee = [r, K, epsilon] # packing\ntspan_allee = (0.0, 3.0)\n\n\nNous définissons le système dynamique comme précédemment, à la différence que nous prévoyons de surcharger l’argument p dans le problème d’intégration sous forme d’un vecteur comprennant :\n\nle vecteur de paramètres par_allee en première position\nle vecteur de paramètres par_effort en seconde position\net la fonction effort en troisième position\n\n\nfunction allee_evar(u, p, t)\n    r, K, epsilon = p[1]        # unpacking model parameters\n    par_effort = p[2]           # unpacking fishing effort parameters\n    E = p[3]                    # unpacking fishing effort function\n    x = u[1]                    # use x notation\n    \n    dx = r*x*(x/epsilon - 1)*(1 - x/K) - E(t, par_effort)*x\nend\n\nL’intégration en elle-même suit le shéma vu précédemment, si ce n’est que l’argument de paramètres doit bien refléter ce qui est attendu par la fonction allee_evar(). La simulation en elle-même est effectuée avec une modification de la précision relative de l’intégration reltol = 1e-6, la précision par défaut n’étant pas suffisante ici.\n\nprob_allee_evar = ODEProblem(allee_evar, \n                             x0, \n                             tspan, \n                             [par_allee, par_effort, effort], \n                             saveat = tstep)\n\nsol_allee_evar = solve(prob_allee_evar, reltol = 1e-6)\n\nsol_allee_evar = DataFrame(sol_allee_evar)\nrename!(sol_allee_evar, :timestamp =&gt; :time, :value =&gt; :x)\n\nFinalement, nous pouvons représenter graphiquement la solution contre le temps. Ici, malgré la perturbation violente induite par la période de surexploitation, le pêcherie retrouve une situation soutenable après un retour à E=E_s.\n\n\nCode\nplot(sol_allee_evar.time, sol_allee_evar.x,\n     label = \"\\$x(t)\\$\",\n     linewidth = 2,\n     xlabel = \"temps\",\n     ylabel = \"densité de population \\$x(t)\\$\",\n     title = \"Effort de pêche variant dans le temps\",\n     palette = :tab10,\n     legend = :left,\n     margin = .5Plots.cm,\n     topmargin = 1Plots.cm)\n\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 1: Persistence dans le modèle avec effet Allee et prélèvements\n\n\n\n\n\nLorsque la période de surexploitation de la population est trop longue (e.g. ici T_x=9.2), la population ne parvient pas à récupérer malgré le retour à un effort de prélèvements soutenable.\n\n\nCode\n# change parameter\nT_x2 = 9.2\n\npar_effort2 = [E_s, E_x, T_s, T_x2]\n\n# define new problem and integrate\nprob_allee_evar2 = ODEProblem(allee_evar, \n                             x0, \n                             tspan, \n                             [par_allee, par_effort2, effort], \n                             saveat = tstep)\n\nsol_allee_evar2 = solve(prob_allee_evar2, reltol = 1e-7)\n\nsol_allee_evar2 = DataFrame(sol_allee_evar2)\nrename!(sol_allee_evar2, :timestamp =&gt; :time, :value =&gt; :x)\n\n# plot\nplot(sol_allee_evar2.time, sol_allee_evar2.x,\n     label = \"\\$x(t)\\$\",\n     linewidth = 2,\n     xlabel = \"temps\",\n     ylabel = \"densité de population \\$x(t)\\$\",\n     title = \"Effort de pêche variant dans le temps\",\n     palette = :tab10,\n     legend = :left,\n     margin = .5Plots.cm,\n     topmargin = 1Plots.cm)\n\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 2: Extinction dans le modèle avec effet Allee et prélèvements"
  },
  {
    "objectID": "pop_exploitees.html#simulations-dans-lespace-e-x",
    "href": "pop_exploitees.html#simulations-dans-lespace-e-x",
    "title": "Populations exploitées",
    "section": "",
    "text": "Il s’agit ici de représenter dans l’espace (E, x) l’évolution conjointe de l’effort de pêche et de la densité de la population au cours du temps, afin de mieux comprendre le phénomène d’extinction. Dans cet objectif, on tracera aussi le lieu des équilibres de la population x^*(E) en fonction d’une valeur de E constante, i.e. : \nx^*(E) = 0,\n ou : \nE = r\\left(\\frac{x^*(E)}{\\epsilon}-1\\right)\\left(1-\\frac{x^*(E)}{K}\\right).\n\nNous allons tracer les situations dans 2 sous figures. Commençons par les lieux des équilibres :\n\n# vecteurs pour le tracé\ne2plot = 0:.1:1\nx2plot1 = epsilon:.02:(K+epsilon)/2\nx2plot2 = (K+epsilon)/2:.02:K\n\n# parabole pour les equilibres positifs\nfunction eeqpos(x, par = par_allee)\n        r, K, epsilon = par\n\n        r*(x/epsilon -1)*(1-x/K)\nend\n\n# on définit des couleurs spécifiques depuis la palette :pal10\nmygreen = palette(:tab10)[3]\nmyorange = palette(:tab10)[2]\nmyblue = palette(:tab10)[1]\n\n# plot\nP1 = plot(e2plot, zeros(length(e2plot)),\n          color = mygreen,\n          linewidth = 2,\n          label = \"équilibres stables\",\n          ylabel = \"densité de population \\$x\\$\",\n          xlabel = \"effort de pêche \\$E\\$\",\n          legend = :left)\n        #   margin = .5Plots.cm,\n        #   topmargin = 1Plots.cm)\n\nplot!(P1, eeqpos.(x2plot1), x2plot1, \n          color= myorange,\n          linewidth = 2,\n          label = \"équilibre instable\")\n\nplot!(P1, eeqpos.(x2plot2), x2plot2, \n          color= mygreen,\n          linewidth = 2,\n          label =\"\")\n\ndisplay(P1)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nOn prépare un graphique P2 avec les mêmes éléments :\n\nP2 = deepcopy(P1) # évite de tout retaper...\n\nOn complète P1 et P2 avec quelques annotations et les trajectoires calculées plus haut en fonction de l’effort de pêche variable au cours du temps, et on trace les résultats en deux sous-figures :\n\nannotate!(P1, .35, 8.5, Plots.text(\"branche stable\", 10, rotation=-28))\nannotate!(P1, .4, 2.7, Plots.text(\"branche instable\", 10, rotation=28))\nannotate!(P2, .4, 2.7, Plots.text(\"branche instable\", 10, rotation=28))\nannotate!(P2, .35, 8.5, Plots.text(\"branche stable\", 10, rotation=-28))\n\nplot!(P1, [effort(t, par_effort) for t in sol_allee_evar.time], sol_allee_evar.x,\n      color = myblue, \n      linewidth = 2,\n      label = \"trajectory\")\n\nplot!(P2, [effort(t, par_effort2) for t in sol_allee_evar2.time], sol_allee_evar2.x,\n      color = myblue, \n      linewidth = 2,\n      label = \"trajectory\")\n\nplot(P1, P2, suptitle = \"Effets Allee et prélèvements\",\n     margin = .5Plots.cm,\n     topmargin = 1Plots.cm)\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\nFigure 3: bifurcation pli et catastrophe dans le modèle avec effet Allee et prélèvements"
  },
  {
    "objectID": "pop_exploitees.html#la-tordeuse-du-bourgeon-de-lépinette",
    "href": "pop_exploitees.html#la-tordeuse-du-bourgeon-de-lépinette",
    "title": "Populations exploitées",
    "section": "La tordeuse du bourgeon de l’épinette",
    "text": "La tordeuse du bourgeon de l’épinette\n\nModèle\nNous considérons le modèle de dynamique de populations suivant, inspiré de Ludwig, Jones, and Holling (1978) :\n\n\\dot x =rx\\left(1-\\frac{x}{K}\\right) - \\frac{\\alpha x^2}{h^2+x^2}\\ y,\n\\tag{2}\navec x la densité de tordeuses et y la densité d’oiseaux. La croissance des tordeuses suit une loi logistique et la prédation des oiseaux une réponse fonctionnelle de type Holling III.\n\n\nSimulations\nOn procède classiquement, en ajustant les valeurs de paramètres pour mettre en évidence les phénomènes dynamiques attendus :\n\n# paramètres\nr = 5.0      # natalité\nK = 10.0     # mortalité\nα = 1.0      # taux max de prédation\nh = 0.5      # constante de demi-saturation\nyc = 7.0     # densité de prédateurs\n\npar_tordeuse = [r, K, α, h, yc] \n\n# temps d'intégration\ntspan = (0.0, 3.0)\ntstep = 0.02\n\nPuis on définit le modèle :\n\nfunction tordeuse(u, p, t)\n    r, K, α, h, yc = p\n    x = u[1]\n    dx = r*x*(1 - x/K) - α*x^2/(h^2 + x^2)*yc\nend\n\nComme pour le modèle avec effets Allee, on définit une fonction qui redéfinit le problème d’intégration à chaque fois, et simule et renvoit la solution pour pouvoir illustrer la bi-stabilité1 :1 une méthode alternative utilisant l’interface integrator de DifferentialEquations.jl est proposée en annexe\n\nfunction int_tordeuse(x0, tspan = tspan, param = par_tordeuse)\n    prob_tordeuse = ODEProblem(tordeuse,       # modèle\n                               x0,               # condition initiale\n                               tspan,            # tspan\n                               param,            # paramètres\n                               saveat = tstep)   # option de sortie\n    \n    sol_tordeuse = solve(prob_tordeuse)\n    sol_tordeuse = DataFrame(sol_tordeuse)\n    rename!(sol_tordeuse, :timestamp =&gt; :time, :value =&gt; :x)\nend\n\nNous simulons le modèle depuis différentes conditions intiales, et traçons les résultats via une boucle.\n\n# conditions initiales\nx0step = 1.35\nx0vec = x0step:x0step:K\n\n# custom color palette\ninit_cgrad = palette([:steelblue, :lightblue], length(x0vec))\n\n# initialisation du graphique, équilibre nul\nP = plot(palette = init_cgrad,\n         legend = :right, \n         label =\"équilibres instables\",\n         title = \"Tordeuse du bourgeon de l\\'épinette\",\n         ylabel = \"densité de population \\$x(t)\\$\", \n         xlabel = \"temps \\$t\\$\",\n         margin = .5Plots.cm,\n         topmargin = 1Plots.cm)\n\n# boucle de plot avec intégration pour differentes conditions initiales\nfor x0 in x0vec\n    plot!(P, int_tordeuse(x0).time, int_tordeuse(x0).x,\n          linewidth = 2,\n          label = \"\")\nend\n\ndisplay(P)      # actually shows the plot P\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nEquilibres\nLes valeurs des équilibres positifs du modèle Equation 2 n’ont pas d’écriture mathématique simple. Nous allons calculer numériquement les racines du polynôme dont ils sont solution : \nr\\left(1-\\frac{x^*}{K}\\right)\\left(h^2+x^{*2}\\right)-\\alpha x^* y = 0\n\\tag{3}\nPour cela, on utilise le package Polynomials.jl :\n\nusing Polynomials\n\n# définition du monôme X\nX = Polynomial([0, 1])\n\n# définition du polynôme \npol = r*(1-X/K)*(h^2 + X^2)-α*X*yc\n\n# calcul des racines, réelles, positives et plus petites que K\neq_pos = roots(pol)                         # calcul des racines\neq_pos = real.(eq_pos[isreal.(eq_pos)])     # filtrage des racines réelles\neq_pos = eq_pos[(eq_pos .&gt; 0) .& (eq_pos .&lt;= K)] # filtrage des racines &gt;0 et &lt;K\n\n3-element Vector{Float64}:\n 0.20406511760131657\n 1.4717313636879934\n 8.324203518710693\n\n\nEt on trace les différents équilibres :\n\nt2plot = collect(tspan)\n\n# initialisation du graphique, équilibre nul\nplot!(P, t2plot, zeros(length(t2plot)), \n         lw=2, \n         linestyle = :dash, \n         color = myorange, \n         palette = init_cgrad,\n         legend = :right, \n         label =\"équilibres instables\",\n         ylabel = \"densité de population \\$x(t)\\$\", \n         xlabel = \"temps \\$t\\$\",\n         margin = .5Plots.cm,\n         topmargin = 1Plots.cm)\n\n# équilibres positifs\nif length(eq_pos) == 1\n    plot!(P, t2plot, ones(length(t2plot)).*eq_pos, \n          color = mygreen, \n          label =\"équilibre stable\")\nelseif length(eq_pos) == 3\n    plot!(P, t2plot, ones(length(t2plot)).*eq_pos[1], \n          lw=2, \n          linestyle = :dash, \n          color = mygreen, \n          label =\"équilibres stables\")\n    plot!(P, t2plot, ones(length(t2plot)).*eq_pos[2], \n          lw=2, \n          linestyle = :dash, \n          color = myorange, \n          label = \"\")\n    plot!(P, t2plot, ones(length(t2plot)).*eq_pos[3], \n          lw=2, \n          linestyle = :dash, \n          color = mygreen, \n          label = \"\")\nend\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 4: bistabilité dans le modèle de la tordeuse du bourgeon de l’épinette\n\n\n\n\n\nDiagramme de bifurcations\nFinalement nous traçons dans le plan (y, x) le lieu des points d’équilibres en fonction de la taille de la population d’oiseaux:\n\ny = \\frac{r}{\\alpha x^*}\\left(1-\\frac{x^*}{K}\\right)(h^2+x^{*2})\n\\tag{4}\nComme nous l’avons vu en cours cette fonction est non monotone avec une branche décroissante, une branche croissante puis à nouveau une branche décroissante, le sens de variation déterminant la stabilité de l’équilibre correspondant.\nPour déterminer ces différentes branches et les représenter de différentes couleurs de façon à illustrer leur stabilité, nous allons dériver l’Equation 4 par rapport à x^* en utilisant le package Symbolics.jl et chercher les racines de la dérivée2.2 si l’Equation 4 avait été un polynôme nous aurions utilisé les outils pour les polynômes, mais il s’agit d’une fraction rationnelle\n\nusing Symbolics\n\n@variables X\nD = Differential(X)\n\nY = r/(α*X)*(1-X/K)*(h^2+X^2)\n\n \\begin{equation}\n\\frac{5 \\left( 1 - 0.1 X \\right) \\left( 0.25 + X^{2} \\right)}{X}\n\\end{equation}\n\n\n\nLes racines de la dérivée, sont les racines du numérateur de la dérivée, donc on dérive, et on récupère ce numérateur:\n\ndnumerator = Symbolics.arguments(Symbolics.value(simplify(expand_derivatives(D(Y)))))[1]\ndnumerator\n\n \\begin{equation}\n-1.25 + 5.0 X^{2} - X^{3}\n\\end{equation}\n\n\n\nComme ce numérateur est un polynôme, on peut utiliser le polynôme symbolique de Symbolics.jl pour regénérer un polynôme et utiliser la méthode roots() de Polynomials.jl33 il faut l’admettre, ce serait plus simple d’avoir directement une façon de trouver les racines d’un polynôme symbolique, mais ça ne semble pas implanté pour l’instant (fin 2023)\n\n# on récupère les coefficients X^k du polynôme\ncoefs_dict = Symbolics.value(dnumerator).dict\ndd = Dict(Symbolics.degree(first(kv)) =&gt; kv[2] for kv ∈ coefs_dict)\n\n# on rajoute dans le dictionnaire le coefficient constant\ndd[0] = substitute(dnumerator, Dict(X=&gt;0))\n\n# on définit le polynôme à partir du dictionnaire\ndnumpoly = SparsePolynomial(dd, :X)\n\n# on calcule les solutions en filtrant les racines entre 0 et K via une fonction anonyme s-&gt; K &gt; s &gt; 0\ndroots = filter(s -&gt; K &gt; s &gt; 0, roots(dnumpoly))\n\nOn calcule les branches correspondantes et on peut les tracer dans le plan (y,x) pour illustrer le diagramme de bifurcations.\n\n# on calcule chacune des branches\nxplot1 = 0.08:.01:droots[1]\nxplot2 = droots[1]:.01:droots[2]\nxplot3 = droots[2]:.01:K\nyeq1 = r.*(1 .-xplot1./K) ./ (α.*xplot1).*(h^2 .+xplot1.^2)\nyeq2 = r.*(1 .-xplot2./K) ./ (α.*xplot2).*(h^2 .+xplot2.^2)\nyeq3 = r.*(1 .-xplot3./K) ./ (α.*xplot3).*(h^2 .+xplot3.^2)\n\n# diagramme de bifurcations\nPbif = plot(yeq1, xplot1,\n            linewidth = 2,\n            color = mygreen,\n            label = \"équilibres stables\",\n            legend = :left,\n            xlabel = \"population d'oiseaux \\$y\\$\",\n            ylabel = \"population de tordeuses \\$x\\$\",\n            title = \"Diagramme de bifurcations pour le modèle de tordeuses\",\n            margin = .5Plots.cm,\n            topmargin = 1Plots.cm)\n\nplot!(Pbif, yeq2, xplot2,\n      linewidth = 2,\n      color = myred,\n      label = \"équilibres instables\")\n\nplot!(Pbif, yeq3, xplot3,\n      linewidth = 2,\n      color = mygreen,\n      label = \"\")\n\nplot!(Pbif, [0, maximum(yeq1)], [0, 0], \n      color = myred,\n      lw = 2,\n      label = \"\")\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 5: bifurcations dans le modèle de la tordeuse du bourgeon de l’épinette\n\n\n\nNous verrons sur la page des populations en interactions le cas où la population d’oiseaux varie lentement au cours du temps."
  },
  {
    "objectID": "pop_interactions.html#la-tordeuse-du-bourgeon-de-lépinette-suite",
    "href": "pop_interactions.html#la-tordeuse-du-bourgeon-de-lépinette-suite",
    "title": "Populations en interaction (1)",
    "section": "",
    "text": "Pour débuter cette partie sur les populations en interactions, nous reprenons le modèle de tordeuse de Ludwig, Jones, and Holling (1978) en supposant que la population d’oiseaux réagit (lentement) à la démographie des tordeuses, via la prédation.\nLe changement principal ici est la dimension du modèle (dimension 2) : les tailles de populations de tordeuses x et d’oiseaux y varient toutes deux au cours du temps en s’influençant l’une l’autre, avec une population d’oiseaux qui varie lentement (d’où le paramètre \\varepsilon).\nLe modèle prend la forme :\n\n\\left\\{\n\\begin{array}{l}\n\\displaystyle \\dot x = rx\\left(1-\\frac{x}{K}\\right) - \\frac{\\alpha x^2}{h^2+x^2}\\ y \\\\[.3cm]\n\\displaystyle \\dot y = \\varepsilon \\left(\\frac{n \\alpha x^2}{h^2+x^2}\\ y -m y\\right)\n\\end{array}\n\\right.\n\\tag{1}\nIl faut ajuster un peu la manière de coder pour prendre en compte ces deux dimensions. Commençons par les paramètres divers.\n\nusing DifferentialEquations, Plots, DataFrames\n\n# paramètres\nr = 5.0      # natalité\nK = 10.0     # mortalité\nα = 1.0      # taux max de prédation\nh = 0.5      # constante de demi-saturation\n\nϵ = 0.01     # timescale\nn = 5.0      # gain à la prédation\nm = 3.0      # moralité\n\n\npar_tord_ois = [r, K, α, h, ϵ, n, m] \n\n# temps d'intégration\ntspan = (0.0, 400.0)\ntstep = 0.02\n\n# conditions initiales\nx0 = 1.0    # tordeuses\ny0 = 2.5    # oiseaux\netat0 = [x0, y0]\n\nPuis le modèle :\n\nfunction tord_ois(u, param, t)\n    r, K, α, h, ϵ, n, m = param\n    x = u[1]\n    y = u[2]\n    dx = r*x*(1 - x/K) - α*x^2/(h^2 + x^2) * y\n    dy = ϵ*(n*α*x^2/(h^2 + x^2) * y - m * y)\n    [dx, dy]\nend\n\nProblème d’intégration et simulation :\n\nprob_tord_ois = ODEProblem(tord_ois, \n                           etat0, \n                           tspan, \n                           par_tord_ois, \n                           saveat = tstep)\n\nsol_tord_ois = solve(prob_tord_ois, reltol = 1e-6)\n\nsol_tord_ois = DataFrame(sol_tord_ois)\nrename!(sol_tord_ois, :timestamp =&gt; :time, :value1 =&gt; :x, :value2 =&gt; :y)\n\nReprésentation graphique contre le temps\n\n# color definitions\nmygreen = palette(:tab10)[3]\nmyorange = palette(:tab10)[2]\nmyblue = palette(:tab10)[1]\nmyred = palette(:tab10)[4]\n\nP1 = plot(sol_tord_ois.time, sol_tord_ois.x,\n          color = myblue,\n          linewidth = 2,\n          label = \"tordeuses \\$x\\$\",\n          xlabel = \"temps\",\n          ylabel = \"densités de populations\",\n          title = \"Dynamiques des tordeuses avec\\n population d'oiseaux variable\")\n\nplot!(P1, sol_tord_ois.time, sol_tord_ois.y ./ 2,\n      color = myorange,\n      linewidth = 2,\n      label = \"oiseaux \\$y/2\\$\")\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nOn observe ici des bifurcations dynamiques avec le passage de la population de tordeuse d’une branche d’équilibre stable à l’autre, qui créé un comportement de type cycle d’hysteresis. La situation se comprend bien sur le diagramme de bifurcations (y, x). On retrace le diagramme de bifurcations.\n\n\nCode\nusing Symbolics, Polynomials\n\n@variables X\nD = Differential(X)\n\n# lieu des équilibres positifs\nY = r/(α*X)*(1-X/K)*(h^2+X^2)\n\n# dénominateur de la dérivée\ndnumerator = Symbolics.arguments(Symbolics.value(simplify(expand_derivatives(D(Y)))))[1]\n\n# on récupère les coefficients X^k du polynôme\ncoefs_dict = Symbolics.value(dnumerator).dict\ndd = Dict(Symbolics.degree(first(kv)) =&gt; kv[2] for kv ∈ coefs_dict)\n# on rajoute dans le dictionnaire le coefficient constant\ndd[0] = substitute(dnumerator, Dict(X=&gt;0))\n\n# on définit le polynôme à partir du dictionnaire\ndnumpoly = SparsePolynomial(dd, :X)\n\n# on calcule les racines en filtrant les racines entre 0 et K via une fonction anonyme s-&gt; K &gt; s &gt; 0\ndroots = filter(s -&gt; K &gt; s &gt; 0, roots(dnumpoly))\n\n# vecteur pour le tracé du diagramme de bifurcation\nxplot1 = 0.08:.01:droots[1]\nxplot2 = droots[1]:.01:droots[2]\nxplot3 = droots[2]:.01:K\nyeq1 = r.*(1 .-xplot1./K) ./ (α.*xplot1).*(h^2 .+xplot1.^2)\nyeq2 = r.*(1 .-xplot2./K) ./ (α.*xplot2).*(h^2 .+xplot2.^2)\nyeq3 = r.*(1 .-xplot3./K) ./ (α.*xplot3).*(h^2 .+xplot3.^2)\n\n# diagramme de bifurcations\nPbif = plot(yeq1, xplot1,\n            linewidth = 2,\n            color = mygreen,\n            label = \"équilibres stables\",\n            legend = :left,\n            xlabel = \"population d'oiseaux \\$y\\$\",\n            ylabel = \"population de tordeuses \\$x\\$\",\n            title = \"Diagramme de bifurcations pour le modèle de tordeuses\",\n            margin = .5Plots.cm,\n            topmargin = 1Plots.cm)\n\nplot!(Pbif, yeq2, xplot2,\n      linewidth = 2,\n      color = myred,\n      label = \"équilibres instables\")\n\nplot!(Pbif, yeq3, xplot3,\n      linewidth = 2,\n      color = mygreen,\n      label = \"\")\n\nplot!(Pbif, [0, maximum(yeq1)], [0, 0], \n      color = myred,\n      lw = 2,\n      label = \"\")\n\n\nOn trace sur ce diagramme la trajectoire simulée plus haut :\n\nplot!(Pbif, sol_tord_ois.y, sol_tord_ois.x,\n      color = myblue,\n      linewidth = 2,\n      linealpha = 0.5,\n      label = \"trajectoire\")"
  },
  {
    "objectID": "pop_interactions.html#sec-lv",
    "href": "pop_interactions.html#sec-lv",
    "title": "Populations en interaction (1)",
    "section": "Le modèle proie-prédateur de Lotka et Volterra",
    "text": "Le modèle proie-prédateur de Lotka et Volterra\nNous considérons le modèle de dynamique de populations de Lotka (1925) et Volterra (1926) :\n\n\\left\\{\\begin{array}{l}\n\\dot x = rx - c xy,\\\\\n\\dot y = bxy - m y.\n\\end{array}\\right.\n\\tag{2}\nAvec x la population de proies et y la population de prédateurs.\n\nDynamiques\nIl n’y a pas de difficulté particulière à la simulation par rapport au modèle de la tordeuse du bourgeon de l’épinette avec population d’oiseaux variables.\n\n\nCode\n# conditions initiales\nx0 = 1.0\ny0 = 1.95\netat0 = [x0, y0]\n\n# paramètres\nr = 1.0\nc = 1.0\nb = 1.0\nm = 1.0\npar_lovo = [r, c, b, m]\n\n# integration plus longue\ntspan = (0.0, 30.0)\ntstep = .01\n\n# définition du modèle\nfunction lovo(u, par, t)\n    r, c, b, m = par\n    x = u[1]\n    y = u[2]\n    dx = r*x - c*x*y\n    dy = b*x*y - m*y\n    [dx, dy]\nend\n\n# problème\nprob_lovo = ODEProblem(lovo, etat0, tspan, par_lovo, saveat = tstep)\n# intégration\nsol_lovo = solve(prob_lovo, reltol = 1e-6)\n# dataframe\nsol_lovo = DataFrame(sol_lovo)\nrename!(sol_lovo, :timestamp =&gt; :time, :value1 =&gt; :x, :value2 =&gt; :y)\n\nPlv = plot(sol_lovo.time, sol_lovo.x,\n           linewidth = 2,\n           color = myblue,\n           label = \"proies\",\n           xlabel = \"temps\",\n           ylabel = \"densité de populations\",\n           title = \"Modèle de Lotka Volterra\",\n           margin = .5Plots.cm,\n           topmargin = 1Plots.cm)\n\nplot!(Plv, sol_lovo.time, sol_lovo.y,\n      linewidth = 2,\n      color = myorange,\n      label = \"prédateurs\")\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nEspace d’état\nCommençons par tracer les isoclines nulles ainsi que l’orientation du champs de vecteur dans l’espace d’état. Ce dernier utilise la fonction quiver().\n\n# on redéfinit des fonctions qui renvoient les composantes de la dérivée mises à l'échelle\nscale = 10\nder_x(x, y) = lovo([x y], par_lovo, 0)[1]/scale\nder_y(x, y) = lovo([x y], par_lovo, 0)[2]/scale\n\n# on définit un ensemble de valeur de x et y formant une grille \n# sur laquelle évaluer le champs de vecteurs\nxrange = range(0., 2, length=11)'  # note ' : on va broadcaster pour créer la grille via der_x.() et der_y.()\nyrange = range(0. ,2, length=11)\n\n# champs de vecteurs\nPlan = quiver(xrange, yrange, \n       quiver = (der_x.(xrange, yrange), der_y.(xrange, yrange)),\n       ylim = (-0.05, 2),\n       xlim = (-0.05, 2),\n       color = :lightgray,\n     grid = false,\n       title = \"Modèle de Lotka Volterra\",\n       xlabel = \"proies\",\n       ylabel = \"prédateurs\",\n       margin = .5Plots.cm,\n       topmargin = 1Plots.cm)\n\nOn rajoute les isoclines nulles et les équilibres :\n\n\nCode\n# isoclines nulles\nxplot = 0:2\nyplot = 0:2\nplot!(Plan, xplot, ones(length(xplot)).*r./c,\n      linewidth = 2,\n      color = mygreen,\n      label = \"\\$\\\\dot x = 0\\$\")\nplot!(Plan, zeros(length(yplot)), yplot,\n      linewidth = 2,\n      color = mygreen,\n      label = \"\")\nplot!(Plan, ones(length(yplot)).*m./b, yplot,\n      linewidth = 2,\n      color = myred,\n      label = \"\\$\\\\dot y = 0\\$\")\nplot!(Plan, xplot, zeros(length(xplot)), \n      linewidth = 2,\n      color = myred,\n      label = \"\")\n\n# équilibres\nplot!(Plan, (0, 0),\n      markershape = :circle,\n      color= myred,\n      label = \"\")\nplot!(Plan, (m/b, r/c),\n      markershape = :circle,\n      color= myorange,\n      label = \"\")\n\n\nEt enfin la trajectoire :\n\n\nCode\n# trajectoire\nplot!(Plan,  sol_lovo.x, sol_lovo.y,\n      color = myblue,\n      linewidth = 2,\n      label = \"trajectoire\")\n\ndisplay(Plan)\n\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 1: Plan de phase du modèle de Lotka Volterra\n\n\n\n\n\nIntégrale première\nNous illustrons en 3D l’intégrale première du modèle et superposons la trajectoire simulée plus haut sur ce graphique. L’intégrale première s’écrit : \nH(x,y)= -r\\log(y)+c y-m\\log(x) + bx\n\n\n# l'intégrale première\nfunction int_prem(x, y, par = par_lovo)\n      r, c, b, m = par\n      -r*log(y) + c*y - m*log(x) + b*x\nend\n\nPour tracer le graphique en 3D, nous utilisons le backend plotly.\n\nplotly()\n\n# grille x, y\nxsurf = .2: .1: 3\nysurf = .2:.1: 3\n\n# calcul de la surface via une compréhension de liste\nzsurf = [int_prem(x, y, par_lovo) for x in xsurf, y in ysurf]\n# et H(x0, y0)\nzplane = [int_prem(x0, y0, par_lovo) for x in xsurf, y in ysurf]\n\n# on trace H(x0, y0)\nPsurf = plot(xsurf, ysurf, zplane, \n              st = :surface, \n              color = myorange, \n              alpha =.5, \n              label = \"\") \n\n# l'intégrale première\nplot!(Psurf, xsurf, ysurf, zsurf, \n             st=:surface, \n             alpha = .6, \n             camera = (30, 10), \n             color = :viridis,\n             xlabel = \"proies\",\n             ylabel = \"prédateurs\",\n             title = \"Intégrale première du modèle de Lotka Volterra\")\n\n# la trajectoire\nplot!(Psurf, sol_lovo.x, sol_lovo.y, ones(length(sol_lovo.x)).*int_prem(x0, y0, par_lovo), \n      color = myred, \n      lw=4, \n      label = \"\")\n\n    \n    \n\n\n\n\nFinissons ce TP en simulant le modèle de Rosenzweig MacArthur, par ici."
  },
  {
    "objectID": "pop_interactions2.html",
    "href": "pop_interactions2.html",
    "title": "Populations en interaction (2)",
    "section": "",
    "text": "Nous considérons le modèle de dynamique de populations attribué à Rosenzweig et MacArthur (voir Rosenzweig and MacArthur (1963), Turchin (2003), Smith (2008)).\n\n\\left\\{\\begin{array}{l}\n\\dot x = \\displaystyle rx\\left(1-\\frac{x}{K}\\right) - c \\frac{x}{h+x} y\\\\[.3cm]\n\\dot y = b\\displaystyle \\frac{x}{h+x} y - m y\n\\end{array}\\right.\n\\tag{1}\n\n\nIl n’y a pas de difficulté particulière à la simulation par rapport au modèle de Lotka Volterra.\n\n\nCode\nusing DifferentialEquations, DataFrames\n\n# conditions initiales\nx0 = 1.0\ny0 = 1.95\netat0 = [x0, y0]\n\n# paramètres\nr = 1.0\nK = 10.0 \nc = 1.0\nh = 2.0\nb = 2.0\nm = 1.0\n\npar_rma = [r, K, c, h, b, m]\n\n# temps d'integration \ntspan = (0.0, 55.0)\ntstep = .01\n\n# définition du modèle\nfunction rma(u, par, t)\n    r, K, c, h, b, m = par\n    x = u[1]\n    y = u[2]\n\n    dx = r*x*(1-x/K) - c*x/(h+x)*y\n    dy = b*x/(h+x)*y - m*y\n    \n    [dx, dy]\nend\n\n# problème\nprob_rma = ODEProblem(rma, etat0, tspan, par_rma, saveat = tstep)\n# intégration\nsol_rma = solve(prob_rma, reltol = 1e-6)\n# dataframe\nsol_rma = DataFrame(sol_rma)\nrename!(sol_rma, :timestamp =&gt; :time, :value1 =&gt; :x, :value2 =&gt; :y)\n\n\nNous utiliserons ici le package de visualisation graphique Makie.jl1 à la place de Plots.jl. Makie.jl permet un contrôle très approfondi du graphique. Commençons par tracer les dynamiques contre le temps dans une figure simple.1 entièrement écrit en Julia, présenté comme “le futur” de la représentation graphique avec Julia. Une bonne introduction à Makie.\nNous utiliserons le backend CairoMakie pour la visualisation en 2D.\n\nusing CairoMakie\n\nUn peu comme Matplotlib en Python, Makie définit un triplet FigureAxisPlot : la figure est le conteneur de (éventuellement) plusieurs systèmes d’axes qui contiennent chacun un ou plusieurs graphique.\n\n# on crée la figure\nfig1 = Figure(backgroundcolor = :transparent,\n              resolution = (600,400),   # size\n              fontsize = 18)  \n\n# on crée un système d'axes en position [1,1] dans la figure\nax1 = Axis(fig1[1,1],\n           xlabel = \"temps\",\n           ylabel = \"densités de populations\",\n           title = \"Modèle de Rosenzweig MacArthur\")\n\n# on trace la population x contre le temps sur le système d'axe ax1\nlines!(ax1, sol_rma.time, sol_rma.x,\n       linewidth = 2,\n       linestyle = :solid,\n       label = L\"x(t)\")\n\n# population y\nlines!(ax1, sol_rma.time, sol_rma.y,\n       linewidth = 2,\n       linestyle = :solid,\n       label = L\"y(t)\")\n\n# légende\naxislegend(position = :lt)\n\n# on affiche la figure\nfig1\n\n\n\n\nFigure 1: Ma première figure avec Makie.jl\n\n\n\n\n\n\n\nNous allons maintenant tracer un graphique plus complexe comprenant en colonne de droite les dynamiques des proies et des prédateurs sur deux lignes et en colonne de gauche le plan de phase. préparons la figure et les systèmes d’axes.\n\n# figure\nfig2 = Figure(backgroundcolor = :transparent,\n              size = (800,500),   # size\n              fontsize = 20,\n              font = \"CMU Serif\")  \n\n# 3 systèmes d'axes\nax21 = Axis(fig2[1,1],\n            title = \"Dynamiques\")\n\nax22 = Axis(fig2[2,1],\n            xlabel = \"temps\")\n\nax23 = Axis(fig2[:,2],\n            xlabel = \"proies\",\n            ylabel = \"prédateurs\",\n            title = \"Plan de phase\")\n\n# on agrandi un peu la deuxième colonne de la figure\ncolsize!(fig2.layout, 2, Auto(1.5))\n\n# ajout d'un titre\nsupertitle = Label(fig2[0, :], \"Modèle de Rosenzweig MacArthur\", fontsize = 30)\n# et d'un label d'axes commun à la première colonne\nsideinfo = Label(fig2[1:2, 0], \"densités de populations\", rotation = pi/2)\n\n# on affiche la figure\nfig2\n\n\n\n\nOn rajoute les dynamiques.\n\nlines!(ax21, sol_rma.time, sol_rma.x,\n       color = Cycled(1),  # pick color 1 in the colorcycle\n       linewidth = 2,\n       linestyle = :solid,\n       label = L\"x\")\naxislegend(ax21, position = :lt, labelsize = 14)\n\nlines!(ax22, sol_rma.time, sol_rma.y,\n       color = Cycled(2),\n       linewidth = 2,\n       linestyle = :solid,\n       label = L\"y\")\naxislegend(ax22, position = :lt, labelsize = 14)\n\nhidexdecorations!(ax21, ticks = false)\n\nfig2\n\n\n\n\nPassons maintenant au plan de phase.\n\n# trajectoire\nlines!(ax23, sol_rma.x, sol_rma.y,\n       color = Cycled(1),\n       linewidth = 2,\n       linestyle = :solid,\n       label = L\"trajectoire $$\")\n\n# calcul des isoclines nulles\nx = LinRange(0.0, K+.1, 30)\ny = x\n\n# isoclines nulles de xdot\nnull_x_x = ones(length(y)).*0        # x = 0 isocline nulle de xdot\nnull_x_y = r./c.*(h.+x).*(1 .-x./K)  # y = f(x) isocline nulle de xdot\n\n# isoclines nulles de ydot\nnull_y_y = ones(length(y)).*0           # y = 0 isocline nulle de ydot\nnull_y_x = ones(length(y)).*m.*h./(b-m) # x = mh/(b-m) isocline nulle de ydot\n\n# tracé des isoclines nulle de x\nlines!(ax23, null_x_x, y,\n       color = Cycled(2),\n       linewidth = 2,\n       linestyle = :solid)\n\nlines!(ax23, x, null_x_y, \n       color = Cycled(2),\n       linewidth = 2,\n       linestyle = :solid,\n       label = L\"nullcline de $x$\")\n\n# tracé des isoclines nulle de y\nlines!(ax23, x, null_y_y, \n       color = Cycled(3),\n       linewidth = 2,\n       linestyle = :solid)\nlines!(ax23, null_y_x, y,\n       color = Cycled(3),\n       linewidth = 2,\n       linestyle = :solid,\n       label = L\"nullcline de $y$\")\n\n# tracé des équilibres\nscatter!(ax23, 0, 0,\n         color = Cycled(4),\n         label = L\"équilibres$$\")\nscatter!(ax23, K, 0,\n         color = Cycled(4))\n\neq_coex = [m*h/(b-m), r/c*(h+m*h/(b-m))*(1-m*h/(b-m)/K)]\n\nscatter!(ax23, eq_coex[1], eq_coex[2],\n         color = Cycled(4))\n\n# champs de vecteur\nscale = 10\nxrange = range(1, 10, length=11)  \nyrange = range(1. ,10, length=11)\n\nderx = [rma([x y], par_rma, 0)[1]/scale for x in xrange, y in yrange]\ndery = [rma([x y], par_rma, 0)[2]/scale for x in xrange, y in yrange]\n\narrows!(ax23, xrange, yrange, derx, dery, \n        color = :lightgray, \n        arrowsize = 10, \n        label = L\"vector field$$\")\n\naxislegend(ax23, position = :rt, labelsize = 14)\n\n# reduce default spacing for columns and rows\ncolgap!(fig2.layout, 20)\nrowgap!(fig2.layout, 20)\n\nfig2\n\n\n\n\nFigure 2: Une figure plus complexe avec Makie.jl\n\n\n\n\n\n\n\nPour finir ce TP, nous allons tracer le diagramme de bifurcation du modèle de Rosenzweig MacArthur y^* en fonction de K, en identifiant les bifurcations transcritique et de Hopf vues en cours, et en estimant et représentant les extremas du cycle limite apparaissant pour K grand.\nPour rappel, il y a 3 situations asymptotiques distinctes pour le modèle de Rosenzweig MacArthur :\n\nsi : 0&lt;K&lt;\\displaystyle\\frac{mh}{b-m} : les prédateurs s’éteignent et les proies convergent vers K, l’équilibre d’extinction des deux populations est instable.\nsi : \\displaystyle\\frac{mh}{b-m} &lt;K&lt; h+\\frac{2mh}{b-m} : proies et prédateurs co-existent à un équilibre globalement asymptotiquement stable, l’équilibre d’extinction des prédateurs est instable, l’équilibre d’extinction des deux populations est instable.\nsi : h+\\displaystyle\\frac{2mh}{b-m}&lt;K: proies et prédateurs co-existent le long d’un cycle limite globalement asymptotiquement stable, l’équilibre d’extinction des prédateurs est instable, l’équilibre d’extinction des deux populations est instable.\n\nDans un premier temps nous allons calculer et représenter les différents équilibres et leur stabilité dans le plan (K, y), puis nous calculerons et rajouterons une représentation du cycle limite.\n\n\nNous faisons une boucle sur les valeurs de K et calculons les équilibres.\n\nK_step = 0.1\n\n# before transcritical\nK_plot1 = 0: K_step: m*h/(b-m)\ny_eq01 = ones(length(K_plot1)).*0\n\n# between transcritical and Hopf\nK_plot2 = m*h/(b-m): K_step: h+2*m*h/(b-m)\ny_eq02 = ones(length(K_plot2)).*0\ny_co2 = [r/c*(h+m*h/(b-m))*(1-m*h/(b-m)/K_p) for K_p in K_plot2]  # may have broadcasted\n\n# above Hopf\nK_plot3 = h+2*m*h/(b-m)-K_step/5: (K_step/10) :8\ny_eq03 = ones(length(K_plot3)).*0\ny_co3 = [r/c*(h+m*h/(b-m))*(1-m*h/(b-m)/K_p) for K_p in K_plot3]; # may have broadcasted\n\nEt nous commençons le tracé de la figure :\n\n\nCode\nfig3 = Figure(backgroundcolor = :transparent,\n              resolution = (600,400),   # size\n              fontsize = 18)  \n\n# on crée un système d'axes en position [1,1] dans la figure\nax31 = Axis(fig3[1,1],\n           xlabel = L\"capacité de charge $K$\",\n           ylabel = L\"densité de population $y^*$\",\n           title = \"Diagramme de bifurcations pour le\\n modèle de Rosenzweig MacArthur\")\n\n# on trace la population x \n# left of transcritical\nlines!(ax31, K_plot1, y_eq01,\n       color = Cycled(1),\n       linewidth = 2,\n       label = L\"branche stable$$\")\n\n# between transcritical and Hopf\nlines!(ax31, K_plot2, y_eq02,\n       color = Cycled(2),\n       linewidth = 2,\n       label = L\"branche instable$$\")\n\nlines!(ax31, K_plot2, y_co2,\n       color = Cycled(1),\n       linewidth = 2)\n\n# right of Hopf\nlines!(ax31, K_plot3, y_eq03,\n       color = Cycled(2),\n       linewidth = 2)\n\nlines!(ax31, K_plot3, y_co3,\n       color = Cycled(2),\n       linewidth = 2)\n\nfig3\n\n\n\n\n\n\n\n\nPour estimer le cycle limite pour chaque la valeur de K nous allons simuler le modèle pendant un transitoire assez long, puis repartir de cette valeur de l’état, simuler un cycle et récupérer les extremas pour les tracer. Nous utilisons une méthode basée sur remake pour modifier le problème d’intégration2.2 voir aussi l’annexe\n\n# transient integration time\nt_trans = (0.0, 8000.)\n\n# for storage\ni = 1\ny_cmin = zero(K_plot3)\ny_cmax = zero(K_plot3)\n\n\nrma_pbe = ODEProblem(rma, etat0, t_trans, par_rma)\n\n# estimate limit cycle through loop on K \nfor Kc in K_plot3               # loop on K values\n  par_rmac = [r, Kc, c, h, b, m]    # set parameters\n  \n  # transient initial value problem; simulation\n  rma_trans_pbe =  remake(rma_pbe, p = par_rmac)\n  # with such arguments `solve` yields only the final value of the simulation\n  post_trans2 = solve(rma_trans_pbe, \n                      save_everystep = false, \n                      save_start = false,  \n                      abstol=1e-6, reltol=1e-6)\n  \n  # limit cycle initial value problem; simulation\n  rma_cycle_pbe =  remake(rma_pbe, \n                          p = par_rmac, \n                          u0 = post_trans2[:,1], \n                          tspan = tspan, \n                          saveat = tstep)\n  \n  sol_cycle = solve(rma_cycle_pbe, abstol=1e-6, reltol=1e-6)\n  \n  # get the extrema of y\n  y_cmin[i] = minimum(sol_cycle[2,:])           \n  y_cmax[i] = maximum(sol_cycle[2,:])\n  \n  i+=1\n  #return post_trans2\nend\n\n\n\n\nFinalement, on inclut les branches calculées dans le diagramme de bifurcations.\n\n\nCode\nlines!(ax31, K_plot3, y_cmin,\n       color = Cycled(3),\n       linewidth = 2,\n       label = L\"cycle limite$$\")\n\nlines!(ax31, K_plot3, y_cmax,\n       color = Cycled(3),\n       linewidth = 2)\n\naxislegend(ax31, position = :lt, labelsize = 14)\n\nfig3\n\n\n\n\n\nFigure 3: Diagramme de bifurcations du modèle de Rosenzweig MacArthur.\n\n\n\n\n\n\nThat’s all folks!"
  },
  {
    "objectID": "pop_interactions2.html#sec-rma",
    "href": "pop_interactions2.html#sec-rma",
    "title": "Populations en interaction (2)",
    "section": "",
    "text": "Nous considérons le modèle de dynamique de populations attribué à Rosenzweig et MacArthur (voir Rosenzweig and MacArthur (1963), Turchin (2003), Smith (2008)).\n\n\\left\\{\\begin{array}{l}\n\\dot x = \\displaystyle rx\\left(1-\\frac{x}{K}\\right) - c \\frac{x}{h+x} y\\\\[.3cm]\n\\dot y = b\\displaystyle \\frac{x}{h+x} y - m y\n\\end{array}\\right.\n\\tag{1}\n\n\nIl n’y a pas de difficulté particulière à la simulation par rapport au modèle de Lotka Volterra.\n\n\nCode\nusing DifferentialEquations, DataFrames\n\n# conditions initiales\nx0 = 1.0\ny0 = 1.95\netat0 = [x0, y0]\n\n# paramètres\nr = 1.0\nK = 10.0 \nc = 1.0\nh = 2.0\nb = 2.0\nm = 1.0\n\npar_rma = [r, K, c, h, b, m]\n\n# temps d'integration \ntspan = (0.0, 55.0)\ntstep = .01\n\n# définition du modèle\nfunction rma(u, par, t)\n    r, K, c, h, b, m = par\n    x = u[1]\n    y = u[2]\n\n    dx = r*x*(1-x/K) - c*x/(h+x)*y\n    dy = b*x/(h+x)*y - m*y\n    \n    [dx, dy]\nend\n\n# problème\nprob_rma = ODEProblem(rma, etat0, tspan, par_rma, saveat = tstep)\n# intégration\nsol_rma = solve(prob_rma, reltol = 1e-6)\n# dataframe\nsol_rma = DataFrame(sol_rma)\nrename!(sol_rma, :timestamp =&gt; :time, :value1 =&gt; :x, :value2 =&gt; :y)\n\n\nNous utiliserons ici le package de visualisation graphique Makie.jl1 à la place de Plots.jl. Makie.jl permet un contrôle très approfondi du graphique. Commençons par tracer les dynamiques contre le temps dans une figure simple.1 entièrement écrit en Julia, présenté comme “le futur” de la représentation graphique avec Julia. Une bonne introduction à Makie.\nNous utiliserons le backend CairoMakie pour la visualisation en 2D.\n\nusing CairoMakie\n\nUn peu comme Matplotlib en Python, Makie définit un triplet FigureAxisPlot : la figure est le conteneur de (éventuellement) plusieurs systèmes d’axes qui contiennent chacun un ou plusieurs graphique.\n\n# on crée la figure\nfig1 = Figure(backgroundcolor = :transparent,\n              resolution = (600,400),   # size\n              fontsize = 18)  \n\n# on crée un système d'axes en position [1,1] dans la figure\nax1 = Axis(fig1[1,1],\n           xlabel = \"temps\",\n           ylabel = \"densités de populations\",\n           title = \"Modèle de Rosenzweig MacArthur\")\n\n# on trace la population x contre le temps sur le système d'axe ax1\nlines!(ax1, sol_rma.time, sol_rma.x,\n       linewidth = 2,\n       linestyle = :solid,\n       label = L\"x(t)\")\n\n# population y\nlines!(ax1, sol_rma.time, sol_rma.y,\n       linewidth = 2,\n       linestyle = :solid,\n       label = L\"y(t)\")\n\n# légende\naxislegend(position = :lt)\n\n# on affiche la figure\nfig1\n\n\n\n\nFigure 1: Ma première figure avec Makie.jl\n\n\n\n\n\n\n\nNous allons maintenant tracer un graphique plus complexe comprenant en colonne de droite les dynamiques des proies et des prédateurs sur deux lignes et en colonne de gauche le plan de phase. préparons la figure et les systèmes d’axes.\n\n# figure\nfig2 = Figure(backgroundcolor = :transparent,\n              size = (800,500),   # size\n              fontsize = 20,\n              font = \"CMU Serif\")  \n\n# 3 systèmes d'axes\nax21 = Axis(fig2[1,1],\n            title = \"Dynamiques\")\n\nax22 = Axis(fig2[2,1],\n            xlabel = \"temps\")\n\nax23 = Axis(fig2[:,2],\n            xlabel = \"proies\",\n            ylabel = \"prédateurs\",\n            title = \"Plan de phase\")\n\n# on agrandi un peu la deuxième colonne de la figure\ncolsize!(fig2.layout, 2, Auto(1.5))\n\n# ajout d'un titre\nsupertitle = Label(fig2[0, :], \"Modèle de Rosenzweig MacArthur\", fontsize = 30)\n# et d'un label d'axes commun à la première colonne\nsideinfo = Label(fig2[1:2, 0], \"densités de populations\", rotation = pi/2)\n\n# on affiche la figure\nfig2\n\n\n\n\nOn rajoute les dynamiques.\n\nlines!(ax21, sol_rma.time, sol_rma.x,\n       color = Cycled(1),  # pick color 1 in the colorcycle\n       linewidth = 2,\n       linestyle = :solid,\n       label = L\"x\")\naxislegend(ax21, position = :lt, labelsize = 14)\n\nlines!(ax22, sol_rma.time, sol_rma.y,\n       color = Cycled(2),\n       linewidth = 2,\n       linestyle = :solid,\n       label = L\"y\")\naxislegend(ax22, position = :lt, labelsize = 14)\n\nhidexdecorations!(ax21, ticks = false)\n\nfig2\n\n\n\n\nPassons maintenant au plan de phase.\n\n# trajectoire\nlines!(ax23, sol_rma.x, sol_rma.y,\n       color = Cycled(1),\n       linewidth = 2,\n       linestyle = :solid,\n       label = L\"trajectoire $$\")\n\n# calcul des isoclines nulles\nx = LinRange(0.0, K+.1, 30)\ny = x\n\n# isoclines nulles de xdot\nnull_x_x = ones(length(y)).*0        # x = 0 isocline nulle de xdot\nnull_x_y = r./c.*(h.+x).*(1 .-x./K)  # y = f(x) isocline nulle de xdot\n\n# isoclines nulles de ydot\nnull_y_y = ones(length(y)).*0           # y = 0 isocline nulle de ydot\nnull_y_x = ones(length(y)).*m.*h./(b-m) # x = mh/(b-m) isocline nulle de ydot\n\n# tracé des isoclines nulle de x\nlines!(ax23, null_x_x, y,\n       color = Cycled(2),\n       linewidth = 2,\n       linestyle = :solid)\n\nlines!(ax23, x, null_x_y, \n       color = Cycled(2),\n       linewidth = 2,\n       linestyle = :solid,\n       label = L\"nullcline de $x$\")\n\n# tracé des isoclines nulle de y\nlines!(ax23, x, null_y_y, \n       color = Cycled(3),\n       linewidth = 2,\n       linestyle = :solid)\nlines!(ax23, null_y_x, y,\n       color = Cycled(3),\n       linewidth = 2,\n       linestyle = :solid,\n       label = L\"nullcline de $y$\")\n\n# tracé des équilibres\nscatter!(ax23, 0, 0,\n         color = Cycled(4),\n         label = L\"équilibres$$\")\nscatter!(ax23, K, 0,\n         color = Cycled(4))\n\neq_coex = [m*h/(b-m), r/c*(h+m*h/(b-m))*(1-m*h/(b-m)/K)]\n\nscatter!(ax23, eq_coex[1], eq_coex[2],\n         color = Cycled(4))\n\n# champs de vecteur\nscale = 10\nxrange = range(1, 10, length=11)  \nyrange = range(1. ,10, length=11)\n\nderx = [rma([x y], par_rma, 0)[1]/scale for x in xrange, y in yrange]\ndery = [rma([x y], par_rma, 0)[2]/scale for x in xrange, y in yrange]\n\narrows!(ax23, xrange, yrange, derx, dery, \n        color = :lightgray, \n        arrowsize = 10, \n        label = L\"vector field$$\")\n\naxislegend(ax23, position = :rt, labelsize = 14)\n\n# reduce default spacing for columns and rows\ncolgap!(fig2.layout, 20)\nrowgap!(fig2.layout, 20)\n\nfig2\n\n\n\n\nFigure 2: Une figure plus complexe avec Makie.jl\n\n\n\n\n\n\n\nPour finir ce TP, nous allons tracer le diagramme de bifurcation du modèle de Rosenzweig MacArthur y^* en fonction de K, en identifiant les bifurcations transcritique et de Hopf vues en cours, et en estimant et représentant les extremas du cycle limite apparaissant pour K grand.\nPour rappel, il y a 3 situations asymptotiques distinctes pour le modèle de Rosenzweig MacArthur :\n\nsi : 0&lt;K&lt;\\displaystyle\\frac{mh}{b-m} : les prédateurs s’éteignent et les proies convergent vers K, l’équilibre d’extinction des deux populations est instable.\nsi : \\displaystyle\\frac{mh}{b-m} &lt;K&lt; h+\\frac{2mh}{b-m} : proies et prédateurs co-existent à un équilibre globalement asymptotiquement stable, l’équilibre d’extinction des prédateurs est instable, l’équilibre d’extinction des deux populations est instable.\nsi : h+\\displaystyle\\frac{2mh}{b-m}&lt;K: proies et prédateurs co-existent le long d’un cycle limite globalement asymptotiquement stable, l’équilibre d’extinction des prédateurs est instable, l’équilibre d’extinction des deux populations est instable.\n\nDans un premier temps nous allons calculer et représenter les différents équilibres et leur stabilité dans le plan (K, y), puis nous calculerons et rajouterons une représentation du cycle limite.\n\n\nNous faisons une boucle sur les valeurs de K et calculons les équilibres.\n\nK_step = 0.1\n\n# before transcritical\nK_plot1 = 0: K_step: m*h/(b-m)\ny_eq01 = ones(length(K_plot1)).*0\n\n# between transcritical and Hopf\nK_plot2 = m*h/(b-m): K_step: h+2*m*h/(b-m)\ny_eq02 = ones(length(K_plot2)).*0\ny_co2 = [r/c*(h+m*h/(b-m))*(1-m*h/(b-m)/K_p) for K_p in K_plot2]  # may have broadcasted\n\n# above Hopf\nK_plot3 = h+2*m*h/(b-m)-K_step/5: (K_step/10) :8\ny_eq03 = ones(length(K_plot3)).*0\ny_co3 = [r/c*(h+m*h/(b-m))*(1-m*h/(b-m)/K_p) for K_p in K_plot3]; # may have broadcasted\n\nEt nous commençons le tracé de la figure :\n\n\nCode\nfig3 = Figure(backgroundcolor = :transparent,\n              resolution = (600,400),   # size\n              fontsize = 18)  \n\n# on crée un système d'axes en position [1,1] dans la figure\nax31 = Axis(fig3[1,1],\n           xlabel = L\"capacité de charge $K$\",\n           ylabel = L\"densité de population $y^*$\",\n           title = \"Diagramme de bifurcations pour le\\n modèle de Rosenzweig MacArthur\")\n\n# on trace la population x \n# left of transcritical\nlines!(ax31, K_plot1, y_eq01,\n       color = Cycled(1),\n       linewidth = 2,\n       label = L\"branche stable$$\")\n\n# between transcritical and Hopf\nlines!(ax31, K_plot2, y_eq02,\n       color = Cycled(2),\n       linewidth = 2,\n       label = L\"branche instable$$\")\n\nlines!(ax31, K_plot2, y_co2,\n       color = Cycled(1),\n       linewidth = 2)\n\n# right of Hopf\nlines!(ax31, K_plot3, y_eq03,\n       color = Cycled(2),\n       linewidth = 2)\n\nlines!(ax31, K_plot3, y_co3,\n       color = Cycled(2),\n       linewidth = 2)\n\nfig3\n\n\n\n\n\n\n\n\nPour estimer le cycle limite pour chaque la valeur de K nous allons simuler le modèle pendant un transitoire assez long, puis repartir de cette valeur de l’état, simuler un cycle et récupérer les extremas pour les tracer. Nous utilisons une méthode basée sur remake pour modifier le problème d’intégration2.2 voir aussi l’annexe\n\n# transient integration time\nt_trans = (0.0, 8000.)\n\n# for storage\ni = 1\ny_cmin = zero(K_plot3)\ny_cmax = zero(K_plot3)\n\n\nrma_pbe = ODEProblem(rma, etat0, t_trans, par_rma)\n\n# estimate limit cycle through loop on K \nfor Kc in K_plot3               # loop on K values\n  par_rmac = [r, Kc, c, h, b, m]    # set parameters\n  \n  # transient initial value problem; simulation\n  rma_trans_pbe =  remake(rma_pbe, p = par_rmac)\n  # with such arguments `solve` yields only the final value of the simulation\n  post_trans2 = solve(rma_trans_pbe, \n                      save_everystep = false, \n                      save_start = false,  \n                      abstol=1e-6, reltol=1e-6)\n  \n  # limit cycle initial value problem; simulation\n  rma_cycle_pbe =  remake(rma_pbe, \n                          p = par_rmac, \n                          u0 = post_trans2[:,1], \n                          tspan = tspan, \n                          saveat = tstep)\n  \n  sol_cycle = solve(rma_cycle_pbe, abstol=1e-6, reltol=1e-6)\n  \n  # get the extrema of y\n  y_cmin[i] = minimum(sol_cycle[2,:])           \n  y_cmax[i] = maximum(sol_cycle[2,:])\n  \n  i+=1\n  #return post_trans2\nend\n\n\n\n\nFinalement, on inclut les branches calculées dans le diagramme de bifurcations.\n\n\nCode\nlines!(ax31, K_plot3, y_cmin,\n       color = Cycled(3),\n       linewidth = 2,\n       label = L\"cycle limite$$\")\n\nlines!(ax31, K_plot3, y_cmax,\n       color = Cycled(3),\n       linewidth = 2)\n\naxislegend(ax31, position = :lt, labelsize = 14)\n\nfig3\n\n\n\n\n\nFigure 3: Diagramme de bifurcations du modèle de Rosenzweig MacArthur.\n\n\n\n\n\n\nThat’s all folks!"
  },
  {
    "objectID": "annexe_integrator.html",
    "href": "annexe_integrator.html",
    "title": "Simulations multiples",
    "section": "",
    "text": "Lors de simulations multiples1, la stratégie choisie a été de redéfinir un nouveau problème d’intégration ODEProblem pour chaque condition initiale. Cette procédure est a priori très peu efficace, et DifferentialEquations.jl permet de modifier un problème d’intégration via la Integrator Interface.1 par exemple pour plusieurs conditions initiales pour le modèle avec effets Allee ou celui de la tordeuse du bourgeon de l’épinette\nRépliquons la figure des dynamiques de la tordeuse du bourgeon de l’épinette avec cette méthode. On commence par définir les paramètres et le modèle:\n\n\nCode\nusing DifferentialEquations, Plots, DataFrames\n\n# paramètres\nr = 5.0      # natalité\nK = 10.0     # mortalité\nα = 1.0      # taux max de prédation\nh = 0.5      # constante de demi-saturation\nyc = 7.0     # densité de prédateurs\n\npar_tordeuse = [r, K, α, h, yc] \n\n# temps d'intégration\ntspan = (0.0, 3.0)\ntstep = 0.02\n\n# condition initale\nx0step = 1.35\n\n# modèle\nfunction tordeuse(u, p, t)\n    r, K, α, h, yc = p\n    x = u[1]\n    dx = r*x*(1 - x/K) - α*x^2/(h^2 + x^2)*yc\nend\n\n\nNous définissons ensuite le problème d’intégration ainsi que l’intégrateur integrator:\n\nprob_tordeuse = ODEProblem(tordeuse,         # modèle\n                           x0step,           # condition initiale\n                           tspan,            # tspan\n                           par_tordeuse,     # paramètres\n                           saveat = tstep)   # option de sortie\n\nintegrator = init(prob_tordeuse)\n\nPour une utilisation dans une boucle pour simuler les trajectoires depuis différentes conditions initiales, nous définissons une fonction qui réinitialise l’intégrateur à la nouvelle condition, effectue la simulation (et transforme la solution en dataframe).\n\nfunction int_tordeuse(x0, integrator)\n    reinit!(integrator, x0)\n\n    sol_tordeuse = solve!(integrator)\n    sol_tordeuse = DataFrame(sol_tordeuse)\n    rename!(sol_tordeuse, :timestamp =&gt; :time, :value =&gt; :x)\nend\n\nOn construit ensuite le graphique et on fait une boucle pour intégrer et tracer les résultats:\n\n# conditions initiales\nx0vec = x0step:x0step:K\n\n# custom color palette\ninit_cgrad = palette([:steelblue, :lightblue], length(x0vec))\n\n# initialisation du graphique, équilibre nul\nP = plot(palette = init_cgrad,\n         legend = :right, \n         label = \"équilibres instables\",\n         title = \"Tordeuse du bourgeon de l\\'épinette\",\n         ylabel = \"densité de population \\$x(t)\\$\", \n         xlabel = \"temps \\$t\\$\",\n         margin = .5Plots.cm,\n         topmargin = 1Plots.cm)\n\n# boucle de plot avec intégration pour differentes conditions initiales\nfor x0 in x0vec\n    plot!(P, int_tordeuse(x0, integrator).time, \n          int_tordeuse(x0, integrator).x,\n          linewidth = 2,\n          label = \"\")\nend\n\ndisplay(P)      # actually shows the plot P\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nOn peut compléter la figure comme vu précédemment.\n\n\nCode\n# on définit des couleurs spécifiques depuis la palette :pal10\nmygreen = palette(:tab10)[3]\nmyorange = palette(:tab10)[2]\nmyblue = palette(:tab10)[1]\nmyred = palette(:tab10)[4]\n\nusing Polynomials\n\n# définition du monôme X\nX = Polynomial([0, 1])\n\n# définition du polynôme \npol = r*(1-X/K)*(h^2 + X^2)-α*X*yc\n\n# calcul des racines, réelles, positives et plus petites que K\neq_pos = roots(pol)                         # calcul des racines\neq_pos = real.(eq_pos[isreal.(eq_pos)])     # filtrage des racines réelles\neq_pos = eq_pos[(eq_pos .&gt; 0) .& (eq_pos .&lt;= K)] # filtrage des racines &gt;0 et &lt;K\n\nt2plot = collect(tspan)\n\n# initialisation du graphique, équilibre nul\nplot!(P, t2plot, zeros(length(t2plot)), \n         lw=2, \n         linestyle = :dash, \n         color = myorange, \n         palette = init_cgrad,\n         legend = :right, \n         label =\"équilibres instables\",\n         ylabel = \"densité de population \\$x(t)\\$\", \n         xlabel = \"temps \\$t\\$\",\n         margin = .5Plots.cm,\n         topmargin = 1Plots.cm)\n\n# équilibres positifs\nif length(eq_pos) == 1\n    plot!(P, t2plot, ones(length(t2plot)).*eq_pos, \n          color = mygreen, \n          label =\"équilibre stable\")\nelseif length(eq_pos) == 3\n    plot!(P, t2plot, ones(length(t2plot)).*eq_pos[1], \n          lw=2, \n          linestyle = :dash, \n          color = mygreen, \n          label =\"équilibres stables\")\n    plot!(P, t2plot, ones(length(t2plot)).*eq_pos[2], \n          lw=2, \n          linestyle = :dash, \n          color = myorange, \n          label = \"\")\n    plot!(P, t2plot, ones(length(t2plot)).*eq_pos[3], \n          lw=2, \n          linestyle = :dash, \n          color = mygreen, \n          label = \"\")\nend\n\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 1: bistabilité dans le modèle de la tordeuse du bourgeon de l’épinette\n\n\n\n\n\nLe code de la fonction int_tordeuse est plus simple avec l’integrator interface qu’en redéfinissant le problème d’intégration à chaque fois. Néanmoins, sur un problème avec x0step= 0.1 (soit ~100 trajectoires calculées), le gain en temps de calcul de cette méthode est marginal : 123 ms contre 128 ms avec la méthode précédente (test avec package BenchmarkTools.jl).\nLe gain en mémoire est plus sensible : 4.28 MiB contre 7.26 MiB, mais finalement marginal aussi sur des machines modernes pour de si petits problèmes d’intégration.\n\n\n\nUne autre approche plutôt que d’utiliser l’integrator interface, ou de redéfinir un nouveau problème d’intégration à chaque fois, serait de modifier le problème d’intégration via la fonction remake:\n\nfunction int_tordeuse2(x0, prob)\n    prob = remake(prob, u0 = x0)       # redéfinition du problème d'intégration\n    \n    sol_tordeuse = solve(prob)\n    sol_tordeuse = DataFrame(sol_tordeuse)\n    rename!(sol_tordeuse, :timestamp =&gt; :time, :value =&gt; :x)\nend\n\nP2 = plot(palette = init_cgrad,\n         legend = :right, \n         label = \"équilibres instables\",\n         title = \"Tordeuse du bourgeon de l\\'épinette\",\n         ylabel = \"densité de population \\$x(t)\\$\", \n         xlabel = \"temps \\$t\\$\",\n         margin = .5Plots.cm,\n         topmargin = 1Plots.cm)\n\nfor x0 in x0vec\n    plot!(P2, int_tordeuse2(x0, prob_tordeuse).time, \n          int_tordeuse2(x0, prob_tordeuse).x,\n          linewidth = 2,\n          label = \"\")\nend\n\nP2\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCette méthode est plus rapide que la redéfinition de problème d’intégration ou l’utilisation de l’integrator interface (113 ms dans les conditions vues plus haut) et intermédiaire en termes de mémoire utilisée (6.39 MiB). Le code est aussi simple que pour l’integrator interface.\nPar ailleurs la même approche via remake peut être utilisée pour redéfinir un problème d’intégration en modifiant les paramètres plutôt que la condition initiale, par exemple pour calculer un diagramme de bifurcations par force brute comme pour le modèle de Rosenzweig MacArthur."
  },
  {
    "objectID": "annexe_integrator.html#utilisation-de-linterface-integrator",
    "href": "annexe_integrator.html#utilisation-de-linterface-integrator",
    "title": "Matériel supplémentaire",
    "section": "",
    "text": "Lors de simulations multiples1, la stratégie choisie a été de redéfinir un nouveau problème d’intégration ODEProblem pour chaque condition initiale. Cette procédure est a priori très peu efficace, et DifferentialEquations.jl permet de modifier un problème d’intégration via la Integrator Interface.1 par exemple pour plusieurs conditions initiales pour le modèle avec effets Allee ou celui de la tordeuse du bourgeon de l’épinette\nLa même approche peut être utilisée pour redéfinir un problème d’intégration en modifiant les paramètres plutôt que la condition initiale, par exemple pour calculer un diagramme de bifurcations par force brute comme pour le modèle de Rosenzweig MacArthur.\nRépliquons la figure des dynamiques de la tordeuse du bourgeon de l’épinette avec cette méthode. On commence par définir les paramètres et le modèle:\n\n\nCode\nusing DifferentialEquations, Plots, DataFrames\n\n# paramètres\nr = 5.0      # natalité\nK = 10.0     # mortalité\nα = 1.0      # taux max de prédation\nh = 0.5      # constante de demi-saturation\nyc = 7.0     # densité de prédateurs\n\npar_tordeuse = [r, K, α, h, yc] \n\n# temps d'intégration\ntspan = (0.0, 3.0)\ntstep = 0.02\n\n# condition initale\nx0step = 1.35\n\n# modèle\nfunction tordeuse(u, p, t)\n    r, K, α, h, yc = p\n    x = u[1]\n    dx = r*x*(1 - x/K) - α*x^2/(h^2 + x^2)*yc\nend\n\n\nNous définissons ensuite le problème d’intégration ainsi que l’intégrateur integrator:\n\nprob_tordeuse = ODEProblem(tordeuse,         # modèle\n                           x0step,           # condition initiale\n                           tspan,            # tspan\n                           par_tordeuse,     # paramètres\n                           saveat = tstep)   # option de sortie\n\nintegrator = init(prob_tordeuse)\n\nPour une utilisation dans une boucle pour simuler les trajectoires depuis différentes conditions initiales, nous définissons une fonction qui réinitialise l’intégrateur à la nouvelle condition, effectue la simulation (et transforme la solution en dataframe).\n\nfunction int_tordeuse(x0, integrator)\n    reinit!(integrator, x0)\n\n    sol_tordeuse = solve!(integrator)\n    sol_tordeuse = DataFrame(sol_tordeuse)\n    rename!(sol_tordeuse, :timestamp =&gt; :time, :value =&gt; :x)\nend\n\nOn construit ensuite le graphique et on fait une boucle pour intégrer et tracer les résultats:\n\n# conditions initiales\nx0vec = x0step:x0step:K\n\n# custom color palette\ninit_cgrad = palette([:steelblue, :lightblue], length(x0vec))\n\n# initialisation du graphique, équilibre nul\nP = plot(palette = init_cgrad,\n         legend = :right, \n         label = \"équilibres instables\",\n         title = \"Tordeuse du bourgeon de l\\'épinette\",\n         ylabel = \"densité de population \\$x(t)\\$\", \n         xlabel = \"temps \\$t\\$\",\n         margin = .5Plots.cm,\n         topmargin = 1Plots.cm)\n\n# boucle de plot avec intégration pour differentes conditions initiales\nfor x0 in x0vec\n    plot!(P, int_tordeuse(x0, integrator).time, \n          int_tordeuse(x0, integrator).x,\n          linewidth = 2,\n          label = \"\")\nend\n\ndisplay(P)      # actually shows the plot P\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nOn peut compléter la figure comme vu précédemment.\n\n\nCode\n# on définit des couleurs spécifiques depuis la palette :pal10\nmygreen = palette(:tab10)[3]\nmyorange = palette(:tab10)[2]\nmyblue = palette(:tab10)[1]\nmyred = palette(:tab10)[4]\n\nusing Polynomials\n\n# définition du monôme X\nX = Polynomial([0, 1])\n\n# définition du polynôme \npol = r*(1-X/K)*(h^2 + X^2)-α*X*yc\n\n# calcul des racines, réelles, positives et plus petites que K\neq_pos = roots(pol)                         # calcul des racines\neq_pos = real.(eq_pos[isreal.(eq_pos)])     # filtrage des racines réelles\neq_pos = eq_pos[(eq_pos .&gt; 0) .& (eq_pos .&lt;= K)] # filtrage des racines &gt;0 et &lt;K\n\nt2plot = collect(tspan)\n\n# initialisation du graphique, équilibre nul\nplot!(P, t2plot, zeros(length(t2plot)), \n         lw=2, \n         linestyle = :dash, \n         color = myorange, \n         palette = init_cgrad,\n         legend = :right, \n         label =\"équilibres instables\",\n         ylabel = \"densité de population \\$x(t)\\$\", \n         xlabel = \"temps \\$t\\$\",\n         margin = .5Plots.cm,\n         topmargin = 1Plots.cm)\n\n# équilibres positifs\nif length(eq_pos) == 1\n    plot!(P, t2plot, ones(length(t2plot)).*eq_pos, \n          color = mygreen, \n          label =\"équilibre stable\")\nelseif length(eq_pos) == 3\n    plot!(P, t2plot, ones(length(t2plot)).*eq_pos[1], \n          lw=2, \n          linestyle = :dash, \n          color = mygreen, \n          label =\"équilibres stables\")\n    plot!(P, t2plot, ones(length(t2plot)).*eq_pos[2], \n          lw=2, \n          linestyle = :dash, \n          color = myorange, \n          label = \"\")\n    plot!(P, t2plot, ones(length(t2plot)).*eq_pos[3], \n          lw=2, \n          linestyle = :dash, \n          color = mygreen, \n          label = \"\")\nend\n\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 1: bistabilité dans le modèle de la tordeuse du bourgeon de l’épinette\n\n\n\n\n\nLe code de la fonction int_tordeuse est plus simple avec l’integrator interface qu’en redéfinissant le problème d’intégration à chaque fois. Néanmoins, sur un problème avec x0step= 0.1 (soit ~100 trajectoires calculées), le gain en temps de calcul de cette méthode est marginal : 123ms contre 128ms avec la méthode précédente. Le gain en mémoire est plus sensible : 4.28 mO contre 7,26 mO, mais finalement marginal aussi sur des machines modernes pour de si petits problèmes d’intégration."
  },
  {
    "objectID": "annexe_integrator.html#interface-integrator-pour-simulations-multiples",
    "href": "annexe_integrator.html#interface-integrator-pour-simulations-multiples",
    "title": "Simulations multiples",
    "section": "",
    "text": "Lors de simulations multiples1, la stratégie choisie a été de redéfinir un nouveau problème d’intégration ODEProblem pour chaque condition initiale. Cette procédure est a priori très peu efficace, et DifferentialEquations.jl permet de modifier un problème d’intégration via la Integrator Interface.1 par exemple pour plusieurs conditions initiales pour le modèle avec effets Allee ou celui de la tordeuse du bourgeon de l’épinette\nRépliquons la figure des dynamiques de la tordeuse du bourgeon de l’épinette avec cette méthode. On commence par définir les paramètres et le modèle:\n\n\nCode\nusing DifferentialEquations, Plots, DataFrames\n\n# paramètres\nr = 5.0      # natalité\nK = 10.0     # mortalité\nα = 1.0      # taux max de prédation\nh = 0.5      # constante de demi-saturation\nyc = 7.0     # densité de prédateurs\n\npar_tordeuse = [r, K, α, h, yc] \n\n# temps d'intégration\ntspan = (0.0, 3.0)\ntstep = 0.02\n\n# condition initale\nx0step = 1.35\n\n# modèle\nfunction tordeuse(u, p, t)\n    r, K, α, h, yc = p\n    x = u[1]\n    dx = r*x*(1 - x/K) - α*x^2/(h^2 + x^2)*yc\nend\n\n\nNous définissons ensuite le problème d’intégration ainsi que l’intégrateur integrator:\n\nprob_tordeuse = ODEProblem(tordeuse,         # modèle\n                           x0step,           # condition initiale\n                           tspan,            # tspan\n                           par_tordeuse,     # paramètres\n                           saveat = tstep)   # option de sortie\n\nintegrator = init(prob_tordeuse)\n\nPour une utilisation dans une boucle pour simuler les trajectoires depuis différentes conditions initiales, nous définissons une fonction qui réinitialise l’intégrateur à la nouvelle condition, effectue la simulation (et transforme la solution en dataframe).\n\nfunction int_tordeuse(x0, integrator)\n    reinit!(integrator, x0)\n\n    sol_tordeuse = solve!(integrator)\n    sol_tordeuse = DataFrame(sol_tordeuse)\n    rename!(sol_tordeuse, :timestamp =&gt; :time, :value =&gt; :x)\nend\n\nOn construit ensuite le graphique et on fait une boucle pour intégrer et tracer les résultats:\n\n# conditions initiales\nx0vec = x0step:x0step:K\n\n# custom color palette\ninit_cgrad = palette([:steelblue, :lightblue], length(x0vec))\n\n# initialisation du graphique, équilibre nul\nP = plot(palette = init_cgrad,\n         legend = :right, \n         label = \"équilibres instables\",\n         title = \"Tordeuse du bourgeon de l\\'épinette\",\n         ylabel = \"densité de population \\$x(t)\\$\", \n         xlabel = \"temps \\$t\\$\",\n         margin = .5Plots.cm,\n         topmargin = 1Plots.cm)\n\n# boucle de plot avec intégration pour differentes conditions initiales\nfor x0 in x0vec\n    plot!(P, int_tordeuse(x0, integrator).time, \n          int_tordeuse(x0, integrator).x,\n          linewidth = 2,\n          label = \"\")\nend\n\ndisplay(P)      # actually shows the plot P\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nOn peut compléter la figure comme vu précédemment.\n\n\nCode\n# on définit des couleurs spécifiques depuis la palette :pal10\nmygreen = palette(:tab10)[3]\nmyorange = palette(:tab10)[2]\nmyblue = palette(:tab10)[1]\nmyred = palette(:tab10)[4]\n\nusing Polynomials\n\n# définition du monôme X\nX = Polynomial([0, 1])\n\n# définition du polynôme \npol = r*(1-X/K)*(h^2 + X^2)-α*X*yc\n\n# calcul des racines, réelles, positives et plus petites que K\neq_pos = roots(pol)                         # calcul des racines\neq_pos = real.(eq_pos[isreal.(eq_pos)])     # filtrage des racines réelles\neq_pos = eq_pos[(eq_pos .&gt; 0) .& (eq_pos .&lt;= K)] # filtrage des racines &gt;0 et &lt;K\n\nt2plot = collect(tspan)\n\n# initialisation du graphique, équilibre nul\nplot!(P, t2plot, zeros(length(t2plot)), \n         lw=2, \n         linestyle = :dash, \n         color = myorange, \n         palette = init_cgrad,\n         legend = :right, \n         label =\"équilibres instables\",\n         ylabel = \"densité de population \\$x(t)\\$\", \n         xlabel = \"temps \\$t\\$\",\n         margin = .5Plots.cm,\n         topmargin = 1Plots.cm)\n\n# équilibres positifs\nif length(eq_pos) == 1\n    plot!(P, t2plot, ones(length(t2plot)).*eq_pos, \n          color = mygreen, \n          label =\"équilibre stable\")\nelseif length(eq_pos) == 3\n    plot!(P, t2plot, ones(length(t2plot)).*eq_pos[1], \n          lw=2, \n          linestyle = :dash, \n          color = mygreen, \n          label =\"équilibres stables\")\n    plot!(P, t2plot, ones(length(t2plot)).*eq_pos[2], \n          lw=2, \n          linestyle = :dash, \n          color = myorange, \n          label = \"\")\n    plot!(P, t2plot, ones(length(t2plot)).*eq_pos[3], \n          lw=2, \n          linestyle = :dash, \n          color = mygreen, \n          label = \"\")\nend\n\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 1: bistabilité dans le modèle de la tordeuse du bourgeon de l’épinette\n\n\n\n\n\nLe code de la fonction int_tordeuse est plus simple avec l’integrator interface qu’en redéfinissant le problème d’intégration à chaque fois. Néanmoins, sur un problème avec x0step= 0.1 (soit ~100 trajectoires calculées), le gain en temps de calcul de cette méthode est marginal : 123 ms contre 128 ms avec la méthode précédente (test avec package BenchmarkTools.jl).\nLe gain en mémoire est plus sensible : 4.28 MiB contre 7.26 MiB, mais finalement marginal aussi sur des machines modernes pour de si petits problèmes d’intégration.\n\n\n\nUne autre approche plutôt que d’utiliser l’integrator interface, ou de redéfinir un nouveau problème d’intégration à chaque fois, serait de modifier le problème d’intégration via la fonction remake:\n\nfunction int_tordeuse2(x0, prob)\n    prob = remake(prob, u0 = x0)       # redéfinition du problème d'intégration\n    \n    sol_tordeuse = solve(prob)\n    sol_tordeuse = DataFrame(sol_tordeuse)\n    rename!(sol_tordeuse, :timestamp =&gt; :time, :value =&gt; :x)\nend\n\nP2 = plot(palette = init_cgrad,\n         legend = :right, \n         label = \"équilibres instables\",\n         title = \"Tordeuse du bourgeon de l\\'épinette\",\n         ylabel = \"densité de population \\$x(t)\\$\", \n         xlabel = \"temps \\$t\\$\",\n         margin = .5Plots.cm,\n         topmargin = 1Plots.cm)\n\nfor x0 in x0vec\n    plot!(P2, int_tordeuse2(x0, prob_tordeuse).time, \n          int_tordeuse2(x0, prob_tordeuse).x,\n          linewidth = 2,\n          label = \"\")\nend\n\nP2\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCette méthode est plus rapide que la redéfinition de problème d’intégration ou l’utilisation de l’integrator interface (113 ms dans les conditions vues plus haut) et intermédiaire en termes de mémoire utilisée (6.39 MiB). Le code est aussi simple que pour l’integrator interface.\nPar ailleurs la même approche via remake peut être utilisée pour redéfinir un problème d’intégration en modifiant les paramètres plutôt que la condition initiale, par exemple pour calculer un diagramme de bifurcations par force brute comme pour le modèle de Rosenzweig MacArthur."
  },
  {
    "objectID": "pop_interactions2.html#bifurcation-diagram-plot",
    "href": "pop_interactions2.html#bifurcation-diagram-plot",
    "title": "Populations en interaction (2)",
    "section": "Bifurcation diagram: plot",
    "text": "Bifurcation diagram: plot\n\n\nCode\nlines!(ax31, K_plot3, y_cmin,\n       color = Cycled(3),\n       linewidth = 2,\n       label = L\"cycle limite$$\")\n\nlines!(ax31, K_plot3, y_cmax,\n       color = Cycled(3),\n       linewidth = 2)\n\n\naxislegend(ax31, position = :lt, labelsize = 14)\n\nfig3"
  },
  {
    "objectID": "pop_interactions2.html#diagramme-de-bifurcation-final",
    "href": "pop_interactions2.html#diagramme-de-bifurcation-final",
    "title": "Populations en interaction (2)",
    "section": "Diagramme de bifurcation final",
    "text": "Diagramme de bifurcation final\nFinalement, on inclut les branches calculées dans le diagramme de bifurcations.\n\n\nCode\nlines!(ax31, K_plot3, y_cmin,\n       color = Cycled(3),\n       linewidth = 2,\n       label = L\"cycle limite$$\")\n\nlines!(ax31, K_plot3, y_cmax,\n       color = Cycled(3),\n       linewidth = 2)\n\n\naxislegend(ax31, position = :lt, labelsize = 14)\n\nfig3\n\n\n\n\n\nFigure 3: Diagramme de bifurcations du modèle de Rosenzweig MacArthur."
  },
  {
    "objectID": "index.html#installation-de-julia",
    "href": "index.html#installation-de-julia",
    "title": "Introduction",
    "section": "Installation de Julia",
    "text": "Installation de Julia\nLa façon la plus simple d’installer Julia est d’utiliser juliaup.\nSur Linux, installez curl sur votre système1. Puis dans un terminal :1 sudo apt install curl sur Ubuntu\n\ncurl -fsSL https://install.julialang.org | sh\n\net procédez à l’installation.\nFermez et réouvrez votre terminal (ou rechargez votre fichier de préférences comme vous l’indique l’installateur de juliaup) pour pouvoir exécuter Julia.\nPuis, si vous souhaitez utiliser Julia dans un notebook jupyter, installez le package IJulia depuis Julia comme suit2:2 le profil utilisé doit semble-t-il être administrateur, et si il est tout nouvellement créé un redémarrage peut s’avérer nécessaire si vous rencontrez une erreur à l’exécution de jupyterlab() ci-dessous\n\njulia # executer julia dans un terminal\n   _       _ _(_)_     |  Documentation: https://docs.julialang.org\n  (_)     | (_) (_)    |\n   _ _   _| |_  __ _   |  Type \"?\" for help, \"]?\" for Pkg help.\n  | | | | | | |/ _` |  |\n  | | |_| | | | (_| |  |  Version 1.9.4 (2023-11-14)\n _/ |\\__'_|_|_|\\__'_|  |  Official https://julialang.org/ release\n|__/                   |\n\njulia&gt; ]  # package mode\n(@v1.9) pkg&gt; add IJulia \n\nSi vous avez déjà jupyterlab installé, un noyau Julia est ensuite disponible. Sinon vous pouvez l’installer et le démarrer directement depuis Julia :\n\njulia&gt; using IJulia # tapez backspace d'abord \n                    # pour sortir du package mode\njulia&gt; jupyterlab()\n\n\n\nJulia a aussi un système de notebook propre Pluto.jl:\n\njulia&gt; ]   # package mode\n(@v1.9) pkg&gt; add Pluto\njulia&gt; using Pluto  # hit backspace first to exit package mode\n\n\n\nEnfin, une extension Julia est disponible pour VScode/VScodium.\nAllons-y !"
  },
  {
    "objectID": "annexe_LV_makieplot.html",
    "href": "annexe_LV_makieplot.html",
    "title": "Lotka Volterra avec Makie.jl",
    "section": "",
    "text": "L’objectif ici est de faire une jolie représentation graphique du modèle de Lotka Volterra avec la librairie graphique Makie.jl.\nOn reprend une partie du code de la page sur les populations en intéractions.\n\n\nCode\nusing DifferentialEquations\n\n# conditions initiales\nx0 = 1.0\ny0 = 2.3\netat0 = [x0, y0]\n\n# paramètres\nr = 1.0\nc = 1.0\nb = 1.0\nm = 1.0\npar_lovo = [r, c, b, m]\n\n# integration plus longue\ntspan = (0.0, 30.0)\ntstep = .01\n\n# définition du modèle\nfunction lovo(u, par, t)\n    r, c, b, m = par\n    x = u[1]\n    y = u[2]\n    dx = r*x - c*x*y\n    dy = b*x*y - m*y\n    [dx, dy]\nend\n\n# problème\nprob_lovo = ODEProblem(lovo, etat0, tspan, par_lovo, saveat = tstep)\n# intégration\nsol_lovo = solve(prob_lovo, reltol = 1e-6)\n\n\nL’objectif est de créer une figure avec trois panels. dans la colonne de gauche, le premier panel représentera la dynamique temporelle, le second le plan de phase, et dans la colonne de droite nous représenterons la figure 3D avec l’intégrale première.\n\nusing CairoMakie\n\n# on crée la figure avec un fond gris clair\nfig = Figure(backgroundcolor = RGBf(0.98, 0.98, 0.98),\n              size = (1000, 600)) \n\n# déclare les différents panels comme des éléments gridlayout contenant les plots\npanela = fig[1, 1] = GridLayout()\npanelb = fig[2, 1] = GridLayout()\npanelc = fig[:, 2] = GridLayout()\n\nOn commence par remplir le premier panel avec les dynamiques :\n\nax1 = Axis(panela[1,1],\n           #xlabel = L\"temps$$\",\n           ylabel = L\"densités de populations$$\",\n           title=\"Dynamiques\")\n\n# pour avoir un xlabel plus proche de l'axe on le définit séparément en réglant manuellement l'espacement/padding\nLabel(panela[1,1,Bottom()], L\"temps$$\", padding=(0,0,0,20))\n\nlines!(ax1, sol_lovo.t, sol_lovo[1,:],\n       linewidth = 2,\n       label = L\"$x(t)$\")\nlines!(ax1, sol_lovo.t, sol_lovo[2,:],\n       linewidth = 2,\n       label = L\"$y(t)$\")\n\naxislegend(ax1, position = :lt, \n           labelsize = 12, \n           padding = (5,5,0,0),\n           rowgap = -5)\n\nfig\n\n\n\n\nPuis on remplit le second panel avec le plan de phase :\n\nax2 = Axis(panelb[1,1],\n           xlabel = L\"population $x$\",\n           ylabel = L\"population $y$\",\n           title = \"Plan de phase\",\n           xticks = (0:.5:2),\n           yticks = (0:.5:2))\n\n# champs de vecteur\nscale = 10\nxrange = range(0, 2.75, length=11)  \nyrange = range(0, 2.75, length=11)\n\nderx = [lovo([x y], par_lovo, 0)[1]/scale for x in xrange, y in yrange]\ndery = [lovo([x y], par_lovo, 0)[2]/scale for x in xrange, y in yrange]\n\narrows!(ax2, xrange, yrange, derx, dery, \n        color = :lightgray, \n        arrowsize = 10)\n\n# nullclines\nlines!(ax2, xrange, [r/c for x in xrange],\n       color = Cycled(2),\n       linewidth = 2,\n       label = L\"$\\dot{x}$ nullcline\")\nlines!(ax2, [0 for y in yrange], yrange,\n       linewidth = 2,\n       color = Cycled(2))\nlines!(ax2, [m/b for y in yrange], yrange,\n       color = Cycled(3),\n       linewidth = 2,\n       label = L\"$\\dot{y}$ nullcline\")\nlines!(ax2, xrange, [0 for y in yrange],\n       color = Cycled(3),\n       linewidth = 2)\n\n# équilibres\nscatter!(ax2, Point2f(0,0),\n         color = Cycled(4))\nscatter!(ax2, Point2f(m/b, r/c),\n         color = Cycled(4))\n\n# trajectoire\nlines!(ax2, sol_lovo[1, :], sol_lovo[2, :],\n       color = Cycled(1),\n       linewidth = 2)\n\nxlims!(ax2, -0.1, 2.75)\nylims!(ax2, -0.1, 2.75)\n\naxislegend(ax2, position = :rt, \n           labelsize = 12, \n           padding = (5,5,0,0), \n           rowgap = -5)\n\nfig\n\n\n\n\nFinalement on remplit le troisième panel avec la représentation 3D, en commencant par redéfinir l’intégrale première\n\n# l'intégrale première\nfunction int_prem(x, y, par = par_lovo)\n      r, c, b, m = par\n      -r*log(y) + c*y - m*log(x) + b*x\nend\n\n\n# système d'axe 3D en première colonne de panel c, avec réglage de la caméra\nax3 = Axis3(panelc[1, 1], \n            title = \"Intégrale première\",\n            titlegap = -50,\n            xlabel = L\"population $x$\",\n            ylabel = L\"population $y$\",\n            zlabel = L\"$H(x,y)$\",\n            azimuth = 0.5,\n            elevation = 0.2)\n\n# grille x, y\nxsurf = .2: .1: 3\nysurf = .2:.1: 3\n\n# calcul de la surface via une compréhension de liste\nhsurf = [int_prem(x, y, par_lovo) for x in xsurf, y in ysurf]\nhplane = [int_prem(x0, y0, par_lovo) for x in xsurf, y in ysurf]\n\n# tracé de H(x,y) et du plan z = H(x0,y0)\nhs = surface!(ax3, xsurf, ysurf, hsurf, alpha=.5)\nsurface!(ax3, xsurf, ysurf, hplane, color = fill(:red,100,100), alpha = .3)\n\n# ajout de la trajectoire simulée\nlines!(ax3, sol_lovo[1,:], sol_lovo[2,:], \n       [int_prem(x0, y0) for x in sol_lovo[1,:]],\n       color = Cycled(4),\n       linewidth = 3)\n\n# ajout d'une colorbar reprise sur le plot de H(x,y) avec une hauteur relative sur la colonne\n# la colorbar est en 2e colonne du panelc\nColorbar(panelc[1, 2], hs, height = Relative(.55))\n\n# colonne 2 plus large\ncolsize!(fig.layout, 2, Auto(1.5))\n# modification des espacements entre lignes et colonnes\ncolgap!(fig.layout, 60)\ncolgap!(panelc, -10)\nrowgap!(fig.layout, 10)\n\n# titre général\nsupertitle = Label(fig[0, :], \"Modèle de Lotka Volterra\", fontsize = 30)\n\nfig\n\n\n\n\nFigure 1: Figure illustrant le comportement du modèle de Lotka Volterra\n\n\n\n\net voilà !\n\n\n\n\n\nReusehttps://creativecommons.org/licenses/by-nc/4.0/"
  },
  {
    "objectID": "annexe_LV_makieplot.html#lotka-volterra-avec-makie.jl",
    "href": "annexe_LV_makieplot.html#lotka-volterra-avec-makie.jl",
    "title": "Matériel supplémentaire",
    "section": "",
    "text": "Juste une jolie représentation graphique du modèle de Lotka Volterra avec la librairie graphique Makie.jl."
  },
  {
    "objectID": "annexe_FisherKPP.html",
    "href": "annexe_FisherKPP.html",
    "title": "Fisher KPP with Julia",
    "section": "",
    "text": "This implementation of numerical solve of a reaction diffusion equation is based on the presentation of the package MethodOfLines.jl at JuliaCon 2022 by A. Jones."
  },
  {
    "objectID": "annexe_FisherKPP.html#fisher-kpp-equation",
    "href": "annexe_FisherKPP.html#fisher-kpp-equation",
    "title": "Fisher KPP with Julia",
    "section": "Fisher KPP equation",
    "text": "Fisher KPP equation\nThe Fisher KPP equation (Fisher’s version) reads (Fisher (1937), Kolmogorov, Petrovskii, and Piskunov (1937)):\n\n\\frac{\\partial u}{\\partial t} = ru\\left(1-u\\right) + D \\frac{\\partial^2 u}{\\partial x^2},\n\nwith u(t,x) the population density at time t and position x (scaled to the local carrying capacity K), r the intrinsic growth rate of the population, and D the diffusion coefficient."
  },
  {
    "objectID": "annexe_FisherKPP.html#packages",
    "href": "annexe_FisherKPP.html#packages",
    "title": "Fisher KPP with Julia",
    "section": "Packages",
    "text": "Packages\nLet us first import the packages used for the simulation:\n\nusing MethodOfLines, \n      ModelingToolkit,\n      DomainSets, \n      OrdinaryDiffEq, \n      Plots, \n      LaTeXStrings"
  },
  {
    "objectID": "annexe_FisherKPP.html#model-definition",
    "href": "annexe_FisherKPP.html#model-definition",
    "title": "Fisher KPP with Julia",
    "section": "Model definition",
    "text": "Model definition\nMethodsOfLines.jl makes use of ModelingToolkit.jl to symbolically define the model to integrate.\nLet us first define the time and space parameters:\n\n@parameters t x\n\nThe model parameters:\n\n@parameters r D\n\nNow the variable u(t,x):\n\n@variables u(..)\n\nAnd finally the derivatives:\n\nDt = Differential(t)\nDx = Differential(x)\nDxx = Differential(x)^2\n\nWe can now define the model symbolically through:\n\neq = Dt(u(t, x)) ~ r * u(t,x) * (1-u(t,x)) + D * Dxx(u(t,x))\n\n \\begin{equation}\n\\frac{\\mathrm{d}}{\\mathrm{d}t} u\\left( t, x \\right) = D \\frac{\\mathrm{d}}{\\mathrm{d}x} \\frac{\\mathrm{d}}{\\mathrm{d}x} u\\left( t, x \\right) + r u\\left( t, x \\right) \\left( 1 - u\\left( t, x \\right) \\right)\n\\end{equation}"
  },
  {
    "objectID": "annexe_FisherKPP.html#domains-of-integration",
    "href": "annexe_FisherKPP.html#domains-of-integration",
    "title": "Fisher KPP with Julia",
    "section": "Domains of integration",
    "text": "Domains of integration\nLet us introduce some parameters for space and time domains:\n\nx_max = 30.0\nt_max = 14.0\n\nAnd the domains of integration:\n\ndomain = [x ∈ Interval(0.0, x_max),\n          t ∈ Interval(0.0, t_max)]\n\nWe also introduce (initial and) boundary conditions:\n\nic_bc = [u(0.0, x) ~ 0.0,\n         u(t, 0.0) ~ 1.0,\n         u(t, x_max) ~ 0.0]"
  },
  {
    "objectID": "annexe_FisherKPP.html#simulation",
    "href": "annexe_FisherKPP.html#simulation",
    "title": "Fisher KPP with Julia",
    "section": "Simulation",
    "text": "Simulation\nWe define the model to be integrated as a PDESystem, from the equation eq, the initial and boundary conditions ic_bc, the domains of integration domain, the time and space parameters t and x, the solution we want to retrieve u(t,x), and the model parameters r and D:\n\n@named sys = PDESystem(eq, ic_bc, domain, [t, x], [u(t,x)], [r =&gt; 1.0, D =&gt; 1.0])\n\nWe set up the discretization of space, through MethodOfLines.jl:\n\ndx = 0.1\ndiscretization = MOLFiniteDifference([x =&gt; dx], t)\n\nAnd we set up the (ODE) problem to be integrated:\n\nprob = discretize(sys, discretization)\n\nAnd we finally integrate it through the OrdinaryDiffEq.jl solver with Tsit5 algorithm.\n\nsol = solve(prob, Tsit5(), saveat = .1)"
  },
  {
    "objectID": "annexe_FisherKPP.html#graphical-representation",
    "href": "annexe_FisherKPP.html#graphical-representation",
    "title": "Fisher KPP with Julia",
    "section": "Graphical representation",
    "text": "Graphical representation\nWe retrieve the components of the solution for easier manipulation:\n\ngridx = sol[x]\ngridt = sol[t]\nsolu = sol[u(t,x)]\n\nAnd we plot the animation of the solution through time:\n\nanim = @animate for i in eachindex(gridt)\n    plot(gridx, solu[i, :],\n         xlabel = \"position \"*L\"$x$\",\n         ylabel = \"population density \"*L\"$u$\", \n         label = L\"$u(x,t)$\", \n         title = \"t=$(gridt[i])\")\nend\n\ngif(anim, \"fisherKPP.gif\", fps = 10)\n\n\n\n\n\n\nAnd that’s it !"
  },
  {
    "objectID": "annexes.html",
    "href": "annexes.html",
    "title": "Matériel supplémentaire",
    "section": "",
    "text": "Les pages listées ici contiennent du matétiel supplémentaire pour compléments plus avancés :\n\ntracer une jolie figure pour Lotka Volterra avec Makie.jl\nutiliser l’interface integrator de DifferentialEquations.jl ou la redéfinition de problèmes d’intégration via remake\nsimuler une équation de réaction-diffusion en une dimension : le modèle de Fisher-KPP\n\n\n\n\n\n\nReusehttps://creativecommons.org/licenses/by-nc/4.0/"
  }
]