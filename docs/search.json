[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Présentation",
    "section": "",
    "text": "Ces pages proposent une introduction à la simulation d’équations différentielles avec Julia, centrée sur la simulation de modèles classiques en dynamique des populations.\nLe document est structuré comme suit :\n\nLa section sur les populations isolées introduit les bases en dimension 1 (modèle de Malthus, modèle logistique et effets Allee)\nla section sur les populations exploitées introduit les diagrammes de bifurcations et la dimension 2 (prélèvements et effets Allee, interactions insectes-oiseaux)\nla section sur les populations en interaction approfondit la dimension 2, notamment via les représentations dans l’espace d’état, et traite des interactions entre populations sous l’angle des modèles proies-prédateurs (modèle de Lotka Volterra et modèle de Rosenzweig MacArthur)\n\nAllons-y !\n\n\n\n\n\nReusehttps://creativecommons.org/licenses/by-nc/4.0/"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "A Propos",
    "section": "",
    "text": "Ces pages ont été générées avec Quarto, et Julia (version 1.9.4).\nLes principaux packages utilisés sont DifferentialEquations.jl, et Plots.jl\n\n\n\n\n\nReusehttps://creativecommons.org/licenses/by-nc/4.0/"
  },
  {
    "objectID": "pop_isolees.html",
    "href": "pop_isolees.html",
    "title": "Populations isolées",
    "section": "",
    "text": "Nous considérons le modèle proposé par Malthus (1798) : \n\\dot x = (n-m)x,\n\\tag{1} avec n le taux de natalité, et m le taux de mortalité.\n\n\nPour simuler ce modèle, c’est à dire intégrer numériquement les solutions au problème de Cauchy correspondant à l’Equation 1 avec x(0)=x_0\\geq0, nous allons utiliser les routines de DifferentialEquations.jl avec la méthode par défaut. Nous utiliserons aussi le package Plots.jl pour les représentations graphiques.\n\nusing Plots, DifferentialEquations\n\n\n\n\nNous définissions la condition initiale de la simulation :\n\nx0 = 0.1\n\nNous définissons les paramètres, et les encapsulons dans un vecteur de paramètres :\n\nn = 3.0     # natalité\nm = 2.0     # morrtalité\npar_malthus = [n, m] # packing\n\nEnfin, les propriétés du temps d’intégration :\n\ntspan = (0.0, 10.0)\ntstep = 0.1\n\n\n\n\nOn définit le modèle comme une fonction renvoyant la dérivée de x (comme SVector) en fonction de l’état, de paramètres, et du temps. L’ordre des arguments est important, c’est sous cette forme que les routines d’intégration attendent le modèle.\n\nfunction malthus(u, p, t)\n    n, m = p        # unpacking\n    x = u[1]        # use x notation\n    dx = (n-m)x     # return derivative\nend\n\n\n\n\nOn commence par définir le problème de Cauchy à intégrer, comme un ODEProblem avec arguments: le modèle, la condition initiale, les bornes d’intégration, les paramètres ainsi que l’option saveat = tstep permettant de récupérer la solution tout les tstep pas de temps (il y a plein d’options de sortie de l’intégration, dont même une fonction du temps !)\n\nprob_malthus = ODEProblem(malthus,          # modèle\n                          x0,               # condition initiale\n                          tspan,            # tspan\n                          par_malthus,      # paramètres\n                          saveat = tstep)   # option de sortie\n\nOn intègre le modèle via solve, défini par DifferentialEquations.jl pour des struct de type ODEProblem :\n\nsol_malthus = solve(prob_malthus)\n\nLe type de solution renvoyée par le solveur est assez complexe et comprend de nombreux champs informatifs sur le calcul. On peut accéder au temps de simulation via sol_malthus.t :\n\nfirst(sol_malthus.t, 3)\n\n3-element Vector{Float64}:\n 0.0\n 0.1\n 0.2\n\n\nainsi qu’aux valeurs de la variable x calculées le long du temps via sol_matlhus.u :\n\nfirst(sol_malthus.u, 3)\n\n3-element Vector{Float64}:\n 0.1\n 0.1105170918098962\n 0.12214028021690636\n\n\nMême si ce n’est pas indispensable, il est possible de transformer la solution renvoyée facilement en DataFrame, qui peut permettre des manipulations plus faciles.\n\nusing DataFrames\n\nsol_malthus = DataFrame(sol_malthus)\nrename!(sol_malthus, :timestamp =&gt; :time, :value =&gt; :x)\n\nsi bien que :\n\nfirst(sol_malthus, 3)\n\n3×2 DataFrame\n\n\n\nRow\ntime\nx\n\n\n\nFloat64\nFloat64\n\n\n\n\n1\n0.0\n0.1\n\n\n2\n0.1\n0.110517\n\n\n3\n0.2\n0.12214\n\n\n\n\n\n\n\n\n\nOn peut représenter graphiquement la simulation de la croissance de la population au cours du temps (ici via le dataframe).\n\nplot(sol_malthus.time, sol_malthus.x,\n    palette = :tab10,\n    linewidth = 2,\n    title = \"\\n Modèle de Malthus \\$n=$n, m=$m\\$\",\n    label = \"population \\$x\\$\",  \n    ylabel = \"densité de population \\$x(t)\\$\", \n    xlabel = \"temps \\$t\\$\",\n    margin = .5Plots.cm,\n    topmargin = 1Plots.cm)"
  },
  {
    "objectID": "pop_interactions.html",
    "href": "pop_interactions.html",
    "title": "Populations en interaction",
    "section": "",
    "text": "Reusehttps://creativecommons.org/licenses/by-nc/4.0/"
  },
  {
    "objectID": "pop_exploitees.html",
    "href": "pop_exploitees.html",
    "title": "Populations exploitées",
    "section": "",
    "text": "Nous reprenons le modèle précédent sur l’effet Allee mais en prenant en compte des prélèvements externes avec un effort (taux) de prélèvement E : \n\\dot x = r x \\left(\\frac{x}{\\epsilon}-1\\right)\\left(1-\\frac{x}{K}\\right)-Ex.\n\\tag{1}\nLa simulation de ce modèle pour différentes valeurs de E (par exemple E=0.2 ou E=0.85) ne présente aucune difficulté supplémentaire.\nNous allons maintenant nous intéresser à une situation où l’effort de prélèvement E varie au cours du temps entre une valeur soutenable E_s (par exemple 0.2), et une valeur excessive E_x (par exemple 0.85).\nL’attendu théorique est que si les prélèvements sont maintenus à une valeur excessive E_x trop longtemps, la population disparait irrémédiablement même si les prélèvements sont par la suite ramenés à une valeur initialement soutenable E_s.\n\n\n\nusing DifferentialEquations, Plots\n\nDéfinissons une fonction effort() dépendant du temps, qui renvoit :\n\nE_s~ si ~t&lt;T_s\nE_x~ si ~t\\in [T_s+T_x[\nà nouveau E_s~ si ~t\\geq T_s+T_x\n\n\n# paramètres\nE_s = 0.2\nE_x = 0.85\nT_s = 10.0\nT_x = 9.0\n\npar_effort = [E_s, E_x, T_s, T_x]\n\nfunction effort(t, pars)\n    E_s, E_x, T_s, T_x = pars\n\n    if t &lt; T_s || t &gt;= T_s + T_x\n        return E_s\n    elseif t &gt;= T_s && t &lt; T_s + T_x\n        return E_x\n    end\nend\n\nLa fonction correspond bien à nos hypothèses :\n\n\nCode\ntime2plot = 0: .1: 30\n\nplot(time2plot, [effort(t, par_effort) for t in time2plot],\n     palette = :tab10,\n     linewidth = 2,\n     label = \"\\$E(t)\\$\",\n     xlabel = \"temps\",\n     ylabel = \"\\$E(t)\\$\",\n     title = \"Effort de pêche \\$E(t)\\$\",\n     margin = .5Plots.cm,\n     topmargin = 1Plots.cm)\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNous définissons les paramètres du modèle, la condition initiale et le temps d’intégration :\n\nx0 = 10.\n\ntspan = (0.0, 30.0)\ntstep = 0.1\n\nr = 1.\nK = 10.\nepsilon = 2.                 # seuil de Allee\npar_allee = [r, K, epsilon] # packing\ntspan_allee = (0.0, 3.0)\n\nNous définissons le système dynamique comme précédemment, à la différence que nous prévoyons de surcharger l’argument p dans le problème d’intégration sous forme d’un vecteur comprennant :\n\nle vecteur de paramètres par_allee en première position\nle vecteur de paramètres par_effort en seconde position\net la fonction effort en troisième position\n\n\nfunction allee_evar(u, p, t)\n    r, K, epsilon = p[1]        # unpacking model parameters\n    par_effort = p[2]           # unpacking fishing effort parameters\n    E = p[3]                    # unpacking fishing effort function\n    x = u[1]                    # use x notation\n    \n    dx = r*x*(x/epsilon - 1)*(1 - x/K) - E(t, par_effort)*x\nend\n\nL’intégration en elle-même suit le shéma vu précédemment, si ce n’est que l’argument de paramètres doit bien refléter ce qui est attendu par la fonction allee_evar(). La simulation en elle-même est effectuée avec une modification de la précision relative de l’intégration reltol = 1e-6, la précision par défaut n’étant pas suffisante ici.\n\nprob_allee_evar = ODEProblem(allee_evar, \n                             x0, \n                             tspan, \n                             [par_allee, par_effort, effort], \n                             saveat = tstep)\n\nsol_allee_evar = solve(prob_allee_evar, reltol = 1e-6)\n\nFinalement, nous pouvons représenter graphiquement la solution contre le temps. Ici, on choisit de ne pas passer par un dataframe, pour illustration.\n\nplot(sol_allee_evar,\n     label = \"\\$x(t)\\$\",\n     linewidth = 2,\n     xlabel = \"temps\",\n     ylabel = \"densité de population \\$x(t)\\$\",\n     title = \"Effort de pêche variant dans le temps\",\n     palette = :tab10,\n     legend = :left,\n     margin = .5Plots.cm,\n     topmargin = 1Plots.cm)"
  },
  {
    "objectID": "pop_isolees.html#sec-malthus",
    "href": "pop_isolees.html#sec-malthus",
    "title": "Populations isolées",
    "section": "",
    "text": "Nous considérons le modèle proposé par Malthus (1798) : \n\\dot x = (n-m)x,\n\\tag{1} avec n le taux de natalité, et m le taux de mortalité.\n\n\nPour simuler ce modèle, c’est à dire intégrer numériquement les solutions au problème de Cauchy correspondant à l’Equation 1 avec x(0)=x_0\\geq0, nous allons utiliser les routines de DifferentialEquations.jl avec la méthode par défaut. Nous utiliserons aussi le package Plots.jl pour les représentations graphiques.\n\nusing Plots, DifferentialEquations\n\n\n\n\nNous définissions la condition initiale de la simulation :\n\nx0 = 0.1\n\nNous définissons les paramètres, et les encapsulons dans un vecteur de paramètres :\n\nn = 3.0     # natalité\nm = 2.0     # morrtalité\npar_malthus = [n, m] # packing\n\nEnfin, les propriétés du temps d’intégration :\n\ntspan = (0.0, 10.0)\ntstep = 0.1\n\n\n\n\nOn définit le modèle comme une fonction renvoyant la dérivée de x (comme SVector) en fonction de l’état, de paramètres, et du temps. L’ordre des arguments est important, c’est sous cette forme que les routines d’intégration attendent le modèle.\n\nfunction malthus(u, p, t)\n    n, m = p        # unpacking\n    x = u[1]        # use x notation\n    dx = (n-m)x     # return derivative\nend\n\n\n\n\nOn commence par définir le problème de Cauchy à intégrer, comme un ODEProblem avec arguments: le modèle, la condition initiale, les bornes d’intégration, les paramètres ainsi que l’option saveat = tstep permettant de récupérer la solution tout les tstep pas de temps (il y a plein d’options de sortie de l’intégration, dont même une fonction du temps !)\n\nprob_malthus = ODEProblem(malthus,          # modèle\n                          x0,               # condition initiale\n                          tspan,            # tspan\n                          par_malthus,      # paramètres\n                          saveat = tstep)   # option de sortie\n\nOn intègre le modèle via solve, défini par DifferentialEquations.jl pour des struct de type ODEProblem :\n\nsol_malthus = solve(prob_malthus)\n\nLe type de solution renvoyée par le solveur est assez complexe et comprend de nombreux champs informatifs sur le calcul. On peut accéder au temps de simulation via sol_malthus.t :\n\nfirst(sol_malthus.t, 3)\n\n3-element Vector{Float64}:\n 0.0\n 0.1\n 0.2\n\n\nainsi qu’aux valeurs de la variable x calculées le long du temps via sol_matlhus.u :\n\nfirst(sol_malthus.u, 3)\n\n3-element Vector{Float64}:\n 0.1\n 0.1105170918098962\n 0.12214028021690636\n\n\nMême si ce n’est pas indispensable, il est possible de transformer la solution renvoyée facilement en DataFrame, qui peut permettre des manipulations plus faciles.\n\nusing DataFrames\n\nsol_malthus = DataFrame(sol_malthus)\nrename!(sol_malthus, :timestamp =&gt; :time, :value =&gt; :x)\n\nsi bien que :\n\nfirst(sol_malthus, 3)\n\n3×2 DataFrame\n\n\n\nRow\ntime\nx\n\n\n\nFloat64\nFloat64\n\n\n\n\n1\n0.0\n0.1\n\n\n2\n0.1\n0.110517\n\n\n3\n0.2\n0.12214\n\n\n\n\n\n\n\n\n\nOn peut représenter graphiquement la simulation de la croissance de la population au cours du temps (ici via le dataframe).\n\nplot(sol_malthus.time, sol_malthus.x,\n    palette = :tab10,\n    linewidth = 2,\n    title = \"\\n Modèle de Malthus \\$n=$n, m=$m\\$\",\n    label = \"population \\$x\\$\",  \n    ylabel = \"densité de population \\$x(t)\\$\", \n    xlabel = \"temps \\$t\\$\",\n    margin = .5Plots.cm,\n    topmargin = 1Plots.cm)"
  },
  {
    "objectID": "pop_isolees.html#préliminaires",
    "href": "pop_isolees.html#préliminaires",
    "title": "Populations isolées",
    "section": "Préliminaires",
    "text": "Préliminaires\nPour simuler ce modèle, c’est à dire intégrer numériquement les solutions au problème de Cauchy correspondant à l’Equation 1 avec x(0)=x_0\\geq0, nous allons utiliser les routines de DifferentialEquations.jl avec une méthode utilisant des tableaux statiques pour la rapidité d’exécution (package StaticArrays.jl). Nous utiliserons aussi le package Plots.jl pour les représentations graphiques.\n\nusing Plots, DifferentialEquations, StaticArrays"
  },
  {
    "objectID": "pop_isolees.html#conditions-initiales-paramètres-et-temps",
    "href": "pop_isolees.html#conditions-initiales-paramètres-et-temps",
    "title": "Populations isolées",
    "section": "Conditions initiales, paramètres et temps",
    "text": "Conditions initiales, paramètres et temps\nNous définissions la condition initiale de la simulation, et l’assignons dans un vecteur statique etat0 :\n\nx0 = 0.1\netat0 = @SVector [x0]\n\nNous définissons les paramètres, et les encapsulons dans un vecteur de paramètres :\n\nn = 3.0     # natalité\nm = 2.0     # morrtalité\npar_malthus = [n, m]\n\nEnfin, les propriétés du temps d’intégration :\n\ntspan = (0.0, 5.0)\ntstep = 0.1"
  },
  {
    "objectID": "pop_isolees.html#section",
    "href": "pop_isolees.html#section",
    "title": "Populations isolées",
    "section": "",
    "text": "On peut représenter graphiquement la simulation de la croissance de la population au cours du temps (ici via le dataframe).\n\nplot(sol_malthus.time, sol_malthus.x,\n    palette = :tab10,\n    linewidth = 2,\n    title = \"\\n Modèle de Malthus\",\n    label = \"population \" * L\"x\",  # latex strings, makrdown latex is off in labels\n    ylabel = \"densité de population \\$x(t)\\$\", # latex markdown is ok in axis label\n    xlabel = \"temps \\$t\\$\",\n    margin = .5Plots.cm,\n    topmargin = 1Plots.cm)"
  },
  {
    "objectID": "pop_isolees.html#sec-logistic",
    "href": "pop_isolees.html#sec-logistic",
    "title": "Populations isolées",
    "section": "Le modèle logistique",
    "text": "Le modèle logistique\nNous considérons ici le modèle “logistique” proposé par Verhulst (1838) :\n\n\\dot x = r x \\left(1-\\frac{x}{K}\\right),\n\\tag{2} avec r le taux de croissance intrinsèque de la population et K la capacité de charge de l’environnement.\nIl n’y a pas de difficulté particulière par rapport aux simulations précedentes. On va réutiliser la condition initiale et les paramètres de temps définis précédemment.\nIl faut cependant définir les paramètres du modèle Equation 2 :\n\n\nCode\nr = 1.0      # natalité\nK = 10.0     # morrtalité\npar_logistic = [r, K] # packing\n\n\nainsi que le nouveau système dynamique :\n\n\nCode\nfunction logistic(u, p, t)\n    r, K = p            # unpacking\n    x = u[1]            # use x notation\n    dx = r*x*(1-x/K)    # return derivative\nend\n\n\net le problème de Cauchy correspondant :\n\n\nCode\nprob_logistic = ODEProblem(logistic,        # modèle\n                          x0,               # condition initiale\n                          tspan,            # tspan\n                          par_logistic,     # paramètres\n                          saveat = tstep)   # option de sortie\n\n\nOn simule et on transforme la solution en dataframe :\n\n\nCode\nsol_logistic = solve(prob_logistic)\n\nsol_logistic = DataFrame(sol_logistic)\nrename!(sol_logistic, :timestamp =&gt; :time, :value =&gt; :x)\n\n\nOn trace la solution, en rajoutant les équilibres stable (x=K) et instable (x=0) :\n\n\nCode\n# solution\nplot(sol_logistic.time, sol_logistic.x,\n    palette = :tab10,\n    linewidth = 2,\n    title = \"\\n Modèle logistique \\$r=$r, K=$K\\$\",\n    label = \"population \\$x\\$\",  \n    legend = :right,\n    ylabel = \"densité de population \\$x(t)\\$\", \n    xlabel = \"temps \\$t\\$\",\n    margin = .5Plots.cm,\n    topmargin = 1Plots.cm)\n\n# équilibre 0\nplot!(sol_logistic.time, zeros(length(sol_logistic.time)),\n      color = \"red\",\n      linewidth = 2,\n      linestyle = :dash,\n      linealpha = .5,\n      label = \"équilibre instable\")\n\n# équilibre 1\nplot!(sol_logistic.time, ones(length(sol_logistic.time)).*K,\n      color = \"green\",\n      linewidth = 2,\n      linestyle = :dash,\n      linealpha = .5,\n      label = \"équilibre stable\")"
  },
  {
    "objectID": "pop_isolees.html#effets-allee",
    "href": "pop_isolees.html#effets-allee",
    "title": "Populations isolées",
    "section": "Effets Allee",
    "text": "Effets Allee"
  },
  {
    "objectID": "pop_isolees.html#sec-allee",
    "href": "pop_isolees.html#sec-allee",
    "title": "Populations isolées",
    "section": "Effets Allee",
    "text": "Effets Allee\nOn s’intéresse à un modèle de dynamique de population avec “effets Allee forts”, souvent attribué à Gruntfest, Arditi, and Dombrovsky (1997)1 :1 mais de nombreuses variations de cette forme polynomiale existent dans la littérature depuis Bazykin (1985)\n\n\\dot x = r x \\left(\\frac{x}{\\epsilon}-1\\right)\\left(1-\\frac{x}{K}\\right),\n\\tag{3} avec r le taux de croissance intrinsèque de la population (par analogie avec la logistique), K la capacité de charge de l’environnement et \\epsilon le seuil en dessous duquel la population n’est pas viable (‘seuil de Allee’).\nNous souhaitons illustrer la bistabilité caractéristique du comportement de ce modèle à partir de la simulation depuis plusieurs conditions initiales.\nCommençons par définir le modèle et les paramètres (en conservant les r et K précédents):\n\n\nCode\nepsilon = 2                 # seuil de Allee\npar_allee = [r, K, epsilon] # packing\ntspan_allee = (0.0, 3.0)\n\nfunction allee(u, p, t)\n    r, K, epsilon = p        # unpacking\n    x = u[1]                 # use x notation\n    dx = r*x*(x/epsilon - 1)*(1 - x/K)     # return derivative\nend\n\n\nNous définissons une fonction qui réalise une simulation en un seul appel :\n\nfunction int_allee(x0, tspan = tspan_allee, param = par_allee)\n    prob_allee = ODEProblem(allee,          # modèle\n                          x0,               # condition initiale\n                          tspan,            # tspan\n                          param,            # paramètres\n                          saveat = tstep)   # option de sortie\n    \n    sol_allee = solve(prob_allee)\n    sol_allee = DataFrame(sol_allee)\n    rename!(sol_allee, :timestamp =&gt; :time, :value =&gt; :x)\nend\n\nNous définissons un vecteur de conditions initiales différentes :\n\nx0step = 1.35\nx0vec = x0step:x0step:K\n\nFinalement on réalise la figure, en initiant un graphique P et en faisant une boucle pour tracer chacune des simulations correspondant aux différentes conditions initiales :\n\n# custom color palette\ninit_cgrad = palette([:steelblue, :lightblue], length(x0vec))\n\n# initialisation du graphique\nP = plot(palette = init_cgrad,\n         title = \"\\n Modèle à effets Allee \\$r=$r, K=$K\\$, \\$ϵ=$epsilon\\$\",\n         legend = :right,\n         ylabel = \"densité de population \\$x(t)\\$\", \n         xlabel = \"temps \\$t\\$\",\n         margin = .5Plots.cm,\n         topmargin = 1Plots.cm)\n\n# boucle de plot avec intégration pour differentes conditions initiales\nfor x0 in x0vec\n    plot!(P, int_allee(x0).time, int_allee(x0).x,\n          linewidth = 2,\n          label = \"\")\nend\n\n# équilibres\nplot!(P, int_allee(0).time, zeros(length(int_allee(0).time)),\n      color = \"green\",\n      linewidth = 2,\n      linestyle = :dash,\n      linealpha = .5,\n      label = \"équilibre stable\")\nplot!(P, int_allee(0).time, ones(length(int_allee(0).time)).*epsilon,\n      color = \"red\",\n      linewidth = 2,\n      linestyle = :dash,\n      linealpha = .5,\n      label = \"équilibre instable\")\nplot!(P, int_allee(0).time, ones(length(int_allee(0).time)).*K,\n      color = \"green\",\n      linewidth = 2,\n      linestyle = :dash,\n      linealpha = .5,\n      label = \"\")\n\ndisplay(P)      # actually shows the plot P\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPassons aux populations exploitées."
  },
  {
    "objectID": "pop_exploitees.html#sec-allee-prelev",
    "href": "pop_exploitees.html#sec-allee-prelev",
    "title": "Populations exploitées",
    "section": "",
    "text": "Nous reprenons le modèle précédent sur l’effet Allee mais en prenant en compte des prélèvements externes avec un effort (taux) de prélèvement E : \n\\dot x = r x \\left(\\frac{x}{\\epsilon}-1\\right)\\left(1-\\frac{x}{K}\\right)-Ex.\n\\tag{1}\nLa simulation de ce modèle pour différentes valeurs de E (par exemple E=0.2 ou E=0.85) ne présente aucune difficulté supplémentaire.\nNous allons maintenant nous intéresser à une situation où l’effort de prélèvement E varie au cours du temps entre une valeur soutenable E_s (par exemple 0.2), et une valeur excessive E_x (par exemple 0.85).\nL’attendu théorique est que si les prélèvements sont maintenus à une valeur excessive E_x trop longtemps, la population disparait irrémédiablement même si les prélèvements sont par la suite ramenés à une valeur initialement soutenable E_s.\n\n\n\nusing DifferentialEquations, Plots\n\nDéfinissons une fonction effort() dépendant du temps, qui renvoit :\n\nE_s~ si ~t&lt;T_s\nE_x~ si ~t\\in [T_s+T_x[\nà nouveau E_s~ si ~t\\geq T_s+T_x\n\n\n# paramètres\nE_s = 0.2\nE_x = 0.85\nT_s = 10.0\nT_x = 9.0\n\npar_effort = [E_s, E_x, T_s, T_x]\n\nfunction effort(t, pars)\n    E_s, E_x, T_s, T_x = pars\n\n    if t &lt; T_s || t &gt;= T_s + T_x\n        return E_s\n    elseif t &gt;= T_s && t &lt; T_s + T_x\n        return E_x\n    end\nend\n\nLa fonction correspond bien à nos hypothèses :\n\n\nCode\ntime2plot = 0: .1: 30\n\nplot(time2plot, [effort(t, par_effort) for t in time2plot],\n     palette = :tab10,\n     linewidth = 2,\n     label = \"\\$E(t)\\$\",\n     xlabel = \"temps\",\n     ylabel = \"\\$E(t)\\$\",\n     title = \"Effort de pêche \\$E(t)\\$\",\n     margin = .5Plots.cm,\n     topmargin = 1Plots.cm)\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNous définissons les paramètres du modèle, la condition initiale et le temps d’intégration :\n\nx0 = 10.\n\ntspan = (0.0, 30.0)\ntstep = 0.1\n\nr = 1.\nK = 10.\nepsilon = 2.                 # seuil de Allee\npar_allee = [r, K, epsilon] # packing\ntspan_allee = (0.0, 3.0)\n\nNous définissons le système dynamique comme précédemment, à la différence que nous prévoyons de surcharger l’argument p dans le problème d’intégration sous forme d’un vecteur comprennant :\n\nle vecteur de paramètres par_allee en première position\nle vecteur de paramètres par_effort en seconde position\net la fonction effort en troisième position\n\n\nfunction allee_evar(u, p, t)\n    r, K, epsilon = p[1]        # unpacking model parameters\n    par_effort = p[2]           # unpacking fishing effort parameters\n    E = p[3]                    # unpacking fishing effort function\n    x = u[1]                    # use x notation\n    \n    dx = r*x*(x/epsilon - 1)*(1 - x/K) - E(t, par_effort)*x\nend\n\nL’intégration en elle-même suit le shéma vu précédemment, si ce n’est que l’argument de paramètres doit bien refléter ce qui est attendu par la fonction allee_evar(). La simulation en elle-même est effectuée avec une modification de la précision relative de l’intégration reltol = 1e-6, la précision par défaut n’étant pas suffisante ici.\n\nprob_allee_evar = ODEProblem(allee_evar, \n                             x0, \n                             tspan, \n                             [par_allee, par_effort, effort], \n                             saveat = tstep)\n\nsol_allee_evar = solve(prob_allee_evar, reltol = 1e-6)\n\nFinalement, nous pouvons représenter graphiquement la solution contre le temps. Ici, on choisit de ne pas passer par un dataframe, pour illustration.\n\nplot(sol_allee_evar,\n     label = \"\\$x(t)\\$\",\n     linewidth = 2,\n     xlabel = \"temps\",\n     ylabel = \"densité de population \\$x(t)\\$\",\n     title = \"Effort de pêche variant dans le temps\",\n     palette = :tab10,\n     legend = :left,\n     margin = .5Plots.cm,\n     topmargin = 1Plots.cm)"
  }
]