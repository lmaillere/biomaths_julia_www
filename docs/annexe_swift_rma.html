<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.40">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Simulation améliorée – Biomaths &amp; Julia</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-1092c56c6cadf2eb47b1bc8063ab382a.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap-66bb2cf3060fa4cee14166ad89095ce4.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script>window.backupDefine = window.define; window.define = undefined;</script><script src="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
 var mathElements = document.getElementsByClassName("math");
 var macros = [];
 for (var i = 0; i < mathElements.length; i++) {
  var texText = mathElements[i].firstChild;
  if (mathElements[i].tagName == "SPAN") {
   katex.render(texText.data, mathElements[i], {
    displayMode: mathElements[i].classList.contains('display'),
    throwOnError: false,
    macros: macros,
    fleqn: false
   });
}}});
  </script>
  <script>window.define = window.backupDefine; window.backupDefine = undefined;</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css">

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="styles.css">
</head>

<body class="nav-sidebar floating slimcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item">
      Biomaths &amp; Julia
      </li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="Search" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="./">Biomaths &amp; Julia</a> 
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Introduction</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./pop_isolees.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Populations isolées</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./pop_exploitees.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Populations exploitées</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./pop_interactions.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Populations en interaction (1)</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./pop_interactions2.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Populations en interaction (2)</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./annexes.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Matériel supplémentaire</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./about.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">A Propos</span></a>
  </div>
</li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#modèle-de-rosenzweig-macarthur" id="toc-modèle-de-rosenzweig-macarthur" class="nav-link active" data-scroll-target="#modèle-de-rosenzweig-macarthur">Modèle de Rosenzweig MacArthur</a>
  <ul class="collapse">
  <li><a href="#stratégie-pour-le-code" id="toc-stratégie-pour-le-code" class="nav-link" data-scroll-target="#stratégie-pour-le-code">Stratégie pour le code</a></li>
  <li><a href="#type-spécifique-pour-les-paramètres" id="toc-type-spécifique-pour-les-paramètres" class="nav-link" data-scroll-target="#type-spécifique-pour-les-paramètres">Type spécifique pour les paramètres</a></li>
  <li><a href="#fonctions" id="toc-fonctions" class="nav-link" data-scroll-target="#fonctions">Fonctions</a></li>
  <li><a href="#conditions-initiales" id="toc-conditions-initiales" class="nav-link" data-scroll-target="#conditions-initiales">Conditions initiales</a></li>
  <li><a href="#modèle" id="toc-modèle" class="nav-link" data-scroll-target="#modèle">Modèle</a></li>
  <li><a href="#simulation-simple" id="toc-simulation-simple" class="nav-link" data-scroll-target="#simulation-simple">Simulation simple</a></li>
  <li><a href="#solution-contre-le-temps" id="toc-solution-contre-le-temps" class="nav-link" data-scroll-target="#solution-contre-le-temps">Solution contre le temps</a></li>
  <li><a href="#diagramme-de-bifurcations" id="toc-diagramme-de-bifurcations" class="nav-link" data-scroll-target="#diagramme-de-bifurcations">Diagramme de bifurcations</a></li>
  <li><a href="#organisation-en-modules" id="toc-organisation-en-modules" class="nav-link" data-scroll-target="#organisation-en-modules">Organisation en modules</a></li>
  </ul></li>
  <li><a href="#cas-des-modèles-de-plus-grande-dimension" id="toc-cas-des-modèles-de-plus-grande-dimension" class="nav-link" data-scroll-target="#cas-des-modèles-de-plus-grande-dimension">Cas des modèles de plus grande dimension</a></li>
  </ul>
<div class="toc-actions"><ul><li><a href="https://github.com/lmaillere/biomaths_www/edit/main/annexe_swift_rma.qmd" class="toc-action"><i class="bi bi-github"></i>Edit this page</a></li><li><a href="https://github.com/lmaillere/biomaths_www/issues/new" class="toc-action"><i class="bi empty"></i>Report an issue</a></li></ul></div></nav>
    </div>
<!-- main -->
<main class="content page-columns page-full" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<div class="quarto-title-block"><div><h1 class="title">Simulation améliorée</h1><button type="button" class="btn code-tools-button" id="quarto-code-tools-source"><i class="bi"></i> Code</button></div></div>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<!-- load local julia environment (freeze package versions) -->
<section id="modèle-de-rosenzweig-macarthur" class="level2 page-columns page-full">
<h2 class="anchored" data-anchor-id="modèle-de-rosenzweig-macarthur">Modèle de Rosenzweig MacArthur</h2>
<p>Nous considérons le modèle de dynamique de populations de Rosenzweig et MacArthur que nous avons déjà vu (<span class="citation" data-cites="Rosenzweig1963">Rosenzweig and MacArthur (<a href="#ref-Rosenzweig1963" role="doc-biblioref">1963</a>)</span>, <span class="citation" data-cites="Turchin2003">Turchin (<a href="#ref-Turchin2003" role="doc-biblioref">2003</a>)</span>, <span class="citation" data-cites="Smith2008">Smith (<a href="#ref-Smith2008" role="doc-biblioref">2008</a>)</span>).</p>
<p><span id="eq-rma"><span class="math display">
\left\{\begin{array}{l}
\dot x = \displaystyle rx\left(1-\frac{x}{K}\right) - c \frac{x}{h+x} y\\[.3cm]
\dot y = b\displaystyle \frac{x}{h+x} y - m y
\end{array}\right.
\tag{1}</span></span></p>
<p>L’objectif est de réaliser des simulations performantes sur le tracé du diagramme de bifurcations, avec l’estimation par simulation du cycle limite. Ce type de simulations lourdes se prête bien à se genre de benchmark.</p>
<section id="stratégie-pour-le-code" class="level3 page-columns page-full">
<h3 class="anchored" data-anchor-id="stratégie-pour-le-code">Stratégie pour le code</h3>
<p>Pour un tel problème de dimension réduite, nous allons utiliser des static arrays (tableaux à adresse fixe dans la mémoire<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>), ce qui permettra de ne pas crééer une multitude d’objets pour la simulation mais de toujours modifier le même objet en mémoire.</p>
<div class="no-row-height column-margin column-container"><div id="fn1"><p><sup>1</sup>&nbsp;depuis le package <code>StaticArrays.jl</code></p></div></div><p>Par ailleurs nous allons essayer de nous conformer au maximum aux préconisations :</p>
<ul>
<li>ne pas utiliser de variables globales</li>
<li>définir des fonctions</li>
<li>mettre les paramètres dans un nombre limité de variables et les passer en arguments des fonctions</li>
</ul>
<p>Pour ce dernier point, nous allons définir des types (<code>struct</code>) spécifiques.</p>
<p>Nous commençons par importer les packages que nous allons utiliser:</p>
<div id="4" class="cell" data-execution_count="1">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">using</span> <span class="bu">StaticArrays</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="im">using</span> <span class="bu">DifferentialEquations</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="im">using</span> <span class="bu">CairoMakie</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="type-spécifique-pour-les-paramètres" class="level3 page-columns page-full">
<h3 class="anchored" data-anchor-id="type-spécifique-pour-les-paramètres">Type spécifique pour les paramètres</h3>
<p>Nous définissons un <code>struct</code> pour les paramètres du modèle de Rosenzweig MacArthur.</p>
<p>Type pour les paramètres :</p>
<div id="6" class="cell" data-execution_count="1">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="co"># parameters struct</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="pp">@kwdef</span> <span class="kw">struct</span> ParRma</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>    r<span class="op">::</span><span class="dt">Float64 </span><span class="op">=</span> <span class="fl">1.0</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>    K<span class="op">::</span><span class="dt">Float64 </span><span class="op">=</span> <span class="fl">10.0</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>    c<span class="op">::</span><span class="dt">Float64 </span><span class="op">=</span> <span class="fl">1.0</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>    h<span class="op">::</span><span class="dt">Float64 </span><span class="op">=</span> <span class="fl">2.0</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>    b<span class="op">::</span><span class="dt">Float64 </span><span class="op">=</span> <span class="fl">2.0</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>    m<span class="op">::</span><span class="dt">Float64 </span><span class="op">=</span> <span class="fl">1.0</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Note
</div>
</div>
<div class="callout-body-container callout-body">
<p>La macro <code>@kwdef</code> permet de renseigner des valeurs par défaut des champs du <code>struct</code>.</p>
</div>
</div>
<div class="callout callout-style-default callout-important callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Important
</div>
</div>
<div class="callout-body-container callout-body">
<p>Lors de la création d’un <code>struct</code>, on peut être tenté d’utiliser des types de champs les plus larges possibles, comme par exemple <code>r::Real = 1.0</code> ou <code>r::Number = 1.0</code>.</p>
<p><em>C’est une très mauvaise idée</em> : <code>Real</code> et <code>Number</code> sont des types abstraits qui englobent de nombreux types concrets (e.g.&nbsp;<code>Int64</code> et <code>Float64</code>). Par construction ils ne permettent pas de spécifier un espace mémoire de taille fixe comme le font les types concrets, et ne permettent donc pas d’optimiser le code à la précompilation<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a>.</p>
<p>A l’inverse, pour les fonctions, il est préférable de choisir le type le plus large possible pour la spécification des arguments.</p>
</div>
</div>
<div class="no-row-height column-margin column-container"><div id="fn2"><p><sup>2</sup>&nbsp;Par exemple, la fonction <code>cy_rma()</code> définie plus bas (la plus coûteuse en temps de calcul) est 70 fois plus lente avec un <code>ParRma</code> qui définit ses champs en <code>Real</code> plutôt qu’en <code>Float64</code>, (exécution de ~0.5s à ~35s après précompilation)</p></div></div><p>On peut créer des objets de type <code>ParRma</code> via les <code>constructor</code> par défaut; on accède à un champ particulier via <code>objet.champ</code> :</p>
<div id="8" class="cell" data-execution_count="1">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="co"># with the struct definition, ParRma objects are immutable</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>prma <span class="op">=</span> <span class="fu">ParRma</span>() <span class="co"># constructor with default values</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>prma2 <span class="op">=</span> <span class="fu">ParRma</span>(K <span class="op">=</span> <span class="fl">8.0</span>) <span class="co"># default values except K = 20.0</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a><span class="pp">@show</span> prma</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a><span class="pp">@show</span> prma.K</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a><span class="pp">@show</span> prma2.K;</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>prma = Main.Notebook.ParRma(1.0, 10.0, 1.0, 2.0, 2.0, 1.0)
prma.K = 10.0
prma2.K = 8.0</code></pre>
</div>
</div>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Note
</div>
</div>
<div class="callout-body-container callout-body">
<p>La macro <code>@show</code> est assez explicite</p>
<p>Le <code>;</code> permet de ne pas renvoyer l’évaluation de la commande <code>prma2.K</code> (qui vaut 8.0) étant donné que nous avons déjà forcé la sortie via <code>@show</code></p>
</div>
</div>
</section>
<section id="fonctions" class="level3 page-columns page-full">
<h3 class="anchored" data-anchor-id="fonctions">Fonctions</h3>
<p>Nous définissons les différentes fonctions impliquées dans le modèle de Rosenzweig MacArthur, la logistique et la réponse fonctionnelle de Holling II.</p>
<p>Pour la logistique :</p>
<div id="10" class="cell" data-execution_count="1">
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">logistic</span>(x<span class="op">::</span><span class="dt">Real</span>, p<span class="op">::</span><span class="dt">ParRma</span>)</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>    (; r, K) <span class="op">=</span> p    <span class="co"># deconstruct/get r and K from p</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="fu">r*x*</span>(<span class="fl">1</span><span class="op">-</span>x<span class="op">/</span>K)</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Note
</div>
</div>
<div class="callout-body-container callout-body">
<ul>
<li>les notations <code>var::Type</code> permettent de spécifier le type de l’argument de la fonction<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a></li>
<li>la notation <code>(; r, K) = p</code> permet d’extraire (<em>deconstruct</em>) les champs <code>r</code> et <code>K</code> du paramètre <code>p</code> qui est un objet de type <code>ParRma</code></li>
</ul>
</div>
</div>
<div class="no-row-height column-margin column-container"><div id="fn3"><p><sup>3</sup>&nbsp;C’est une des manières de faire du <a href="https://docs.julialang.org/en/v1/manual/methods/">multiple dispatch</a>, en définissant différentes méthodes pour les fonctions selon le type de l’argument</p></div></div><p>Pour la réponse fonctionnelle (sans le paramètre <span class="math inline">c</span>) :</p>
<div id="12" class="cell" data-execution_count="1">
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">holling2</span>(x<span class="op">::</span><span class="dt">Real</span>, p<span class="op">::</span><span class="dt">ParRma</span>)</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>    (; h) <span class="op">=</span> p   <span class="co"># deconstruct h from p</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> x<span class="op">/</span>(x<span class="op">+</span>h)</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="conditions-initiales" class="level3 page-columns page-full">
<h3 class="anchored" data-anchor-id="conditions-initiales">Conditions initiales</h3>
<p>Pour utiliser les static arrays avec <code>DifferentialEquations.jl</code> il faut que l’état (donc la condition initiale) et les dérivées rendues par le modèle soient des static arrays (ici un <code>SVector</code>).</p>
<p>Nous définissons un <code>struct</code> de condition initiales, avec pour champs <code>x0</code>, <code>y0</code> et un <code>Svector</code> composé de ces deux valeurs :</p>
<div id="14" class="cell" data-execution_count="1">
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="co"># initial value struct</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="pp">@kwdef</span> <span class="kw">struct</span> IniV</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>    x0<span class="op">::</span><span class="dt">Float64 </span><span class="op">=</span> <span class="fl">1.0</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>    y0<span class="op">::</span><span class="dt">Float64 </span><span class="op">=</span> <span class="fl">1.95</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>    u0<span class="op">::</span><span class="dt">SVector{2, Float64} </span><span class="op">=</span> <span class="fu">SVector</span>(x0, y0)</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a><span class="co"># construct some initial condition</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a><span class="pp">@show</span> iniv <span class="op">=</span> <span class="fu">IniV</span>();</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>iniv = IniV() = Main.Notebook.IniV(1.0, 1.95, [1.0, 1.95])</code></pre>
</div>
</div>
<p>Nous définissons un constructeur additionnel pour le type <code>IniV</code> qui à partir d’un <code>SVector</code> de longueur 2, construit l’objet <code>IniV</code> correspondant<a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a> (nous nous en servirons plus bas dans la fonction <code>cy_rma()</code>)</p>
<div class="no-row-height column-margin column-container"><div id="fn4"><p><sup>4</sup>&nbsp;il s’agit d’une forme de multiple dispatch sur le constructeur, avec plusieurs méthodes différents selon le type d’arguments utilisés</p></div></div><div id="16" class="cell" data-execution_count="1">
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="co"># new constructor method for struct IniV</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="co"># takes a length 2 SVector to construct the object (self definition)</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a><span class="fu">IniV</span>(u0<span class="op">::</span><span class="dt">SVector{2, Float64}</span>) <span class="op">=</span> <span class="fu">IniV</span>(x0 <span class="op">=</span> u0[<span class="fl">1</span>], y0 <span class="op">=</span> u0[<span class="fl">2</span>])</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a><span class="co"># construct an initial condition with this constructor</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a><span class="pp">@show</span> <span class="fu">IniV</span>(<span class="fu">SVector</span>(<span class="fl">3.0</span>, <span class="fl">3.0</span>));</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>IniV(SVector(3.0, 3.0)) = Main.Notebook.IniV(3.0, 3.0, [3.0, 3.0])</code></pre>
</div>
</div>
</section>
<section id="modèle" class="level3">
<h3 class="anchored" data-anchor-id="modèle">Modèle</h3>
<p>On définit les équations du modèle en exploitant les fonctions définies plus haut et la structure des paramètres, en renvoyant les dérivées sous forme de <code>SVector</code> :</p>
<div id="18" class="cell" data-execution_count="1">
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">mod_rma</span>(u<span class="op">::</span><span class="dt">SVector{2}</span>, p<span class="op">::</span><span class="dt">ParRma</span>, t)</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>    (; c, b, m) <span class="op">=</span> p     <span class="co"># get c, b, m from p</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>    x <span class="op">=</span> u[<span class="fl">1</span>]            <span class="co"># use x, y notations</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>    y <span class="op">=</span> u[<span class="fl">2</span>]</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>    dx <span class="op">=</span> <span class="fu">logistic</span>(x, p) <span class="op">-</span> c <span class="op">*</span> <span class="fu">holling2</span>(x,p) <span class="op">*</span> y</span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>    dy <span class="op">=</span> b <span class="op">*</span> <span class="fu">holling2</span>(x, p) <span class="op">*</span> y <span class="op">-</span> m <span class="op">*</span> y</span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="fu">SVector</span>(dx, dy) <span class="co"># return derivatives as SVector</span></span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="simulation-simple" class="level3">
<h3 class="anchored" data-anchor-id="simulation-simple">Simulation simple</h3>
<p>On définit les paramètres du temps dans un <code>struct</code> :</p>
<div id="20" class="cell" data-execution_count="1">
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="co"># time parameters struct</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span class="pp">@kwdef</span> <span class="kw">struct</span> ParTime</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>    tspan<span class="op">::</span><span class="dt">Tuple{Float64, Float64} </span><span class="op">=</span> (<span class="fl">0.0</span>, <span class="fl">60.0</span>)</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>    tstep<span class="op">::</span><span class="dt">Float64 </span><span class="op">=</span> <span class="fl">0.1</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a><span class="co"># construct a time parameter</span></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>ptime <span class="op">=</span> <span class="fu">ParTime</span>()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>On définit une fonction qui définit le problème de simulation, l’intègre et retourne la solution, avec pour arguments positionnels la condition initiale, les paramètres et les paramètres de temps, et comme keyword argument le paramètre booléen <code>final</code>.</p>
<p>Lorsque <code>final = false</code> (par défaut), la fonction renvoie toute la solution. Lorsque <code>final  =true</code> la fonction renvoie la valeur finale de la simulation, ce dont nous nous servirons plus bas dans l’estimation des extremas du cycle limite.</p>
<div id="22" class="cell" data-execution_count="1">
<div class="sourceCode cell-code" id="cb13"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">sim_rma</span>(iniv<span class="op">::</span><span class="dt">IniV</span>, p<span class="op">::</span><span class="dt">ParRma</span>, pt<span class="op">::</span><span class="dt">ParTime</span>; final<span class="op">::</span><span class="dt">Bool </span><span class="op">=</span> <span class="cn">false</span>)</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>    <span class="co"># deconstruct time parameter</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>    (; tspan, tstep) <span class="op">=</span> pt</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>    (; u0) <span class="op">=</span> iniv</span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>    <span class="co"># define and solve simulation problem</span></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a>    prob_rma <span class="op">=</span> <span class="fu">ODEProblem</span>(mod_rma, u0, tspan, p)</span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> !final   <span class="co"># if final == false compute whole solution</span></span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a>        sol_rma <span class="op">=</span> <span class="fu">solve</span>(prob_rma; reltol <span class="op">=</span> <span class="fl">1e-6</span>, saveat <span class="op">=</span> tstep)</span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>        <span class="co"># if final == true compute only final state</span></span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a>        sol_rma <span class="op">=</span> <span class="fu">solve</span>(</span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true" tabindex="-1"></a>            prob_rma;</span>
<span id="cb13-13"><a href="#cb13-13" aria-hidden="true" tabindex="-1"></a>            reltol <span class="op">=</span> <span class="fl">1e-6</span>,</span>
<span id="cb13-14"><a href="#cb13-14" aria-hidden="true" tabindex="-1"></a>            save_everystep <span class="op">=</span> <span class="cn">false</span>,</span>
<span id="cb13-15"><a href="#cb13-15" aria-hidden="true" tabindex="-1"></a>            save_start <span class="op">=</span> <span class="cn">false</span>,</span>
<span id="cb13-16"><a href="#cb13-16" aria-hidden="true" tabindex="-1"></a>        )</span>
<span id="cb13-17"><a href="#cb13-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">end</span></span>
<span id="cb13-18"><a href="#cb13-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-19"><a href="#cb13-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> sol_rma</span>
<span id="cb13-20"><a href="#cb13-20" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb13-21"><a href="#cb13-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-22"><a href="#cb13-22" aria-hidden="true" tabindex="-1"></a><span class="pp">@time</span> <span class="fu">sim_rma</span>(iniv, prma, ptime);</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>  2.397224 seconds (4.95 M allocations: 332.802 MiB, 17.11% gc time, 99.98% compilation time: &lt;1% of which was recompilation)</code></pre>
</div>
</div>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Note
</div>
</div>
<div class="callout-body-container callout-body">
<p>La macro <code>@time</code> renvoit le temps (et qqes éléments sur la computation) mis pour calculer la commande qui la suit, ici la simulation.</p>
</div>
</div>
<p>Une fois la fonction précompilée à la première exécution, la performance est incomparable (4 ordres de grandeur plus rapide sur la fonction <code>sim_rma()</code>) :</p>
<div id="24" class="cell" data-execution_count="1">
<div class="sourceCode cell-code" id="cb15"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="pp">@time</span> <span class="fu">sim_rma</span>(iniv, prma2, ptime);</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>  0.000214 seconds (129 allocations: 42.547 KiB)</code></pre>
</div>
</div>
</section>
<section id="solution-contre-le-temps" class="level3">
<h3 class="anchored" data-anchor-id="solution-contre-le-temps">Solution contre le temps</h3>
<p>Finalement, on définit une fonction qui simule et produit un graphique de la solution contre le temps, avec pour arguments la condition initiale, les paramètres et les paramètres de temps :</p>
<div id="26" class="cell" data-execution_count="1">
<div class="sourceCode cell-code" id="cb17"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">plot_rma</span>(iniv<span class="op">::</span><span class="dt">IniV</span>, p<span class="op">::</span><span class="dt">ParRma</span>, pt<span class="op">::</span><span class="dt">ParTime</span>)</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>    <span class="co"># compute the simulation</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>    sol_rma <span class="op">=</span> <span class="fu">sim_rma</span>(iniv, p, pt)</span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>    <span class="co"># initialize figure</span></span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a>    fig <span class="op">=</span> <span class="fu">Figure</span>(; fontsize <span class="op">=</span> <span class="fl">20</span>)</span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a>    ax <span class="op">=</span> <span class="fu">Axis</span>(fig[<span class="fl">1</span>,<span class="fl">1</span>];</span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a>        title <span class="op">=</span> <span class="st">"Modèle de Rosenzweig MacArthur</span><span class="sc">\n</span><span class="st"> "</span>,</span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a>        xlabel <span class="op">=</span> <span class="st">"temps"</span>,</span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true" tabindex="-1"></a>        ylabel <span class="op">=</span> <span class="st">"densités"</span>,</span>
<span id="cb17-11"><a href="#cb17-11" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb17-12"><a href="#cb17-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-13"><a href="#cb17-13" aria-hidden="true" tabindex="-1"></a>    <span class="co"># plot solution</span></span>
<span id="cb17-14"><a href="#cb17-14" aria-hidden="true" tabindex="-1"></a>    <span class="fu">lines!</span>(ax, sol_rma.t, sol_rma[<span class="fl">1</span>,<span class="op">:</span>]; lw <span class="op">=</span> <span class="fl">2</span>, label <span class="op">=</span> <span class="st">"proies"</span>)</span>
<span id="cb17-15"><a href="#cb17-15" aria-hidden="true" tabindex="-1"></a>    <span class="fu">lines!</span>(ax, sol_rma.t,  sol_rma[<span class="fl">2</span>,<span class="op">:</span>]; lw <span class="op">=</span> <span class="fl">2</span>, label <span class="op">=</span> <span class="st">"prédateurs"</span>)</span>
<span id="cb17-16"><a href="#cb17-16" aria-hidden="true" tabindex="-1"></a>    <span class="fu">axislegend</span>(; position <span class="op">=</span> <span class="op">:</span>lt)</span>
<span id="cb17-17"><a href="#cb17-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-18"><a href="#cb17-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> fig</span>
<span id="cb17-19"><a href="#cb17-19" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Finalement on exécute cette fonction pour tracer la simulation :</p>
<div id="cell-fig-rma-time" class="cell" data-execution_count="1">
<div class="sourceCode cell-code" id="cb18"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="fu">plot_rma</span>(iniv, prma, ptime)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="1">
<div id="fig-rma-time" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-rma-time-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="annexe_swift_rma_files/figure-html/fig-rma-time-output-1.svg" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-rma-time-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;1: Simulation des trajectoires du modèle de Rosenzweig MacArthur
</figcaption>
</figure>
</div>
</div>
</div>
</section>
<section id="diagramme-de-bifurcations" class="level3">
<h3 class="anchored" data-anchor-id="diagramme-de-bifurcations">Diagramme de bifurcations</h3>
<p>Nous calculons ici le diagramme de bifurcations : les asymptotiques des prédateurs <span class="math inline">y^*</span> en fonction de <span class="math inline">K</span>.</p>
<section id="équilibres" class="level4">
<h4 class="anchored" data-anchor-id="équilibres">Équilibres</h4>
<p>Il n’y a pas besoin de simulation ici puisque les lieux des équilibres sont facilement calculables analytiquement (cf.&nbsp;cette <a href="./pop_interactions2.html">page</a>).</p>
<p>Nous définissons une fonction qui prend les paramètres du modèle et renvoit des tuples définissant les différentes branches d’équilibres <span class="math inline">(K, y^*)</span> (avec en <code>kwarg</code> un <code>Kmax</code> et un <code>Kstep</code> avec des valeurs par défaut).</p>
<div id="30" class="cell" data-execution_count="1">
<div class="sourceCode cell-code" id="cb19"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">eqy_rma</span>(p<span class="op">::</span><span class="dt">ParRma</span>; Kmax<span class="op">::</span><span class="dt">Real </span><span class="op">=</span> <span class="fl">8.0</span>, Kstep<span class="op">::</span><span class="dt">Real </span><span class="op">=</span> <span class="fl">0.1</span>)</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>    (; r, c, h, b, m) <span class="op">=</span> p <span class="co"># deconstruct p (K is useless since it is varied)</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>    <span class="co"># define bifurcation K values</span></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>    Ktrans <span class="op">=</span> m<span class="op">*</span>h<span class="op">/</span>(b<span class="op">-</span>m)</span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a>    Khopf <span class="op">=</span> h<span class="op">+</span><span class="fl">2</span><span class="op">*</span>m<span class="op">*</span>h<span class="op">/</span>(b<span class="op">-</span>m)</span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a>    <span class="co"># drops an error if Kmax is too small</span></span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> Kmax <span class="op">&lt;</span> Khopf</span>
<span id="cb19-10"><a href="#cb19-10" aria-hidden="true" tabindex="-1"></a>        <span class="fu">error</span>(<span class="st">"For a full computation of equilibria types, Kmax must be greater than </span><span class="sc">$</span>Khopf<span class="st">"</span>)</span>
<span id="cb19-11"><a href="#cb19-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">end</span></span>
<span id="cb19-12"><a href="#cb19-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-13"><a href="#cb19-13" aria-hidden="true" tabindex="-1"></a>    <span class="co"># y equilibria</span></span>
<span id="cb19-14"><a href="#cb19-14" aria-hidden="true" tabindex="-1"></a>    <span class="co"># below transcritical : only y=0</span></span>
<span id="cb19-15"><a href="#cb19-15" aria-hidden="true" tabindex="-1"></a>    Krg1 <span class="op">=</span> <span class="fl">0</span><span class="op">:</span>Kstep<span class="op">:</span>Ktrans</span>
<span id="cb19-16"><a href="#cb19-16" aria-hidden="true" tabindex="-1"></a>    y01 <span class="op">=</span> <span class="fu">ones</span>(<span class="fu">length</span>(Krg1))<span class="op">.*</span><span class="fl">0</span>     <span class="co"># broadcasting</span></span>
<span id="cb19-17"><a href="#cb19-17" aria-hidden="true" tabindex="-1"></a>    eqs1 <span class="op">=</span> (Krg <span class="op">=</span> Krg1, y0 <span class="op">=</span> y01, yco <span class="op">=</span> <span class="cn">nothing</span>)</span>
<span id="cb19-18"><a href="#cb19-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-19"><a href="#cb19-19" aria-hidden="true" tabindex="-1"></a>    <span class="co"># between transcritical and Hopf : y=0 and y&gt;0</span></span>
<span id="cb19-20"><a href="#cb19-20" aria-hidden="true" tabindex="-1"></a>    Krg2 <span class="op">=</span> Ktrans<span class="op">:</span>Kstep<span class="op">:</span>Khopf</span>
<span id="cb19-21"><a href="#cb19-21" aria-hidden="true" tabindex="-1"></a>    y02 <span class="op">=</span> <span class="fu">ones</span>(<span class="fu">length</span>(Krg2))<span class="op">.*</span><span class="fl">0</span></span>
<span id="cb19-22"><a href="#cb19-22" aria-hidden="true" tabindex="-1"></a>    yco2 <span class="op">=</span> [r<span class="op">/</span><span class="fu">c*</span>(h<span class="op">+</span>m<span class="op">*</span>h<span class="op">/</span>(b<span class="op">-</span>m))<span class="fu">*</span>(<span class="fl">1</span><span class="op">-</span>m<span class="op">*</span>h<span class="op">/</span>(b<span class="op">-</span>m)<span class="op">/</span>K) for K <span class="kw">in</span> Krg2]</span>
<span id="cb19-23"><a href="#cb19-23" aria-hidden="true" tabindex="-1"></a>    eqs2 <span class="op">=</span> (Krg <span class="op">=</span> Krg2, y0 <span class="op">=</span> y02, yco <span class="op">=</span> yco2)</span>
<span id="cb19-24"><a href="#cb19-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-25"><a href="#cb19-25" aria-hidden="true" tabindex="-1"></a>    <span class="co"># above Hopf : y=0 and y&gt;0</span></span>
<span id="cb19-26"><a href="#cb19-26" aria-hidden="true" tabindex="-1"></a>    Krg3 <span class="op">=</span> Khopf<span class="op">:</span>Kstep<span class="op">:</span>Kmax</span>
<span id="cb19-27"><a href="#cb19-27" aria-hidden="true" tabindex="-1"></a>    y03 <span class="op">=</span> <span class="fu">ones</span>(<span class="fu">length</span>(Krg3))<span class="op">.*</span><span class="fl">0</span></span>
<span id="cb19-28"><a href="#cb19-28" aria-hidden="true" tabindex="-1"></a>    yco3 <span class="op">=</span> [r<span class="op">/</span><span class="fu">c*</span>(h<span class="op">+</span>m<span class="op">*</span>h<span class="op">/</span>(b<span class="op">-</span>m))<span class="fu">*</span>(<span class="fl">1</span><span class="op">-</span>m<span class="op">*</span>h<span class="op">/</span>(b<span class="op">-</span>m)<span class="op">/</span>K) for K <span class="kw">in</span> Krg3]</span>
<span id="cb19-29"><a href="#cb19-29" aria-hidden="true" tabindex="-1"></a>    eqs3 <span class="op">=</span> (Krg <span class="op">=</span> Krg3, y0 <span class="op">=</span> y03, yco <span class="op">=</span> yco3)</span>
<span id="cb19-30"><a href="#cb19-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-31"><a href="#cb19-31" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> eqs1, eqs2, eqs3</span>
<span id="cb19-32"><a href="#cb19-32" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="cycle-limite" class="level4">
<h4 class="anchored" data-anchor-id="cycle-limite">Cycle limite</h4>
<p>On définit une fonction qui renvoit un tuple contenant les valeurs de <span class="math inline">K</span> et les extremas du cycle limite apparaissant pour <span class="math inline">K &gt; K_{hopf} = h+\frac{2mh}{b-m}</span>.</p>
<p>La fonction prend pour argument les paramètres, et fait appel à la fonction <code>sim_rma()</code> avec les méthodes <code>final = true</code> (pour les transitoires) et <code>final = false</code> (pour les extremas du cycle limite). Elle utilise aussi le constructeur supplémentaire pour les objets <code>IniV</code>.</p>
<div id="32" class="cell" data-execution_count="1">
<div class="sourceCode cell-code" id="cb20"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">cy_rma</span>(p<span class="op">::</span><span class="dt">ParRma</span>; Kmax<span class="op">::</span><span class="dt">Float64 </span><span class="op">=</span> <span class="fl">8.0</span>, Kstep<span class="op">::</span><span class="dt">Float64 </span><span class="op">=</span> <span class="fl">0.01</span>)</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>    <span class="co"># parameters and K range</span></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>    (; r, c, h, b, m) <span class="op">=</span> p <span class="co"># deconstruct p (K is useless since it is varied)</span></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a>    Khopf <span class="op">=</span> h<span class="op">+</span><span class="fl">2</span><span class="op">*</span>m<span class="op">*</span>h<span class="op">/</span>(b<span class="op">-</span>m)</span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a>    Krgh <span class="op">=</span> Khopf<span class="op">-</span>Kstep<span class="op">:</span>Kstep<span class="op">:</span>Kmax</span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a>    <span class="co"># drops an error if Kmax is too small</span></span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> Kmax <span class="op">&lt;</span> Khopf</span>
<span id="cb20-9"><a href="#cb20-9" aria-hidden="true" tabindex="-1"></a>        <span class="fu">error</span>(<span class="st">"For a computation of the limit cycle, Kmax must be greater than </span><span class="sc">$</span>Khopf<span class="st">"</span>)</span>
<span id="cb20-10"><a href="#cb20-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">end</span></span>
<span id="cb20-11"><a href="#cb20-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-12"><a href="#cb20-12" aria-hidden="true" tabindex="-1"></a>    <span class="co"># for storage</span></span>
<span id="cb20-13"><a href="#cb20-13" aria-hidden="true" tabindex="-1"></a>    ycmin <span class="op">=</span> <span class="fu">zero</span>(Krgh)</span>
<span id="cb20-14"><a href="#cb20-14" aria-hidden="true" tabindex="-1"></a>    ycmax <span class="op">=</span> <span class="fu">zero</span>(Krgh)</span>
<span id="cb20-15"><a href="#cb20-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-16"><a href="#cb20-16" aria-hidden="true" tabindex="-1"></a>    <span class="co"># initial value and time parameters</span></span>
<span id="cb20-17"><a href="#cb20-17" aria-hidden="true" tabindex="-1"></a>    iniv <span class="op">=</span> <span class="fu">IniV</span>()</span>
<span id="cb20-18"><a href="#cb20-18" aria-hidden="true" tabindex="-1"></a>    ptime <span class="op">=</span> <span class="fu">ParTime</span>()</span>
<span id="cb20-19"><a href="#cb20-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-20"><a href="#cb20-20" aria-hidden="true" tabindex="-1"></a>    <span class="co"># transient integration time</span></span>
<span id="cb20-21"><a href="#cb20-21" aria-hidden="true" tabindex="-1"></a>    ptrans <span class="op">=</span> <span class="fu">ParTime</span>(tspan <span class="op">=</span> (<span class="fl">0.0</span>, <span class="fl">8000.0</span>))</span>
<span id="cb20-22"><a href="#cb20-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-23"><a href="#cb20-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> (i, Kh) <span class="kw">in</span> <span class="fu">enumerate</span>(Krgh)</span>
<span id="cb20-24"><a href="#cb20-24" aria-hidden="true" tabindex="-1"></a>        <span class="co"># construct parameter from p, with K = Kh of the loop</span></span>
<span id="cb20-25"><a href="#cb20-25" aria-hidden="true" tabindex="-1"></a>        prmabif <span class="op">=</span> <span class="fu">ParRma</span>(r, Kh, c, h, b, m)</span>
<span id="cb20-26"><a href="#cb20-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-27"><a href="#cb20-27" aria-hidden="true" tabindex="-1"></a>        <span class="co"># simulate transient, get final state</span></span>
<span id="cb20-28"><a href="#cb20-28" aria-hidden="true" tabindex="-1"></a>        utr <span class="op">=</span> <span class="fu">sim_rma</span>(iniv, prmabif, ptrans; final <span class="op">=</span> <span class="cn">true</span>)[<span class="op">:</span>,<span class="fl">1</span>]</span>
<span id="cb20-29"><a href="#cb20-29" aria-hidden="true" tabindex="-1"></a>        inivtr <span class="op">=</span> <span class="fu">IniV</span>(utr) <span class="co"># construct new init value</span></span>
<span id="cb20-30"><a href="#cb20-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-31"><a href="#cb20-31" aria-hidden="true" tabindex="-1"></a>        <span class="co"># start from end of transient, simulate limit cycle</span></span>
<span id="cb20-32"><a href="#cb20-32" aria-hidden="true" tabindex="-1"></a>        sol_cyc <span class="op">=</span> <span class="fu">sim_rma</span>(inivtr, prmabif, ptime)</span>
<span id="cb20-33"><a href="#cb20-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-34"><a href="#cb20-34" aria-hidden="true" tabindex="-1"></a>        <span class="co"># get min and max y along the cycle</span></span>
<span id="cb20-35"><a href="#cb20-35" aria-hidden="true" tabindex="-1"></a>        ycmin[i] <span class="op">=</span> <span class="fu">minimum</span>(sol_cyc[<span class="fl">2</span>,<span class="op">:</span>])</span>
<span id="cb20-36"><a href="#cb20-36" aria-hidden="true" tabindex="-1"></a>        ycmax[i] <span class="op">=</span> <span class="fu">maximum</span>(sol_cyc[<span class="fl">2</span>,<span class="op">:</span>])</span>
<span id="cb20-37"><a href="#cb20-37" aria-hidden="true" tabindex="-1"></a>    <span class="cf">end</span></span>
<span id="cb20-38"><a href="#cb20-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-39"><a href="#cb20-39" aria-hidden="true" tabindex="-1"></a>    cycle <span class="op">=</span> (Krg <span class="op">=</span> Krgh, ycmin <span class="op">=</span> ycmin, ycmax <span class="op">=</span> ycmax)</span>
<span id="cb20-40"><a href="#cb20-40" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> cycle</span>
<span id="cb20-41"><a href="#cb20-41" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb20-42"><a href="#cb20-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-43"><a href="#cb20-43" aria-hidden="true" tabindex="-1"></a><span class="pp">@time</span> <span class="fu">cy_rma</span>(prma);</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>  1.228100 seconds (1.16 M allocations: 91.204 MiB, 1.89% gc time, 63.15% compilation time)</code></pre>
</div>
</div>
<p>Après précompilation, ce calcul est encore plus rapide :</p>
<div id="34" class="cell" data-execution_count="1">
<div class="sourceCode cell-code" id="cb22"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="pp">@time</span> <span class="fu">cy_rma</span>(prma2);</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>  0.443242 seconds (51.71 k allocations: 17.591 MiB)</code></pre>
</div>
</div>
<p>A titre d’exemple, la simulation sur cette <a href="./pop_interactions2.html">page</a> prenait de l’ordre de 20 fois plus longtemps pour un calcul similaire.</p>
</section>
<section id="représentation-graphique" class="level4">
<h4 class="anchored" data-anchor-id="représentation-graphique">Représentation graphique</h4>
<p>Finalement, nous définissons une fonction permettant de représenter le diagramme de bifurcations, qui fait appel aux fonctions <code>eqy_rma()</code> et <code>cy_rma()</code> définies ci-dessus :</p>
<div id="36" class="cell" data-execution_count="1">
<div class="sourceCode cell-code" id="cb24"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">plot_bif_rma</span>(p<span class="op">::</span><span class="dt">ParRma</span>; Kmax <span class="op">=</span> <span class="fl">8.0</span>, Kstep <span class="op">=</span> <span class="fl">0.1</span>)</span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>    <span class="co"># initialize figure</span></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a>    fig <span class="op">=</span> <span class="fu">Figure</span>(; fontsize <span class="op">=</span> <span class="fl">20</span>)</span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a>    ax <span class="op">=</span> <span class="fu">Axis</span>(fig[<span class="fl">1</span>,<span class="fl">1</span>];</span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a>        title <span class="op">=</span> <span class="st">"Bifurcations du modèle de Rosenzweig MacArthur</span><span class="sc">\n</span><span class="st"> "</span>,</span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true" tabindex="-1"></a>        xlabel <span class="op">=</span> <span class="st">"capacité de charge 𝐾"</span>,</span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true" tabindex="-1"></a>        ylabel <span class="op">=</span> <span class="st">"densités"</span>,</span>
<span id="cb24-8"><a href="#cb24-8" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb24-9"><a href="#cb24-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-10"><a href="#cb24-10" aria-hidden="true" tabindex="-1"></a>    <span class="co"># plot equilibria</span></span>
<span id="cb24-11"><a href="#cb24-11" aria-hidden="true" tabindex="-1"></a>    eqs1, eqs2, eqs3 <span class="op">=</span> <span class="fu">eqy_rma</span>(p; Kmax <span class="op">=</span> Kmax, Kstep <span class="op">=</span> Kstep)</span>
<span id="cb24-12"><a href="#cb24-12" aria-hidden="true" tabindex="-1"></a>    <span class="fu">lines!</span>(eqs1.Krg, eqs1.y0; color <span class="op">=</span> <span class="fu">Cycled</span>(<span class="fl">1</span>), lw <span class="op">=</span> <span class="fl">2</span>, label <span class="op">=</span> <span class="st">"branche stable"</span>)</span>
<span id="cb24-13"><a href="#cb24-13" aria-hidden="true" tabindex="-1"></a>    <span class="fu">lines!</span>(eqs2.Krg, eqs2.y0; color <span class="op">=</span> <span class="fu">Cycled</span>(<span class="fl">2</span>), lw <span class="op">=</span> <span class="fl">2</span>, label <span class="op">=</span> <span class="st">"branche instable"</span>)</span>
<span id="cb24-14"><a href="#cb24-14" aria-hidden="true" tabindex="-1"></a>    <span class="fu">lines!</span>(eqs2.Krg, eqs2.yco; color <span class="op">=</span> <span class="fu">Cycled</span>(<span class="fl">1</span>), lw <span class="op">=</span> <span class="fl">2</span>)</span>
<span id="cb24-15"><a href="#cb24-15" aria-hidden="true" tabindex="-1"></a>    <span class="fu">lines!</span>(eqs3.Krg, eqs3.y0; color <span class="op">=</span> <span class="fu">Cycled</span>(<span class="fl">2</span>), lw <span class="op">=</span> <span class="fl">2</span>)</span>
<span id="cb24-16"><a href="#cb24-16" aria-hidden="true" tabindex="-1"></a>    <span class="fu">lines!</span>(eqs3.Krg, eqs3.yco; color <span class="op">=</span> <span class="fu">Cycled</span>(<span class="fl">2</span>), lw <span class="op">=</span> <span class="fl">2</span>)</span>
<span id="cb24-17"><a href="#cb24-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-18"><a href="#cb24-18" aria-hidden="true" tabindex="-1"></a>    <span class="co"># plot limit Cycle</span></span>
<span id="cb24-19"><a href="#cb24-19" aria-hidden="true" tabindex="-1"></a>    cycle <span class="op">=</span> <span class="fu">cy_rma</span>(p; Kmax <span class="op">=</span> Kmax) <span class="co"># we keep the default Kstep = 0.01 for accuracy</span></span>
<span id="cb24-20"><a href="#cb24-20" aria-hidden="true" tabindex="-1"></a>    <span class="fu">lines!</span>(cycle.Krg, cycle.ycmin; color <span class="op">=</span> <span class="fu">Cycled</span>(<span class="fl">3</span>), lw<span class="op">=</span><span class="fl">2</span>, label <span class="op">=</span> <span class="st">"cycle limite"</span>)</span>
<span id="cb24-21"><a href="#cb24-21" aria-hidden="true" tabindex="-1"></a>    <span class="fu">lines!</span>(cycle.Krg, cycle.ycmax; color <span class="op">=</span> <span class="fu">Cycled</span>(<span class="fl">3</span>), lw<span class="op">=</span><span class="fl">2</span>)</span>
<span id="cb24-22"><a href="#cb24-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-23"><a href="#cb24-23" aria-hidden="true" tabindex="-1"></a>    <span class="fu">axislegend</span>(ax, position <span class="op">=</span> <span class="op">:</span>lt, labelsize <span class="op">=</span> <span class="fl">14</span>)</span>
<span id="cb24-24"><a href="#cb24-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-25"><a href="#cb24-25" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> fig</span>
<span id="cb24-26"><a href="#cb24-26" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Ce qui donne :</p>
<div id="cell-fig-rma-bif" class="cell" data-execution_count="1">
<div class="sourceCode cell-code" id="cb25"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="fu">plot_bif_rma</span>(prma)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="1">
<div id="fig-rma-bif" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-rma-bif-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="annexe_swift_rma_files/figure-html/fig-rma-bif-output-1.svg" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-rma-bif-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;2: Diagramme de bifurcations du modèle de Rosenzweig MacArthur
</figcaption>
</figure>
</div>
</div>
</div>
</section>
</section>
<section id="organisation-en-modules" class="level3">
<h3 class="anchored" data-anchor-id="organisation-en-modules">Organisation en modules</h3>
<p>Avec cette écriture de programme exploitant au maximum des structs et des fonctions, il est facile de placer l’ensemble des définitions dans un module dans fichier séparé, et de créer un script principal qui appelle ce module et ne demande que quelques lignes pour effectuer les simulations présentées plus haut sur cette page.</p>
<p>Une telle architecture fichier/moudle/script principal est présentée sur <a href="./annexe_rma_module.html">cette page</a>.</p>
</section>
</section>
<section id="cas-des-modèles-de-plus-grande-dimension" class="level2 page-columns page-full">
<h2 class="anchored" data-anchor-id="cas-des-modèles-de-plus-grande-dimension">Cas des modèles de plus grande dimension</h2>
<p>Pour les modèles de plus grande dimension (<span class="math inline">n&gt;8</span>), l’avantage en performance des static arrays n’est plus si net et la documentation de <code>DifferentialEquations.jl</code> recommande d’utiliser la version en place (is in place, IIP dans le jargon du package) de l’interface problem/solver du package.</p>
<p>Il s’agit ici de définir le modèle non pas comme renvoyant la dérivée en fonction de l’état, des paramètres et du temps, mais comme une fonction d’arguments la dérivée, l’état, les paramètres et le temps qui modifie en place la dérivée (et ne renvoie rien). Cela permet de muter un même objet dérivée <code>du</code> à chaque fois que le modèle est appelé, plutôt que de créer un nouvel objet dérivée <code>du</code> à chaque appel du modèle (c’est aussi dans le même esprit de ce qui est fait, différemment, avec les static arrays plus haut).</p>
<p>Typiquement ce type de modèle IIP (en place) s’écrit:</p>
<div id="40" class="cell" data-execution_count="1">
<div class="sourceCode cell-code" id="cb26"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">mod_rma!</span>(du, u, p<span class="op">::</span><span class="dt">ParRma</span>, t)</span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a>    (; c, b, m) <span class="op">=</span> p     <span class="co"># get c, b, m from p</span></span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a>    x <span class="op">=</span> u[<span class="fl">1</span>]            <span class="co"># use x, y notations</span></span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a>    y <span class="op">=</span> u[<span class="fl">2</span>]</span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true" tabindex="-1"></a>    <span class="co"># in-place computation of du</span></span>
<span id="cb26-7"><a href="#cb26-7" aria-hidden="true" tabindex="-1"></a>    du[<span class="fl">1</span>] <span class="op">=</span> <span class="fu">logistic</span>(x, p) <span class="op">-</span> c <span class="op">*</span> <span class="fu">holling2</span>(x,p) <span class="op">*</span> y</span>
<span id="cb26-8"><a href="#cb26-8" aria-hidden="true" tabindex="-1"></a>    du[<span class="fl">2</span>] <span class="op">=</span> b <span class="op">*</span> <span class="fu">holling2</span>(x, p) <span class="op">*</span> y <span class="op">-</span> m <span class="op">*</span> y</span>
<span id="cb26-9"><a href="#cb26-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="cn">nothing</span></span>
<span id="cb26-10"><a href="#cb26-10" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>La définition du problème d’intégration et l’appel de solve est similaire aux autres méthodes, à ceci près que la condition initiale et la dérivée doit être mutable, ce qui ne permet pas (ou très difficilement) d’utiliser la méthode en dimension 1. En effet une déclaration <code>u0 = 1.0</code> ou <code>du = 3.0</code> n’est pas mutable<a href="#fn5" class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a>.</p>


<!-- -->


<div class="no-row-height column-margin column-container"><div id="fn5"><p><sup>5</sup>&nbsp;alors que <code>u0 = [1.0, 2.0]</code> ou <code>du =[2.0, 3.0]</code> le sont. Plus sur la mutabilité dans les <a href="https://m3g.github.io/JuliaNotes.jl/stable/immutable/">Julia notes</a>.</p></div></div></section>


<div id="quarto-appendix" class="default"><section class="quarto-appendix-contents" role="doc-bibliography" id="quarto-bibliography"><h2 class="anchored quarto-appendix-heading">References</h2><div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list">
<div id="ref-Rosenzweig1963" class="csl-entry" role="listitem">
Rosenzweig, M. L., and R. H. MacArthur. 1963. <span>“Graphical Representation and Stability Conditions of Predator-Prey Interactions.”</span> <em>American Naturalist</em> 97: 209–23.
</div>
<div id="ref-Smith2008" class="csl-entry" role="listitem">
Smith, H. L. 2008. <span>“The Rosenzweig MacArthur Predator Prey Model.”</span>
</div>
<div id="ref-Turchin2003" class="csl-entry" role="listitem">
Turchin, P. 2003. <em>Complex Population Dynamics</em>. Princeton University Press.
</div>
</div></section><section class="quarto-appendix-contents" id="quarto-reuse"><h2 class="anchored quarto-appendix-heading">Reuse</h2><div class="quarto-appendix-contents"><div><a rel="license" href="https://creativecommons.org/licenses/by-nc/4.0/">CC BY-NC 4.0</a></div></div></section></div></main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
  const viewSource = window.document.getElementById('quarto-view-source') ||
                     window.document.getElementById('quarto-code-tools-source');
  if (viewSource) {
    const sourceUrl = viewSource.getAttribute("data-quarto-source-url");
    viewSource.addEventListener("click", function(e) {
      if (sourceUrl) {
        // rstudio viewer pane
        if (/\bcapabilities=\b/.test(window.location)) {
          window.open(sourceUrl);
        } else {
          window.location.href = sourceUrl;
        }
      } else {
        const modal = new bootstrap.Modal(document.getElementById('quarto-embedded-source-code-modal'));
        modal.show();
      }
      return false;
    });
  }
  function toggleCodeHandler(show) {
    return function(e) {
      const detailsSrc = window.document.querySelectorAll(".cell > details > .sourceCode");
      for (let i=0; i<detailsSrc.length; i++) {
        const details = detailsSrc[i].parentElement;
        if (show) {
          details.open = true;
        } else {
          details.removeAttribute("open");
        }
      }
      const cellCodeDivs = window.document.querySelectorAll(".cell > .sourceCode");
      const fromCls = show ? "hidden" : "unhidden";
      const toCls = show ? "unhidden" : "hidden";
      for (let i=0; i<cellCodeDivs.length; i++) {
        const codeDiv = cellCodeDivs[i];
        if (codeDiv.classList.contains(fromCls)) {
          codeDiv.classList.remove(fromCls);
          codeDiv.classList.add(toCls);
        } 
      }
      return false;
    }
  }
  const hideAllCode = window.document.getElementById("quarto-hide-all-code");
  if (hideAllCode) {
    hideAllCode.addEventListener("click", toggleCodeHandler(false));
  }
  const showAllCode = window.document.getElementById("quarto-show-all-code");
  if (showAllCode) {
    showAllCode.addEventListener("click", toggleCodeHandler(true));
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script><div class="modal fade" id="quarto-embedded-source-code-modal" tabindex="-1" aria-labelledby="quarto-embedded-source-code-modal-label" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable"><div class="modal-content"><div class="modal-header"><h5 class="modal-title" id="quarto-embedded-source-code-modal-label">Source Code</h5><button class="btn-close" data-bs-dismiss="modal"></button></div><div class="modal-body"><div class="">
<div class="sourceCode" id="cb27" data-shortcodes="false"><pre class="sourceCode markdown code-with-copy"><code class="sourceCode markdown"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="co">---</span></span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a><span class="an">title:</span><span class="co"> "Simulation améliorée"</span></span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a><span class="an">engine:</span><span class="co"> julia</span></span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a><span class="co">---</span></span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true" tabindex="-1"></a><span class="co">&lt;!-- load local julia environment (freeze package versions) --&gt;</span></span>
<span id="cb27-6"><a href="#cb27-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-9"><a href="#cb27-9" aria-hidden="true" tabindex="-1"></a><span class="in">```{julia}</span></span>
<span id="cb27-10"><a href="#cb27-10" aria-hidden="true" tabindex="-1"></a><span class="in">#| include: false</span></span>
<span id="cb27-11"><a href="#cb27-11" aria-hidden="true" tabindex="-1"></a><span class="in">#| eval: true</span></span>
<span id="cb27-12"><a href="#cb27-12" aria-hidden="true" tabindex="-1"></a><span class="in">#</span></span>
<span id="cb27-13"><a href="#cb27-13" aria-hidden="true" tabindex="-1"></a><span class="in"># this cell does not appear in the rendering, but is executed</span></span>
<span id="cb27-14"><a href="#cb27-14" aria-hidden="true" tabindex="-1"></a><span class="in">#</span></span>
<span id="cb27-15"><a href="#cb27-15" aria-hidden="true" tabindex="-1"></a><span class="in"># for reproducibility purposes, we load the local julia environment/project, containing</span></span>
<span id="cb27-16"><a href="#cb27-16" aria-hidden="true" tabindex="-1"></a><span class="in">#  [13f3f980] CairoMakie v0.11.6</span></span>
<span id="cb27-17"><a href="#cb27-17" aria-hidden="true" tabindex="-1"></a><span class="in">#  [a93c6f00] DataFrames v1.6.1</span></span>
<span id="cb27-18"><a href="#cb27-18" aria-hidden="true" tabindex="-1"></a><span class="in">#  [864edb3b] DataStructures v0.18.16</span></span>
<span id="cb27-19"><a href="#cb27-19" aria-hidden="true" tabindex="-1"></a><span class="in">#  [0c46a032] DifferentialEquations v7.12.0</span></span>
<span id="cb27-20"><a href="#cb27-20" aria-hidden="true" tabindex="-1"></a><span class="in">#  [e9467ef8] GLMakie v0.9.6</span></span>
<span id="cb27-21"><a href="#cb27-21" aria-hidden="true" tabindex="-1"></a><span class="in">#  [91a5bcdd] Plots v1.40.0</span></span>
<span id="cb27-22"><a href="#cb27-22" aria-hidden="true" tabindex="-1"></a><span class="in">#  [f27b6e38] Polynomials v4.0.6</span></span>
<span id="cb27-23"><a href="#cb27-23" aria-hidden="true" tabindex="-1"></a><span class="in">#  [90137ffa] StaticArrays v1.9.1</span></span>
<span id="cb27-24"><a href="#cb27-24" aria-hidden="true" tabindex="-1"></a><span class="in">#  [0c5d862f] Symbolics v5.16.1</span></span>
<span id="cb27-25"><a href="#cb27-25" aria-hidden="true" tabindex="-1"></a><span class="in">#</span></span>
<span id="cb27-26"><a href="#cb27-26" aria-hidden="true" tabindex="-1"></a><span class="in"># to share the environment, copy Project.toml and Manifest.toml files in some directory</span></span>
<span id="cb27-27"><a href="#cb27-27" aria-hidden="true" tabindex="-1"></a><span class="in"># `activate` the local environment</span></span>
<span id="cb27-28"><a href="#cb27-28" aria-hidden="true" tabindex="-1"></a><span class="in"># if necessary `instantiate` to get the correct package versions</span></span>
<span id="cb27-29"><a href="#cb27-29" aria-hidden="true" tabindex="-1"></a><span class="in">#</span></span>
<span id="cb27-30"><a href="#cb27-30" aria-hidden="true" tabindex="-1"></a><span class="in"># to check if some PackageName.jl is used from the local environment</span></span>
<span id="cb27-31"><a href="#cb27-31" aria-hidden="true" tabindex="-1"></a><span class="in">## Pkg.status("PackageName")</span></span>
<span id="cb27-32"><a href="#cb27-32" aria-hidden="true" tabindex="-1"></a><span class="in">using Pkg</span></span>
<span id="cb27-33"><a href="#cb27-33" aria-hidden="true" tabindex="-1"></a><span class="in">Pkg.activate(".")</span></span>
<span id="cb27-34"><a href="#cb27-34" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb27-35"><a href="#cb27-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-36"><a href="#cb27-36" aria-hidden="true" tabindex="-1"></a><span class="fu">## Modèle de Rosenzweig MacArthur</span></span>
<span id="cb27-37"><a href="#cb27-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-38"><a href="#cb27-38" aria-hidden="true" tabindex="-1"></a>Nous considérons le modèle de dynamique de populations de Rosenzweig et MacArthur que nous avons déjà vu (@Rosenzweig1963, @Turchin2003, @Smith2008).</span>
<span id="cb27-39"><a href="#cb27-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-40"><a href="#cb27-40" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb27-41"><a href="#cb27-41" aria-hidden="true" tabindex="-1"></a>\left<span class="sc">\{</span>\begin{array}{l}</span>
<span id="cb27-42"><a href="#cb27-42" aria-hidden="true" tabindex="-1"></a>\dot x = \displaystyle rx\left(1-\frac{x}{K}\right) - c \frac{x}{h+x} y<span class="sc">\\</span><span class="co">[</span><span class="ot">.3cm</span><span class="co">]</span></span>
<span id="cb27-43"><a href="#cb27-43" aria-hidden="true" tabindex="-1"></a>\dot y = b\displaystyle \frac{x}{h+x} y - m y</span>
<span id="cb27-44"><a href="#cb27-44" aria-hidden="true" tabindex="-1"></a>\end{array}\right.</span>
<span id="cb27-45"><a href="#cb27-45" aria-hidden="true" tabindex="-1"></a>$$ {#eq-rma}</span>
<span id="cb27-46"><a href="#cb27-46" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-47"><a href="#cb27-47" aria-hidden="true" tabindex="-1"></a>L'objectif est de réaliser des simulations performantes sur le tracé du diagramme de bifurcations, avec l'estimation par simulation du cycle limite. Ce type de simulations lourdes se prête bien à se genre de benchmark.</span>
<span id="cb27-48"><a href="#cb27-48" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-49"><a href="#cb27-49" aria-hidden="true" tabindex="-1"></a><span class="fu">### Stratégie pour le code</span></span>
<span id="cb27-50"><a href="#cb27-50" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-51"><a href="#cb27-51" aria-hidden="true" tabindex="-1"></a>Pour un tel problème de dimension réduite, nous allons utiliser des static arrays (tableaux à adresse fixe dans la mémoire^<span class="co">[</span><span class="ot">depuis le package `StaticArrays.jl`</span><span class="co">]</span>), ce qui permettra de ne pas crééer une multitude d'objets pour la simulation mais de toujours modifier le même objet en mémoire.</span>
<span id="cb27-52"><a href="#cb27-52" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-53"><a href="#cb27-53" aria-hidden="true" tabindex="-1"></a>Par ailleurs nous allons essayer de nous conformer au maximum aux préconisations :</span>
<span id="cb27-54"><a href="#cb27-54" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-55"><a href="#cb27-55" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>ne pas utiliser de variables globales</span>
<span id="cb27-56"><a href="#cb27-56" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>définir des fonctions</span>
<span id="cb27-57"><a href="#cb27-57" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>mettre les paramètres dans un nombre limité de variables et les passer en arguments des fonctions</span>
<span id="cb27-58"><a href="#cb27-58" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-59"><a href="#cb27-59" aria-hidden="true" tabindex="-1"></a>Pour ce dernier point, nous allons définir des types (<span class="in">`struct`</span>) spécifiques.</span>
<span id="cb27-60"><a href="#cb27-60" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-61"><a href="#cb27-61" aria-hidden="true" tabindex="-1"></a>Nous commençons par importer les packages que nous allons utiliser:</span>
<span id="cb27-64"><a href="#cb27-64" aria-hidden="true" tabindex="-1"></a><span class="in">```{julia}</span></span>
<span id="cb27-65"><a href="#cb27-65" aria-hidden="true" tabindex="-1"></a><span class="in">using StaticArrays</span></span>
<span id="cb27-66"><a href="#cb27-66" aria-hidden="true" tabindex="-1"></a><span class="in">using DifferentialEquations</span></span>
<span id="cb27-67"><a href="#cb27-67" aria-hidden="true" tabindex="-1"></a><span class="in">using CairoMakie</span></span>
<span id="cb27-68"><a href="#cb27-68" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb27-69"><a href="#cb27-69" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-70"><a href="#cb27-70" aria-hidden="true" tabindex="-1"></a><span class="fu">### Type spécifique pour les paramètres</span></span>
<span id="cb27-71"><a href="#cb27-71" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-72"><a href="#cb27-72" aria-hidden="true" tabindex="-1"></a>Nous définissons un <span class="in">`struct`</span> pour les paramètres du modèle de Rosenzweig MacArthur.</span>
<span id="cb27-73"><a href="#cb27-73" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-74"><a href="#cb27-74" aria-hidden="true" tabindex="-1"></a>Type pour les paramètres :</span>
<span id="cb27-77"><a href="#cb27-77" aria-hidden="true" tabindex="-1"></a><span class="in">```{julia}</span></span>
<span id="cb27-78"><a href="#cb27-78" aria-hidden="true" tabindex="-1"></a><span class="in"># parameters struct</span></span>
<span id="cb27-79"><a href="#cb27-79" aria-hidden="true" tabindex="-1"></a><span class="in">@kwdef struct ParRma</span></span>
<span id="cb27-80"><a href="#cb27-80" aria-hidden="true" tabindex="-1"></a><span class="in">    r::Float64 = 1.0</span></span>
<span id="cb27-81"><a href="#cb27-81" aria-hidden="true" tabindex="-1"></a><span class="in">    K::Float64 = 10.0</span></span>
<span id="cb27-82"><a href="#cb27-82" aria-hidden="true" tabindex="-1"></a><span class="in">    c::Float64 = 1.0</span></span>
<span id="cb27-83"><a href="#cb27-83" aria-hidden="true" tabindex="-1"></a><span class="in">    h::Float64 = 2.0</span></span>
<span id="cb27-84"><a href="#cb27-84" aria-hidden="true" tabindex="-1"></a><span class="in">    b::Float64 = 2.0</span></span>
<span id="cb27-85"><a href="#cb27-85" aria-hidden="true" tabindex="-1"></a><span class="in">    m::Float64 = 1.0</span></span>
<span id="cb27-86"><a href="#cb27-86" aria-hidden="true" tabindex="-1"></a><span class="in">end</span></span>
<span id="cb27-87"><a href="#cb27-87" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb27-88"><a href="#cb27-88" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-89"><a href="#cb27-89" aria-hidden="true" tabindex="-1"></a>::: {.callout-note}</span>
<span id="cb27-90"><a href="#cb27-90" aria-hidden="true" tabindex="-1"></a>La macro <span class="in">`@kwdef`</span> permet de renseigner des valeurs par défaut des champs du <span class="in">`struct`</span>.</span>
<span id="cb27-91"><a href="#cb27-91" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb27-92"><a href="#cb27-92" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-93"><a href="#cb27-93" aria-hidden="true" tabindex="-1"></a>::: {.callout-important}</span>
<span id="cb27-94"><a href="#cb27-94" aria-hidden="true" tabindex="-1"></a>Lors de la création d'un <span class="in">`struct`</span>, on peut être tenté d'utiliser des types de champs les plus larges possibles, comme par exemple <span class="in">`r::Real = 1.0`</span> ou <span class="in">`r::Number = 1.0`</span>.</span>
<span id="cb27-95"><a href="#cb27-95" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-96"><a href="#cb27-96" aria-hidden="true" tabindex="-1"></a>*C'est une très mauvaise idée* : <span class="in">`Real`</span> et <span class="in">`Number`</span> sont des types abstraits qui englobent de nombreux types concrets (e.g. <span class="in">`Int64`</span> et <span class="in">`Float64`</span>). Par construction ils ne permettent pas de spécifier un espace mémoire de taille fixe comme le font les types concrets, et ne permettent donc pas d'optimiser le code à la précompilation^<span class="co">[</span><span class="ot">Par exemple, la fonction `cy_rma()` définie plus bas (la plus coûteuse en temps de calcul) est 70 fois plus lente avec un `ParRma` qui définit ses champs en `Real` plutôt qu'en `Float64`, (exécution de ~0.5s à ~35s après précompilation)</span><span class="co">]</span>.</span>
<span id="cb27-97"><a href="#cb27-97" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-98"><a href="#cb27-98" aria-hidden="true" tabindex="-1"></a>A l'inverse, pour les fonctions, il est préférable de choisir le type le plus large possible pour la spécification des arguments.</span>
<span id="cb27-99"><a href="#cb27-99" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb27-100"><a href="#cb27-100" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-101"><a href="#cb27-101" aria-hidden="true" tabindex="-1"></a>On peut créer des objets de type <span class="in">`ParRma`</span> via les <span class="in">`constructor`</span> par défaut; on accède à un champ particulier via <span class="in">`objet.champ`</span> :</span>
<span id="cb27-104"><a href="#cb27-104" aria-hidden="true" tabindex="-1"></a><span class="in">```{julia}</span></span>
<span id="cb27-105"><a href="#cb27-105" aria-hidden="true" tabindex="-1"></a><span class="in">#| output: true</span></span>
<span id="cb27-106"><a href="#cb27-106" aria-hidden="true" tabindex="-1"></a><span class="in"># with the struct definition, ParRma objects are immutable</span></span>
<span id="cb27-107"><a href="#cb27-107" aria-hidden="true" tabindex="-1"></a><span class="in">prma = ParRma() # constructor with default values</span></span>
<span id="cb27-108"><a href="#cb27-108" aria-hidden="true" tabindex="-1"></a><span class="in">prma2 = ParRma(K = 8.0) # default values except K = 20.0</span></span>
<span id="cb27-109"><a href="#cb27-109" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-110"><a href="#cb27-110" aria-hidden="true" tabindex="-1"></a><span class="in">@show prma</span></span>
<span id="cb27-111"><a href="#cb27-111" aria-hidden="true" tabindex="-1"></a><span class="in">@show prma.K</span></span>
<span id="cb27-112"><a href="#cb27-112" aria-hidden="true" tabindex="-1"></a><span class="in">@show prma2.K;</span></span>
<span id="cb27-113"><a href="#cb27-113" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb27-114"><a href="#cb27-114" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-115"><a href="#cb27-115" aria-hidden="true" tabindex="-1"></a>::: {.callout-note}</span>
<span id="cb27-116"><a href="#cb27-116" aria-hidden="true" tabindex="-1"></a>La macro <span class="in">`@show`</span> est assez explicite</span>
<span id="cb27-117"><a href="#cb27-117" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-118"><a href="#cb27-118" aria-hidden="true" tabindex="-1"></a>Le <span class="in">`;`</span> permet de ne pas renvoyer l'évaluation de la commande <span class="in">`prma2.K`</span> (qui vaut 8.0) étant donné que nous avons déjà forcé la sortie via <span class="in">`@show`</span></span>
<span id="cb27-119"><a href="#cb27-119" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb27-120"><a href="#cb27-120" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-121"><a href="#cb27-121" aria-hidden="true" tabindex="-1"></a><span class="fu">### Fonctions</span></span>
<span id="cb27-122"><a href="#cb27-122" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-123"><a href="#cb27-123" aria-hidden="true" tabindex="-1"></a>Nous définissons les différentes fonctions impliquées dans le modèle de Rosenzweig MacArthur, la logistique et la réponse fonctionnelle de Holling II.</span>
<span id="cb27-124"><a href="#cb27-124" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-125"><a href="#cb27-125" aria-hidden="true" tabindex="-1"></a>Pour la logistique :</span>
<span id="cb27-128"><a href="#cb27-128" aria-hidden="true" tabindex="-1"></a><span class="in">```{julia}</span></span>
<span id="cb27-129"><a href="#cb27-129" aria-hidden="true" tabindex="-1"></a><span class="in">function logistic(x::Real, p::ParRma)</span></span>
<span id="cb27-130"><a href="#cb27-130" aria-hidden="true" tabindex="-1"></a><span class="in">    (; r, K) = p    # deconstruct/get r and K from p</span></span>
<span id="cb27-131"><a href="#cb27-131" aria-hidden="true" tabindex="-1"></a><span class="in">    return r*x*(1-x/K)</span></span>
<span id="cb27-132"><a href="#cb27-132" aria-hidden="true" tabindex="-1"></a><span class="in">end</span></span>
<span id="cb27-133"><a href="#cb27-133" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb27-134"><a href="#cb27-134" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-135"><a href="#cb27-135" aria-hidden="true" tabindex="-1"></a>::: {.callout-note}</span>
<span id="cb27-136"><a href="#cb27-136" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>les notations <span class="in">`var::Type`</span> permettent de spécifier le type de l'argument de la fonction^<span class="co">[</span><span class="ot">C'est une des manières de faire du [multiple dispatch](https://docs.julialang.org/en/v1/manual/methods/), en définissant différentes méthodes pour les fonctions selon le type de l'argument</span><span class="co">]</span></span>
<span id="cb27-137"><a href="#cb27-137" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>la notation <span class="in">`(; r, K) = p`</span> permet d'extraire (*deconstruct*) les champs <span class="in">`r`</span> et <span class="in">`K`</span> du paramètre <span class="in">`p`</span> qui est un objet de type <span class="in">`ParRma`</span></span>
<span id="cb27-138"><a href="#cb27-138" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb27-139"><a href="#cb27-139" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-140"><a href="#cb27-140" aria-hidden="true" tabindex="-1"></a>Pour la réponse fonctionnelle (sans le paramètre $c$) :</span>
<span id="cb27-143"><a href="#cb27-143" aria-hidden="true" tabindex="-1"></a><span class="in">```{julia}</span></span>
<span id="cb27-144"><a href="#cb27-144" aria-hidden="true" tabindex="-1"></a><span class="in">function holling2(x::Real, p::ParRma)</span></span>
<span id="cb27-145"><a href="#cb27-145" aria-hidden="true" tabindex="-1"></a><span class="in">    (; h) = p   # deconstruct h from p</span></span>
<span id="cb27-146"><a href="#cb27-146" aria-hidden="true" tabindex="-1"></a><span class="in">    return x/(x+h)</span></span>
<span id="cb27-147"><a href="#cb27-147" aria-hidden="true" tabindex="-1"></a><span class="in">end</span></span>
<span id="cb27-148"><a href="#cb27-148" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb27-149"><a href="#cb27-149" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-150"><a href="#cb27-150" aria-hidden="true" tabindex="-1"></a><span class="fu">### Conditions initiales</span></span>
<span id="cb27-151"><a href="#cb27-151" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-152"><a href="#cb27-152" aria-hidden="true" tabindex="-1"></a>Pour utiliser les static arrays avec <span class="in">`DifferentialEquations.jl`</span> il faut que l'état (donc la condition initiale) et les dérivées rendues par le modèle soient des static arrays (ici un <span class="in">`SVector`</span>).</span>
<span id="cb27-153"><a href="#cb27-153" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-154"><a href="#cb27-154" aria-hidden="true" tabindex="-1"></a>Nous définissons un <span class="in">`struct`</span> de condition initiales, avec pour champs <span class="in">`x0`</span>, <span class="in">`y0`</span> et un <span class="in">`Svector`</span> composé de ces deux valeurs :</span>
<span id="cb27-155"><a href="#cb27-155" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-158"><a href="#cb27-158" aria-hidden="true" tabindex="-1"></a><span class="in">```{julia}</span></span>
<span id="cb27-159"><a href="#cb27-159" aria-hidden="true" tabindex="-1"></a><span class="in">#| output: true</span></span>
<span id="cb27-160"><a href="#cb27-160" aria-hidden="true" tabindex="-1"></a><span class="in"># initial value struct</span></span>
<span id="cb27-161"><a href="#cb27-161" aria-hidden="true" tabindex="-1"></a><span class="in">@kwdef struct IniV</span></span>
<span id="cb27-162"><a href="#cb27-162" aria-hidden="true" tabindex="-1"></a><span class="in">    x0::Float64 = 1.0</span></span>
<span id="cb27-163"><a href="#cb27-163" aria-hidden="true" tabindex="-1"></a><span class="in">    y0::Float64 = 1.95</span></span>
<span id="cb27-164"><a href="#cb27-164" aria-hidden="true" tabindex="-1"></a><span class="in">    u0::SVector{2, Float64} = SVector(x0, y0)</span></span>
<span id="cb27-165"><a href="#cb27-165" aria-hidden="true" tabindex="-1"></a><span class="in">end</span></span>
<span id="cb27-166"><a href="#cb27-166" aria-hidden="true" tabindex="-1"></a><span class="in"># construct some initial condition</span></span>
<span id="cb27-167"><a href="#cb27-167" aria-hidden="true" tabindex="-1"></a><span class="in">@show iniv = IniV();</span></span>
<span id="cb27-168"><a href="#cb27-168" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb27-169"><a href="#cb27-169" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-170"><a href="#cb27-170" aria-hidden="true" tabindex="-1"></a>Nous définissons un constructeur additionnel pour le type <span class="in">`IniV`</span> qui à partir d'un <span class="in">`SVector`</span> de longueur 2, construit l'objet <span class="in">`IniV`</span> correspondant^<span class="co">[</span><span class="ot">il s'agit d'une forme de multiple dispatch sur le constructeur, avec plusieurs méthodes différents selon le type d'arguments utilisés</span><span class="co">]</span> (nous nous en servirons plus bas dans la fonction <span class="in">`cy_rma()`</span>)</span>
<span id="cb27-171"><a href="#cb27-171" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-174"><a href="#cb27-174" aria-hidden="true" tabindex="-1"></a><span class="in">```{julia}</span></span>
<span id="cb27-175"><a href="#cb27-175" aria-hidden="true" tabindex="-1"></a><span class="in">#| output: true</span></span>
<span id="cb27-176"><a href="#cb27-176" aria-hidden="true" tabindex="-1"></a><span class="in"># new constructor method for struct IniV</span></span>
<span id="cb27-177"><a href="#cb27-177" aria-hidden="true" tabindex="-1"></a><span class="in"># takes a length 2 SVector to construct the object (self definition)</span></span>
<span id="cb27-178"><a href="#cb27-178" aria-hidden="true" tabindex="-1"></a><span class="in">IniV(u0::SVector{2, Float64}) = IniV(x0 = u0[1], y0 = u0[2])</span></span>
<span id="cb27-179"><a href="#cb27-179" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-180"><a href="#cb27-180" aria-hidden="true" tabindex="-1"></a><span class="in"># construct an initial condition with this constructor</span></span>
<span id="cb27-181"><a href="#cb27-181" aria-hidden="true" tabindex="-1"></a><span class="in">@show IniV(SVector(3.0, 3.0));</span></span>
<span id="cb27-182"><a href="#cb27-182" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb27-183"><a href="#cb27-183" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-184"><a href="#cb27-184" aria-hidden="true" tabindex="-1"></a><span class="fu">### Modèle</span></span>
<span id="cb27-185"><a href="#cb27-185" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-186"><a href="#cb27-186" aria-hidden="true" tabindex="-1"></a>On définit les équations du modèle en exploitant les fonctions définies plus haut et la structure des paramètres, en renvoyant les dérivées sous forme de <span class="in">`SVector`</span> :</span>
<span id="cb27-187"><a href="#cb27-187" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-190"><a href="#cb27-190" aria-hidden="true" tabindex="-1"></a><span class="in">```{julia}</span></span>
<span id="cb27-191"><a href="#cb27-191" aria-hidden="true" tabindex="-1"></a><span class="in">function mod_rma(u::SVector{2}, p::ParRma, t)</span></span>
<span id="cb27-192"><a href="#cb27-192" aria-hidden="true" tabindex="-1"></a><span class="in">    (; c, b, m) = p     # get c, b, m from p</span></span>
<span id="cb27-193"><a href="#cb27-193" aria-hidden="true" tabindex="-1"></a><span class="in">    x = u[1]            # use x, y notations</span></span>
<span id="cb27-194"><a href="#cb27-194" aria-hidden="true" tabindex="-1"></a><span class="in">    y = u[2]</span></span>
<span id="cb27-195"><a href="#cb27-195" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-196"><a href="#cb27-196" aria-hidden="true" tabindex="-1"></a><span class="in">    dx = logistic(x, p) - c * holling2(x,p) * y</span></span>
<span id="cb27-197"><a href="#cb27-197" aria-hidden="true" tabindex="-1"></a><span class="in">    dy = b * holling2(x, p) * y - m * y</span></span>
<span id="cb27-198"><a href="#cb27-198" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-199"><a href="#cb27-199" aria-hidden="true" tabindex="-1"></a><span class="in">    return SVector(dx, dy) # return derivatives as SVector</span></span>
<span id="cb27-200"><a href="#cb27-200" aria-hidden="true" tabindex="-1"></a><span class="in">end</span></span>
<span id="cb27-201"><a href="#cb27-201" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb27-202"><a href="#cb27-202" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-203"><a href="#cb27-203" aria-hidden="true" tabindex="-1"></a><span class="fu">### Simulation simple</span></span>
<span id="cb27-204"><a href="#cb27-204" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-205"><a href="#cb27-205" aria-hidden="true" tabindex="-1"></a>On définit les paramètres du temps dans un <span class="in">`struct`</span> :</span>
<span id="cb27-208"><a href="#cb27-208" aria-hidden="true" tabindex="-1"></a><span class="in">```{julia}</span></span>
<span id="cb27-209"><a href="#cb27-209" aria-hidden="true" tabindex="-1"></a><span class="in"># time parameters struct</span></span>
<span id="cb27-210"><a href="#cb27-210" aria-hidden="true" tabindex="-1"></a><span class="in">@kwdef struct ParTime</span></span>
<span id="cb27-211"><a href="#cb27-211" aria-hidden="true" tabindex="-1"></a><span class="in">    tspan::Tuple{Float64, Float64} = (0.0, 60.0)</span></span>
<span id="cb27-212"><a href="#cb27-212" aria-hidden="true" tabindex="-1"></a><span class="in">    tstep::Float64 = 0.1</span></span>
<span id="cb27-213"><a href="#cb27-213" aria-hidden="true" tabindex="-1"></a><span class="in">end</span></span>
<span id="cb27-214"><a href="#cb27-214" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-215"><a href="#cb27-215" aria-hidden="true" tabindex="-1"></a><span class="in"># construct a time parameter</span></span>
<span id="cb27-216"><a href="#cb27-216" aria-hidden="true" tabindex="-1"></a><span class="in">ptime = ParTime()</span></span>
<span id="cb27-217"><a href="#cb27-217" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb27-218"><a href="#cb27-218" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-219"><a href="#cb27-219" aria-hidden="true" tabindex="-1"></a>On définit une fonction qui définit le problème de simulation, l'intègre et retourne la solution, avec pour arguments positionnels la condition initiale, les paramètres et les paramètres de temps, et comme keyword argument le paramètre booléen <span class="in">`final`</span>.</span>
<span id="cb27-220"><a href="#cb27-220" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-221"><a href="#cb27-221" aria-hidden="true" tabindex="-1"></a>Lorsque <span class="in">`final = false`</span> (par défaut), la fonction renvoie toute la solution. Lorsque <span class="in">`final  =true`</span> la fonction renvoie la valeur finale de la simulation, ce dont nous nous servirons plus bas dans l'estimation des extremas du cycle limite.</span>
<span id="cb27-224"><a href="#cb27-224" aria-hidden="true" tabindex="-1"></a><span class="in">```{julia}</span></span>
<span id="cb27-225"><a href="#cb27-225" aria-hidden="true" tabindex="-1"></a><span class="in">#| output: true</span></span>
<span id="cb27-226"><a href="#cb27-226" aria-hidden="true" tabindex="-1"></a><span class="in">function sim_rma(iniv::IniV, p::ParRma, pt::ParTime; final::Bool = false)</span></span>
<span id="cb27-227"><a href="#cb27-227" aria-hidden="true" tabindex="-1"></a><span class="in">    # deconstruct time parameter</span></span>
<span id="cb27-228"><a href="#cb27-228" aria-hidden="true" tabindex="-1"></a><span class="in">    (; tspan, tstep) = pt</span></span>
<span id="cb27-229"><a href="#cb27-229" aria-hidden="true" tabindex="-1"></a><span class="in">    (; u0) = iniv</span></span>
<span id="cb27-230"><a href="#cb27-230" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-231"><a href="#cb27-231" aria-hidden="true" tabindex="-1"></a><span class="in">    # define and solve simulation problem</span></span>
<span id="cb27-232"><a href="#cb27-232" aria-hidden="true" tabindex="-1"></a><span class="in">    prob_rma = ODEProblem(mod_rma, u0, tspan, p)</span></span>
<span id="cb27-233"><a href="#cb27-233" aria-hidden="true" tabindex="-1"></a><span class="in">    if !final   # if final == false compute whole solution</span></span>
<span id="cb27-234"><a href="#cb27-234" aria-hidden="true" tabindex="-1"></a><span class="in">        sol_rma = solve(prob_rma; reltol = 1e-6, saveat = tstep)</span></span>
<span id="cb27-235"><a href="#cb27-235" aria-hidden="true" tabindex="-1"></a><span class="in">    else        # if final == true compute only final state</span></span>
<span id="cb27-236"><a href="#cb27-236" aria-hidden="true" tabindex="-1"></a><span class="in">        sol_rma = solve(</span></span>
<span id="cb27-237"><a href="#cb27-237" aria-hidden="true" tabindex="-1"></a><span class="in">            prob_rma;</span></span>
<span id="cb27-238"><a href="#cb27-238" aria-hidden="true" tabindex="-1"></a><span class="in">            reltol = 1e-6,</span></span>
<span id="cb27-239"><a href="#cb27-239" aria-hidden="true" tabindex="-1"></a><span class="in">            save_everystep = false,</span></span>
<span id="cb27-240"><a href="#cb27-240" aria-hidden="true" tabindex="-1"></a><span class="in">            save_start = false,</span></span>
<span id="cb27-241"><a href="#cb27-241" aria-hidden="true" tabindex="-1"></a><span class="in">        )</span></span>
<span id="cb27-242"><a href="#cb27-242" aria-hidden="true" tabindex="-1"></a><span class="in">    end</span></span>
<span id="cb27-243"><a href="#cb27-243" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-244"><a href="#cb27-244" aria-hidden="true" tabindex="-1"></a><span class="in">    return sol_rma</span></span>
<span id="cb27-245"><a href="#cb27-245" aria-hidden="true" tabindex="-1"></a><span class="in">end</span></span>
<span id="cb27-246"><a href="#cb27-246" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-247"><a href="#cb27-247" aria-hidden="true" tabindex="-1"></a><span class="in">@time sim_rma(iniv, prma, ptime);</span></span>
<span id="cb27-248"><a href="#cb27-248" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb27-249"><a href="#cb27-249" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-250"><a href="#cb27-250" aria-hidden="true" tabindex="-1"></a>::: {.callout-note}</span>
<span id="cb27-251"><a href="#cb27-251" aria-hidden="true" tabindex="-1"></a>La macro <span class="in">`@time`</span> renvoit le temps (et qqes éléments sur la computation) mis pour calculer la commande qui la suit, ici la simulation.</span>
<span id="cb27-252"><a href="#cb27-252" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb27-253"><a href="#cb27-253" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-254"><a href="#cb27-254" aria-hidden="true" tabindex="-1"></a>Une fois la fonction précompilée à la première exécution, la performance est incomparable (4 ordres de grandeur plus rapide sur la fonction <span class="in">`sim_rma()`</span>) :</span>
<span id="cb27-255"><a href="#cb27-255" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-258"><a href="#cb27-258" aria-hidden="true" tabindex="-1"></a><span class="in">```{julia}</span></span>
<span id="cb27-259"><a href="#cb27-259" aria-hidden="true" tabindex="-1"></a><span class="in">#| output: true</span></span>
<span id="cb27-260"><a href="#cb27-260" aria-hidden="true" tabindex="-1"></a><span class="in">@time sim_rma(iniv, prma2, ptime);</span></span>
<span id="cb27-261"><a href="#cb27-261" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb27-262"><a href="#cb27-262" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-263"><a href="#cb27-263" aria-hidden="true" tabindex="-1"></a><span class="fu">### Solution contre le temps</span></span>
<span id="cb27-264"><a href="#cb27-264" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-265"><a href="#cb27-265" aria-hidden="true" tabindex="-1"></a>Finalement, on définit une fonction qui simule et produit un graphique de la solution contre le temps, avec pour arguments la condition initiale, les paramètres et les paramètres de temps :</span>
<span id="cb27-268"><a href="#cb27-268" aria-hidden="true" tabindex="-1"></a><span class="in">```{julia}</span></span>
<span id="cb27-269"><a href="#cb27-269" aria-hidden="true" tabindex="-1"></a><span class="in">#| eval: true</span></span>
<span id="cb27-270"><a href="#cb27-270" aria-hidden="true" tabindex="-1"></a><span class="in">function plot_rma(iniv::IniV, p::ParRma, pt::ParTime)</span></span>
<span id="cb27-271"><a href="#cb27-271" aria-hidden="true" tabindex="-1"></a><span class="in">    # compute the simulation</span></span>
<span id="cb27-272"><a href="#cb27-272" aria-hidden="true" tabindex="-1"></a><span class="in">    sol_rma = sim_rma(iniv, p, pt)</span></span>
<span id="cb27-273"><a href="#cb27-273" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-274"><a href="#cb27-274" aria-hidden="true" tabindex="-1"></a><span class="in">    # initialize figure</span></span>
<span id="cb27-275"><a href="#cb27-275" aria-hidden="true" tabindex="-1"></a><span class="in">    fig = Figure(; fontsize = 20)</span></span>
<span id="cb27-276"><a href="#cb27-276" aria-hidden="true" tabindex="-1"></a><span class="in">    ax = Axis(fig[1,1];</span></span>
<span id="cb27-277"><a href="#cb27-277" aria-hidden="true" tabindex="-1"></a><span class="in">        title = "Modèle de Rosenzweig MacArthur\n ",</span></span>
<span id="cb27-278"><a href="#cb27-278" aria-hidden="true" tabindex="-1"></a><span class="in">        xlabel = "temps",</span></span>
<span id="cb27-279"><a href="#cb27-279" aria-hidden="true" tabindex="-1"></a><span class="in">        ylabel = "densités",</span></span>
<span id="cb27-280"><a href="#cb27-280" aria-hidden="true" tabindex="-1"></a><span class="in">    )</span></span>
<span id="cb27-281"><a href="#cb27-281" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-282"><a href="#cb27-282" aria-hidden="true" tabindex="-1"></a><span class="in">    # plot solution</span></span>
<span id="cb27-283"><a href="#cb27-283" aria-hidden="true" tabindex="-1"></a><span class="in">    lines!(ax, sol_rma.t, sol_rma[1,:]; lw = 2, label = "proies")</span></span>
<span id="cb27-284"><a href="#cb27-284" aria-hidden="true" tabindex="-1"></a><span class="in">    lines!(ax, sol_rma.t,  sol_rma[2,:]; lw = 2, label = "prédateurs")</span></span>
<span id="cb27-285"><a href="#cb27-285" aria-hidden="true" tabindex="-1"></a><span class="in">    axislegend(; position = :lt)</span></span>
<span id="cb27-286"><a href="#cb27-286" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-287"><a href="#cb27-287" aria-hidden="true" tabindex="-1"></a><span class="in">    return fig</span></span>
<span id="cb27-288"><a href="#cb27-288" aria-hidden="true" tabindex="-1"></a><span class="in">end</span></span>
<span id="cb27-289"><a href="#cb27-289" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb27-290"><a href="#cb27-290" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-291"><a href="#cb27-291" aria-hidden="true" tabindex="-1"></a>Finalement on exécute cette fonction pour tracer la simulation :</span>
<span id="cb27-294"><a href="#cb27-294" aria-hidden="true" tabindex="-1"></a><span class="in">```{julia}</span></span>
<span id="cb27-295"><a href="#cb27-295" aria-hidden="true" tabindex="-1"></a><span class="in">#| output: true</span></span>
<span id="cb27-296"><a href="#cb27-296" aria-hidden="true" tabindex="-1"></a><span class="in">#| label: fig-rma-time</span></span>
<span id="cb27-297"><a href="#cb27-297" aria-hidden="true" tabindex="-1"></a><span class="in">#| fig-cap: Simulation des trajectoires du modèle de Rosenzweig MacArthur</span></span>
<span id="cb27-298"><a href="#cb27-298" aria-hidden="true" tabindex="-1"></a><span class="in">plot_rma(iniv, prma, ptime)</span></span>
<span id="cb27-299"><a href="#cb27-299" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb27-300"><a href="#cb27-300" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-301"><a href="#cb27-301" aria-hidden="true" tabindex="-1"></a><span class="fu">### Diagramme de bifurcations</span></span>
<span id="cb27-302"><a href="#cb27-302" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-303"><a href="#cb27-303" aria-hidden="true" tabindex="-1"></a>Nous calculons ici le diagramme de bifurcations : les asymptotiques des prédateurs $y^*$ en fonction de $K$.</span>
<span id="cb27-304"><a href="#cb27-304" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-305"><a href="#cb27-305" aria-hidden="true" tabindex="-1"></a><span class="fu">#### Équilibres</span></span>
<span id="cb27-306"><a href="#cb27-306" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-307"><a href="#cb27-307" aria-hidden="true" tabindex="-1"></a>Il n'y a pas besoin de simulation ici puisque les lieux des équilibres sont facilement calculables analytiquement (cf. cette <span class="co">[</span><span class="ot">page</span><span class="co">](pop_interactions2.qmd)</span>).</span>
<span id="cb27-308"><a href="#cb27-308" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-309"><a href="#cb27-309" aria-hidden="true" tabindex="-1"></a>Nous définissons une fonction qui prend les paramètres du modèle et renvoit des tuples définissant les différentes branches d'équilibres $(K, y^*)$ (avec en <span class="in">`kwarg`</span> un <span class="in">`Kmax`</span> et un <span class="in">`Kstep`</span> avec des valeurs par défaut).</span>
<span id="cb27-310"><a href="#cb27-310" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-313"><a href="#cb27-313" aria-hidden="true" tabindex="-1"></a><span class="in">```{julia}</span></span>
<span id="cb27-314"><a href="#cb27-314" aria-hidden="true" tabindex="-1"></a><span class="in">#| output: false</span></span>
<span id="cb27-315"><a href="#cb27-315" aria-hidden="true" tabindex="-1"></a><span class="in">function eqy_rma(p::ParRma; Kmax::Real = 8.0, Kstep::Real = 0.1)</span></span>
<span id="cb27-316"><a href="#cb27-316" aria-hidden="true" tabindex="-1"></a><span class="in">    (; r, c, h, b, m) = p # deconstruct p (K is useless since it is varied)</span></span>
<span id="cb27-317"><a href="#cb27-317" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-318"><a href="#cb27-318" aria-hidden="true" tabindex="-1"></a><span class="in">    # define bifurcation K values</span></span>
<span id="cb27-319"><a href="#cb27-319" aria-hidden="true" tabindex="-1"></a><span class="in">    Ktrans = m*h/(b-m)</span></span>
<span id="cb27-320"><a href="#cb27-320" aria-hidden="true" tabindex="-1"></a><span class="in">    Khopf = h+2*m*h/(b-m)</span></span>
<span id="cb27-321"><a href="#cb27-321" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-322"><a href="#cb27-322" aria-hidden="true" tabindex="-1"></a><span class="in">    # drops an error if Kmax is too small</span></span>
<span id="cb27-323"><a href="#cb27-323" aria-hidden="true" tabindex="-1"></a><span class="in">    if Kmax &lt; Khopf</span></span>
<span id="cb27-324"><a href="#cb27-324" aria-hidden="true" tabindex="-1"></a><span class="in">        error("For a full computation of equilibria types, Kmax must be greater than $Khopf")</span></span>
<span id="cb27-325"><a href="#cb27-325" aria-hidden="true" tabindex="-1"></a><span class="in">    end</span></span>
<span id="cb27-326"><a href="#cb27-326" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-327"><a href="#cb27-327" aria-hidden="true" tabindex="-1"></a><span class="in">    # y equilibria</span></span>
<span id="cb27-328"><a href="#cb27-328" aria-hidden="true" tabindex="-1"></a><span class="in">    # below transcritical : only y=0</span></span>
<span id="cb27-329"><a href="#cb27-329" aria-hidden="true" tabindex="-1"></a><span class="in">    Krg1 = 0:Kstep:Ktrans</span></span>
<span id="cb27-330"><a href="#cb27-330" aria-hidden="true" tabindex="-1"></a><span class="in">    y01 = ones(length(Krg1)).*0     # broadcasting</span></span>
<span id="cb27-331"><a href="#cb27-331" aria-hidden="true" tabindex="-1"></a><span class="in">    eqs1 = (Krg = Krg1, y0 = y01, yco = nothing)</span></span>
<span id="cb27-332"><a href="#cb27-332" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-333"><a href="#cb27-333" aria-hidden="true" tabindex="-1"></a><span class="in">    # between transcritical and Hopf : y=0 and y&gt;0</span></span>
<span id="cb27-334"><a href="#cb27-334" aria-hidden="true" tabindex="-1"></a><span class="in">    Krg2 = Ktrans:Kstep:Khopf</span></span>
<span id="cb27-335"><a href="#cb27-335" aria-hidden="true" tabindex="-1"></a><span class="in">    y02 = ones(length(Krg2)).*0</span></span>
<span id="cb27-336"><a href="#cb27-336" aria-hidden="true" tabindex="-1"></a><span class="in">    yco2 = [r/c*(h+m*h/(b-m))*(1-m*h/(b-m)/K) for K in Krg2]</span></span>
<span id="cb27-337"><a href="#cb27-337" aria-hidden="true" tabindex="-1"></a><span class="in">    eqs2 = (Krg = Krg2, y0 = y02, yco = yco2)</span></span>
<span id="cb27-338"><a href="#cb27-338" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-339"><a href="#cb27-339" aria-hidden="true" tabindex="-1"></a><span class="in">    # above Hopf : y=0 and y&gt;0</span></span>
<span id="cb27-340"><a href="#cb27-340" aria-hidden="true" tabindex="-1"></a><span class="in">    Krg3 = Khopf:Kstep:Kmax</span></span>
<span id="cb27-341"><a href="#cb27-341" aria-hidden="true" tabindex="-1"></a><span class="in">    y03 = ones(length(Krg3)).*0</span></span>
<span id="cb27-342"><a href="#cb27-342" aria-hidden="true" tabindex="-1"></a><span class="in">    yco3 = [r/c*(h+m*h/(b-m))*(1-m*h/(b-m)/K) for K in Krg3]</span></span>
<span id="cb27-343"><a href="#cb27-343" aria-hidden="true" tabindex="-1"></a><span class="in">    eqs3 = (Krg = Krg3, y0 = y03, yco = yco3)</span></span>
<span id="cb27-344"><a href="#cb27-344" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-345"><a href="#cb27-345" aria-hidden="true" tabindex="-1"></a><span class="in">    return eqs1, eqs2, eqs3</span></span>
<span id="cb27-346"><a href="#cb27-346" aria-hidden="true" tabindex="-1"></a><span class="in">end</span></span>
<span id="cb27-347"><a href="#cb27-347" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb27-348"><a href="#cb27-348" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-349"><a href="#cb27-349" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-350"><a href="#cb27-350" aria-hidden="true" tabindex="-1"></a><span class="fu">#### Cycle limite</span></span>
<span id="cb27-351"><a href="#cb27-351" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-352"><a href="#cb27-352" aria-hidden="true" tabindex="-1"></a>On définit une fonction qui renvoit un tuple contenant les valeurs de $K$ et les extremas du cycle limite apparaissant pour $K &gt; K_{hopf} = h+\frac{2mh}{b-m}$.</span>
<span id="cb27-353"><a href="#cb27-353" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-354"><a href="#cb27-354" aria-hidden="true" tabindex="-1"></a>La fonction prend pour argument les paramètres, et fait appel à la fonction <span class="in">`sim_rma()`</span> avec les méthodes <span class="in">`final = true`</span> (pour les transitoires) et <span class="in">`final = false`</span> (pour les extremas du cycle limite). Elle utilise aussi le constructeur supplémentaire pour les objets <span class="in">`IniV`</span>.</span>
<span id="cb27-355"><a href="#cb27-355" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-356"><a href="#cb27-356" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-359"><a href="#cb27-359" aria-hidden="true" tabindex="-1"></a><span class="in">```{julia}</span></span>
<span id="cb27-360"><a href="#cb27-360" aria-hidden="true" tabindex="-1"></a><span class="in">#| output: true</span></span>
<span id="cb27-361"><a href="#cb27-361" aria-hidden="true" tabindex="-1"></a><span class="in">#| eval: true</span></span>
<span id="cb27-362"><a href="#cb27-362" aria-hidden="true" tabindex="-1"></a><span class="in">function cy_rma(p::ParRma; Kmax::Float64 = 8.0, Kstep::Float64 = 0.01)</span></span>
<span id="cb27-363"><a href="#cb27-363" aria-hidden="true" tabindex="-1"></a><span class="in">    # parameters and K range</span></span>
<span id="cb27-364"><a href="#cb27-364" aria-hidden="true" tabindex="-1"></a><span class="in">    (; r, c, h, b, m) = p # deconstruct p (K is useless since it is varied)</span></span>
<span id="cb27-365"><a href="#cb27-365" aria-hidden="true" tabindex="-1"></a><span class="in">    Khopf = h+2*m*h/(b-m)</span></span>
<span id="cb27-366"><a href="#cb27-366" aria-hidden="true" tabindex="-1"></a><span class="in">    Krgh = Khopf-Kstep:Kstep:Kmax</span></span>
<span id="cb27-367"><a href="#cb27-367" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-368"><a href="#cb27-368" aria-hidden="true" tabindex="-1"></a><span class="in">    # drops an error if Kmax is too small</span></span>
<span id="cb27-369"><a href="#cb27-369" aria-hidden="true" tabindex="-1"></a><span class="in">    if Kmax &lt; Khopf</span></span>
<span id="cb27-370"><a href="#cb27-370" aria-hidden="true" tabindex="-1"></a><span class="in">        error("For a computation of the limit cycle, Kmax must be greater than $Khopf")</span></span>
<span id="cb27-371"><a href="#cb27-371" aria-hidden="true" tabindex="-1"></a><span class="in">    end</span></span>
<span id="cb27-372"><a href="#cb27-372" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-373"><a href="#cb27-373" aria-hidden="true" tabindex="-1"></a><span class="in">    # for storage</span></span>
<span id="cb27-374"><a href="#cb27-374" aria-hidden="true" tabindex="-1"></a><span class="in">    ycmin = zero(Krgh)</span></span>
<span id="cb27-375"><a href="#cb27-375" aria-hidden="true" tabindex="-1"></a><span class="in">    ycmax = zero(Krgh)</span></span>
<span id="cb27-376"><a href="#cb27-376" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-377"><a href="#cb27-377" aria-hidden="true" tabindex="-1"></a><span class="in">    # initial value and time parameters</span></span>
<span id="cb27-378"><a href="#cb27-378" aria-hidden="true" tabindex="-1"></a><span class="in">    iniv = IniV()</span></span>
<span id="cb27-379"><a href="#cb27-379" aria-hidden="true" tabindex="-1"></a><span class="in">    ptime = ParTime()</span></span>
<span id="cb27-380"><a href="#cb27-380" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-381"><a href="#cb27-381" aria-hidden="true" tabindex="-1"></a><span class="in">    # transient integration time</span></span>
<span id="cb27-382"><a href="#cb27-382" aria-hidden="true" tabindex="-1"></a><span class="in">    ptrans = ParTime(tspan = (0.0, 8000.0))</span></span>
<span id="cb27-383"><a href="#cb27-383" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-384"><a href="#cb27-384" aria-hidden="true" tabindex="-1"></a><span class="in">    for (i, Kh) in enumerate(Krgh)</span></span>
<span id="cb27-385"><a href="#cb27-385" aria-hidden="true" tabindex="-1"></a><span class="in">        # construct parameter from p, with K = Kh of the loop</span></span>
<span id="cb27-386"><a href="#cb27-386" aria-hidden="true" tabindex="-1"></a><span class="in">        prmabif = ParRma(r, Kh, c, h, b, m)</span></span>
<span id="cb27-387"><a href="#cb27-387" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-388"><a href="#cb27-388" aria-hidden="true" tabindex="-1"></a><span class="in">        # simulate transient, get final state</span></span>
<span id="cb27-389"><a href="#cb27-389" aria-hidden="true" tabindex="-1"></a><span class="in">        utr = sim_rma(iniv, prmabif, ptrans; final = true)[:,1]</span></span>
<span id="cb27-390"><a href="#cb27-390" aria-hidden="true" tabindex="-1"></a><span class="in">        inivtr = IniV(utr) # construct new init value</span></span>
<span id="cb27-391"><a href="#cb27-391" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-392"><a href="#cb27-392" aria-hidden="true" tabindex="-1"></a><span class="in">        # start from end of transient, simulate limit cycle</span></span>
<span id="cb27-393"><a href="#cb27-393" aria-hidden="true" tabindex="-1"></a><span class="in">        sol_cyc = sim_rma(inivtr, prmabif, ptime)</span></span>
<span id="cb27-394"><a href="#cb27-394" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-395"><a href="#cb27-395" aria-hidden="true" tabindex="-1"></a><span class="in">        # get min and max y along the cycle</span></span>
<span id="cb27-396"><a href="#cb27-396" aria-hidden="true" tabindex="-1"></a><span class="in">        ycmin[i] = minimum(sol_cyc[2,:])</span></span>
<span id="cb27-397"><a href="#cb27-397" aria-hidden="true" tabindex="-1"></a><span class="in">        ycmax[i] = maximum(sol_cyc[2,:])</span></span>
<span id="cb27-398"><a href="#cb27-398" aria-hidden="true" tabindex="-1"></a><span class="in">    end</span></span>
<span id="cb27-399"><a href="#cb27-399" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-400"><a href="#cb27-400" aria-hidden="true" tabindex="-1"></a><span class="in">    cycle = (Krg = Krgh, ycmin = ycmin, ycmax = ycmax)</span></span>
<span id="cb27-401"><a href="#cb27-401" aria-hidden="true" tabindex="-1"></a><span class="in">    return cycle</span></span>
<span id="cb27-402"><a href="#cb27-402" aria-hidden="true" tabindex="-1"></a><span class="in">end</span></span>
<span id="cb27-403"><a href="#cb27-403" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-404"><a href="#cb27-404" aria-hidden="true" tabindex="-1"></a><span class="in">@time cy_rma(prma);</span></span>
<span id="cb27-405"><a href="#cb27-405" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb27-406"><a href="#cb27-406" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-407"><a href="#cb27-407" aria-hidden="true" tabindex="-1"></a>Après précompilation, ce calcul est encore plus rapide :</span>
<span id="cb27-410"><a href="#cb27-410" aria-hidden="true" tabindex="-1"></a><span class="in">```{julia}</span></span>
<span id="cb27-411"><a href="#cb27-411" aria-hidden="true" tabindex="-1"></a><span class="in">#| output: true</span></span>
<span id="cb27-412"><a href="#cb27-412" aria-hidden="true" tabindex="-1"></a><span class="in">#| eval: true</span></span>
<span id="cb27-413"><a href="#cb27-413" aria-hidden="true" tabindex="-1"></a><span class="in">@time cy_rma(prma2);</span></span>
<span id="cb27-414"><a href="#cb27-414" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb27-415"><a href="#cb27-415" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-416"><a href="#cb27-416" aria-hidden="true" tabindex="-1"></a>A titre d'exemple, la simulation sur cette <span class="co">[</span><span class="ot">page</span><span class="co">](pop_interactions2.qmd)</span> prenait de l'ordre de 20 fois plus longtemps pour un calcul similaire.</span>
<span id="cb27-417"><a href="#cb27-417" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-418"><a href="#cb27-418" aria-hidden="true" tabindex="-1"></a><span class="fu">#### Représentation graphique</span></span>
<span id="cb27-419"><a href="#cb27-419" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-420"><a href="#cb27-420" aria-hidden="true" tabindex="-1"></a>Finalement, nous définissons une fonction permettant de représenter le diagramme de bifurcations, qui fait appel aux fonctions <span class="in">`eqy_rma()`</span> et <span class="in">`cy_rma()`</span> définies ci-dessus :</span>
<span id="cb27-421"><a href="#cb27-421" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-424"><a href="#cb27-424" aria-hidden="true" tabindex="-1"></a><span class="in">```{julia}</span></span>
<span id="cb27-425"><a href="#cb27-425" aria-hidden="true" tabindex="-1"></a><span class="in">function plot_bif_rma(p::ParRma; Kmax = 8.0, Kstep = 0.1)</span></span>
<span id="cb27-426"><a href="#cb27-426" aria-hidden="true" tabindex="-1"></a><span class="in">    # initialize figure</span></span>
<span id="cb27-427"><a href="#cb27-427" aria-hidden="true" tabindex="-1"></a><span class="in">    fig = Figure(; fontsize = 20)</span></span>
<span id="cb27-428"><a href="#cb27-428" aria-hidden="true" tabindex="-1"></a><span class="in">    ax = Axis(fig[1,1];</span></span>
<span id="cb27-429"><a href="#cb27-429" aria-hidden="true" tabindex="-1"></a><span class="in">        title = "Bifurcations du modèle de Rosenzweig MacArthur\n ",</span></span>
<span id="cb27-430"><a href="#cb27-430" aria-hidden="true" tabindex="-1"></a><span class="in">        xlabel = "capacité de charge 𝐾",</span></span>
<span id="cb27-431"><a href="#cb27-431" aria-hidden="true" tabindex="-1"></a><span class="in">        ylabel = "densités",</span></span>
<span id="cb27-432"><a href="#cb27-432" aria-hidden="true" tabindex="-1"></a><span class="in">    )</span></span>
<span id="cb27-433"><a href="#cb27-433" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-434"><a href="#cb27-434" aria-hidden="true" tabindex="-1"></a><span class="in">    # plot equilibria</span></span>
<span id="cb27-435"><a href="#cb27-435" aria-hidden="true" tabindex="-1"></a><span class="in">    eqs1, eqs2, eqs3 = eqy_rma(p; Kmax = Kmax, Kstep = Kstep)</span></span>
<span id="cb27-436"><a href="#cb27-436" aria-hidden="true" tabindex="-1"></a><span class="in">    lines!(eqs1.Krg, eqs1.y0; color = Cycled(1), lw = 2, label = "branche stable")</span></span>
<span id="cb27-437"><a href="#cb27-437" aria-hidden="true" tabindex="-1"></a><span class="in">    lines!(eqs2.Krg, eqs2.y0; color = Cycled(2), lw = 2, label = "branche instable")</span></span>
<span id="cb27-438"><a href="#cb27-438" aria-hidden="true" tabindex="-1"></a><span class="in">    lines!(eqs2.Krg, eqs2.yco; color = Cycled(1), lw = 2)</span></span>
<span id="cb27-439"><a href="#cb27-439" aria-hidden="true" tabindex="-1"></a><span class="in">    lines!(eqs3.Krg, eqs3.y0; color = Cycled(2), lw = 2)</span></span>
<span id="cb27-440"><a href="#cb27-440" aria-hidden="true" tabindex="-1"></a><span class="in">    lines!(eqs3.Krg, eqs3.yco; color = Cycled(2), lw = 2)</span></span>
<span id="cb27-441"><a href="#cb27-441" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-442"><a href="#cb27-442" aria-hidden="true" tabindex="-1"></a><span class="in">    # plot limit Cycle</span></span>
<span id="cb27-443"><a href="#cb27-443" aria-hidden="true" tabindex="-1"></a><span class="in">    cycle = cy_rma(p; Kmax = Kmax) # we keep the default Kstep = 0.01 for accuracy</span></span>
<span id="cb27-444"><a href="#cb27-444" aria-hidden="true" tabindex="-1"></a><span class="in">    lines!(cycle.Krg, cycle.ycmin; color = Cycled(3), lw=2, label = "cycle limite")</span></span>
<span id="cb27-445"><a href="#cb27-445" aria-hidden="true" tabindex="-1"></a><span class="in">    lines!(cycle.Krg, cycle.ycmax; color = Cycled(3), lw=2)</span></span>
<span id="cb27-446"><a href="#cb27-446" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-447"><a href="#cb27-447" aria-hidden="true" tabindex="-1"></a><span class="in">    axislegend(ax, position = :lt, labelsize = 14)</span></span>
<span id="cb27-448"><a href="#cb27-448" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-449"><a href="#cb27-449" aria-hidden="true" tabindex="-1"></a><span class="in">    return fig</span></span>
<span id="cb27-450"><a href="#cb27-450" aria-hidden="true" tabindex="-1"></a><span class="in">end</span></span>
<span id="cb27-451"><a href="#cb27-451" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb27-452"><a href="#cb27-452" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-453"><a href="#cb27-453" aria-hidden="true" tabindex="-1"></a>Ce qui donne :</span>
<span id="cb27-454"><a href="#cb27-454" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-457"><a href="#cb27-457" aria-hidden="true" tabindex="-1"></a><span class="in">```{julia}</span></span>
<span id="cb27-458"><a href="#cb27-458" aria-hidden="true" tabindex="-1"></a><span class="in">#| output: true</span></span>
<span id="cb27-459"><a href="#cb27-459" aria-hidden="true" tabindex="-1"></a><span class="in">#| label: fig-rma-bif</span></span>
<span id="cb27-460"><a href="#cb27-460" aria-hidden="true" tabindex="-1"></a><span class="in">#| fig-cap: Diagramme de bifurcations du modèle de Rosenzweig MacArthur</span></span>
<span id="cb27-461"><a href="#cb27-461" aria-hidden="true" tabindex="-1"></a><span class="in">plot_bif_rma(prma)</span></span>
<span id="cb27-462"><a href="#cb27-462" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb27-463"><a href="#cb27-463" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-464"><a href="#cb27-464" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-465"><a href="#cb27-465" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-466"><a href="#cb27-466" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-467"><a href="#cb27-467" aria-hidden="true" tabindex="-1"></a><span class="fu">### Organisation en modules</span></span>
<span id="cb27-468"><a href="#cb27-468" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-469"><a href="#cb27-469" aria-hidden="true" tabindex="-1"></a>Avec cette écriture de programme exploitant au maximum des structs et des fonctions, il est facile de placer l'ensemble des définitions dans un module dans fichier séparé, et de créer un script principal qui appelle ce module et ne demande que quelques lignes pour effectuer les simulations présentées plus haut sur cette page.</span>
<span id="cb27-470"><a href="#cb27-470" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-471"><a href="#cb27-471" aria-hidden="true" tabindex="-1"></a>Une telle architecture fichier/moudle/script principal est présentée sur <span class="co">[</span><span class="ot">cette page</span><span class="co">](annexe_rma_module.qmd)</span>.</span>
<span id="cb27-472"><a href="#cb27-472" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-473"><a href="#cb27-473" aria-hidden="true" tabindex="-1"></a><span class="fu">## Cas des modèles de plus grande dimension</span></span>
<span id="cb27-474"><a href="#cb27-474" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-475"><a href="#cb27-475" aria-hidden="true" tabindex="-1"></a>Pour les modèles de plus grande dimension ($n&gt;8$), l'avantage en performance des static arrays n'est plus si net et la documentation de <span class="in">`DifferentialEquations.jl`</span> recommande d'utiliser la version en place (is in place, IIP dans le jargon du package) de l'interface problem/solver du package.</span>
<span id="cb27-476"><a href="#cb27-476" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-477"><a href="#cb27-477" aria-hidden="true" tabindex="-1"></a>Il s'agit ici de définir le modèle non pas comme renvoyant la dérivée en fonction de l'état, des paramètres et du temps, mais comme une fonction d'arguments la dérivée, l'état, les paramètres et le temps qui modifie en place la dérivée (et ne renvoie rien). Cela permet de muter un même objet dérivée <span class="in">`du`</span> à chaque fois que le modèle est appelé, plutôt que de créer un nouvel objet dérivée <span class="in">`du`</span> à chaque appel du modèle (c'est aussi dans le même esprit de ce qui est fait, différemment, avec les static arrays plus haut).</span>
<span id="cb27-478"><a href="#cb27-478" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-479"><a href="#cb27-479" aria-hidden="true" tabindex="-1"></a>Typiquement ce type de modèle IIP (en place) s'écrit:</span>
<span id="cb27-480"><a href="#cb27-480" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-483"><a href="#cb27-483" aria-hidden="true" tabindex="-1"></a><span class="in">```{julia}</span></span>
<span id="cb27-484"><a href="#cb27-484" aria-hidden="true" tabindex="-1"></a><span class="in">function mod_rma!(du, u, p::ParRma, t)</span></span>
<span id="cb27-485"><a href="#cb27-485" aria-hidden="true" tabindex="-1"></a><span class="in">    (; c, b, m) = p     # get c, b, m from p</span></span>
<span id="cb27-486"><a href="#cb27-486" aria-hidden="true" tabindex="-1"></a><span class="in">    x = u[1]            # use x, y notations</span></span>
<span id="cb27-487"><a href="#cb27-487" aria-hidden="true" tabindex="-1"></a><span class="in">    y = u[2]</span></span>
<span id="cb27-488"><a href="#cb27-488" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-489"><a href="#cb27-489" aria-hidden="true" tabindex="-1"></a><span class="in">    # in-place computation of du</span></span>
<span id="cb27-490"><a href="#cb27-490" aria-hidden="true" tabindex="-1"></a><span class="in">    du[1] = logistic(x, p) - c * holling2(x,p) * y</span></span>
<span id="cb27-491"><a href="#cb27-491" aria-hidden="true" tabindex="-1"></a><span class="in">    du[2] = b * holling2(x, p) * y - m * y</span></span>
<span id="cb27-492"><a href="#cb27-492" aria-hidden="true" tabindex="-1"></a><span class="in">    return nothing</span></span>
<span id="cb27-493"><a href="#cb27-493" aria-hidden="true" tabindex="-1"></a><span class="in">end</span></span>
<span id="cb27-494"><a href="#cb27-494" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb27-495"><a href="#cb27-495" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-496"><a href="#cb27-496" aria-hidden="true" tabindex="-1"></a>La définition du problème d'intégration et l'appel de solve est similaire aux autres méthodes, à ceci près que la condition initiale et la dérivée doit être mutable, ce qui ne permet pas (ou très difficilement) d'utiliser la méthode en dimension 1. En effet une déclaration <span class="in">`u0 = 1.0`</span> ou <span class="in">`du = 3.0`</span> n'est pas mutable^<span class="co">[</span><span class="ot">alors que `u0 = [1.0, 2.0]` ou `du =[2.0, 3.0]` le sont. Plus sur la mutabilité dans les [Julia notes](https://m3g.github.io/JuliaNotes.jl/stable/immutable/).</span><span class="co">]</span>.</span>
</code><button title="Copy to Clipboard" class="code-copy-button" data-in-quarto-modal=""><i class="bi"></i></button></pre></div>
</div></div></div></div></div>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
      &nbsp;
    </div>   
    <div class="nav-footer-center">
<p>Copyright 2023, Ludovic Mailleret</p>
<div class="toc-actions d-sm-block d-md-none"><ul><li><a href="https://github.com/lmaillere/biomaths_www/edit/main/annexe_swift_rma.qmd" class="toc-action"><i class="bi bi-github"></i>Edit this page</a></li><li><a href="https://github.com/lmaillere/biomaths_www/issues/new" class="toc-action"><i class="bi empty"></i>Report an issue</a></li></ul></div></div>
    <div class="nav-footer-right">
      &nbsp;
    </div>
  </div>
</footer>




</body></html>