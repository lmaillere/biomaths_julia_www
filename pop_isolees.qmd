---
title: "Populations isolées"
---


## Le modèle de Malthus {#sec-malthus}

Nous considérons le modèle proposé par @malthus :
$$
\dot x = (n-m)x,
$$ {#eq-malthus}
avec $n$ le taux de natalité, et $m$ le taux de mortalité.

### Préliminaires

Pour simuler ce modèle, c'est à dire intégrer numériquement les solutions au problème de Cauchy correspondant à l'@eq-malthus avec $x(0)=x_0\geq0$, nous allons utiliser les routines de `DifferentialEquations.jl` avec la méthode par défaut. Nous utiliserons aussi le package `Plots.jl` pour les représentations graphiques.

```{julia}
using Plots, DifferentialEquations
```

### Conditions initiales, paramètres et temps

Nous définissions la condition initiale de la simulation :

```{julia}
x0 = 0.1
```

Nous définissons les paramètres, et les encapsulons dans un vecteur de paramètres :

```{julia}
n = 3.0     # natalité
m = 2.0     # morrtalité
par_malthus = [n, m] # packing
```

Enfin, les propriétés du temps d'intégration :
```{julia}
tspan = (0.0, 10.0)
tstep = 0.1
```

### Système dynamique

On définit le modèle comme une fonction renvoyant la dérivée de $x$ (comme `SVector`) en fonction de l'état, de paramètres, et du temps. L'ordre des arguments est important, c'est sous cette forme que les routines d'intégration attendent le modèle.

```{julia}
function malthus(u, p, t)
    n, m = p        # unpacking
    x = u[1]        # use x notation
    dx = (n-m)x     # return derivative
end
```

### Intégration

On commence par définir le problème de Cauchy à intégrer, comme un `ODEProblem` avec arguments: le modèle, la condition initiale, les bornes d'intégration, les paramètres ainsi que l'option `saveat = tstep` permettant de récupérer la solution tout les `tstep` pas de temps (il y a plein d'options de sortie de l'intégration, dont même une fonction du temps !)

```{julia}
prob_malthus = ODEProblem(malthus,          # modèle
                          x0,               # condition initiale
                          tspan,            # tspan
                          par_malthus,      # paramètres
                          saveat = tstep)   # option de sortie
```

On intègre le modèle via `solve`, défini par `DifferentialEquations.jl` pour des `struct` de type `ODEProblem` :

```{julia}
sol_malthus = solve(prob_malthus)
```

Le type de solution renvoyée par le solveur est assez complexe et comprend de nombreux champs informatifs sur le calcul. On peut accéder au temps de simulation via `sol_malthus.t` :

```{julia}
#| output: true
first(sol_malthus.t, 3)
```

ainsi qu'aux valeurs de la variable $x$ calculées le long du temps via `sol_matlhus.u` :

```{julia}
#| output: true
first(sol_malthus.u, 3)
```

Même si ce n'est pas indispensable, il est possible de transformer la solution renvoyée facilement en `DataFrame`, qui peut permettre des manipulations plus faciles.

```{julia}
using DataFrames

sol_malthus = DataFrame(sol_malthus)
rename!(sol_malthus, :timestamp => :time, :value => :x)
```

si bien que :

```{julia}
#| output: true
first(sol_malthus, 3)
```

### Représentation graphique


On peut représenter graphiquement la simulation de la croissance de la population au cours du temps (ici via le dataframe).

```{julia}
#| output: true
plot(sol_malthus.time, sol_malthus.x,
    palette = :tab10,
    linewidth = 2,
    title = "\n Modèle de Malthus \$n=$n, m=$m\$",
    label = "population \$x\$",  
    ylabel = "densité de population \$x(t)\$", 
    xlabel = "temps \$t\$",
    margin = .5Plots.cm,
    topmargin = 1Plots.cm)
```

## Le modèle logistique {#sec-logistic}

Nous considérons ici le modèle "logistique" proposé par @verhulst1838 :

$$
\dot x = r x \left(1-\frac{x}{K}\right),
$$ {#eq-logistic}
avec $r$ le taux de croissance intrinsèque de la population et $K$ la capacité de charge de l'environnement.


Il n'y a pas de difficulté particulière par rapport aux simulations précedentes. On va réutiliser la condition initiale et les paramètres de temps définis précédemment. 

Il faut cependant définir les paramètres du modèle @eq-logistic :
```{julia}
r = 1.0     # natalité
K = 10.0     # morrtalité
par_logistic = [r, K] # packing
```

ainsi que le nouveau système dynamique :
```{julia}
function logistic(u, p, t)
    r, K = p        # unpacking
    x = u[1]        # use x notation
    dx = r*x*(1-x/K)     # return derivative
end
```

et le problème de Cauchy correspondant :
```{julia}
prob_logistic = ODEProblem(logistic,        # modèle
                          x0,               # condition initiale
                          tspan,            # tspan
                          par_logistic,     # paramètres
                          saveat = tstep)   # option de sortie
```

On simule et on transforme la solution en dataframe :
```{julia}
sol_logistic = solve(prob_logistic)

sol_logistic = DataFrame(sol_logistic)
rename!(sol_logistic, :timestamp => :time, :value => :x)
```

On trace la solution :
```{julia}
#| output: true
plot(sol_logistic.time, sol_logistic.x,
    palette = :tab10,
    linewidth = 2,
    title = "\n Modèle logistique \$r=$r, K=$K\$",
    label = "population \$x\$",  
    ylabel = "densité de population \$x(t)\$", 
    xlabel = "temps \$t\$",
    margin = .5Plots.cm,
    topmargin = 1Plots.cm)
```
\
and that's it !

Passons aux [populations exploitées](pop_exploitees.qmd).

