---
title: "Simulation am√©lior√©e"
---

## Mod√®le de Rosenzweig MacArthur

Nous consid√©rons le mod√®le de dynamique de populations de Rosenzweig et MacArthur que nous avons d√©j√† vu (@Rosenzweig1963, @Turchin2003, @Smith2008).

$$
\left\{\begin{array}{l}
\dot x = \displaystyle rx\left(1-\frac{x}{K}\right) - c \frac{x}{h+x} y\\[.3cm]
\dot y = b\displaystyle \frac{x}{h+x} y - m y
\end{array}\right.
$$ {#eq-rma}

L'objectif est de r√©aliser des simulations performantes sur le trac√© du diagramme de bifurcations, avec l'estimation par simulation du cycle limite. Ce type de simulations lourdes se pr√™te bien √† se genre de benchmark.

### Strat√©gie pour le code

Pour un tel probl√®me de dimension r√©duite, nous allons utiliser des static arrays (tableaux √† adresse fixe dans la m√©moire^[depuis le package `StaticArrays.jl`]), ce qui permettra de ne pas cr√©√©er une multitude d'objets pour la simulation mais de toujours modifier le m√™me objet en m√©moire.

Par ailleurs nous allons essayer de nous conformer au maximum aux pr√©conisations :

- ne pas utiliser de variables globales
- d√©finir des fonctions
- mettre les param√®tres dans un nombre limit√© de variables et les passer en arguments des fonctions

Pour ce dernier point, nous allons d√©finir des types (`struct`) sp√©cifiques.

Nous commen√ßons par importer les packages que nous allons utiliser:
```{julia}
using StaticArrays
using DifferentialEquations
using CairoMakie
```

### Type sp√©cifique pour les param√®tres

Nous d√©finissons un `struct` pour les param√®tres du mod√®le de Rosenzweig MacArthur.

Type pour les param√®tres :
```{julia}
# parameters struct
@kwdef struct ParRma
    r::Float64 = 1.0
    K::Float64 = 10.0
    c::Float64 = 1.0
    h::Float64 = 2.0
    b::Float64 = 2.0
    m::Float64 = 1.0
end
```

::: {.callout-note}
La macro `@kwdef` permet de renseigner des valeurs par d√©faut des champs du `struct`.
:::

::: {.callout-important}
Lors de la cr√©ation d'un `struct`, on peut √™tre tent√© d'utiliser des types de champs les plus larges possibles, comme par exemple `r::Real = 1.0` ou `r::Number = 1.0`.

*C'est une tr√®s mauvaise id√©e* : `Real` et `Number` sont des types abstraits qui englobent de nombreux types concrets (e.g. `Int64` et `Float64`). Par construction ils ne permettent pas de sp√©cifier un espace m√©moire de taille fixe comme le font les types concrets, et ne permettent donc pas d'optimiser le code √† la pr√©compilation^[Par exemple, la fonction `cy_rma()` d√©finie plus bas (la plus co√ªteuse en temps de calcul) est 70 fois plus lente avec un `ParRma` qui d√©finit ses champs en `Real` plut√¥t qu'en `Float64`, (ex√©cution de ~0.5s √† ~35s apr√®s pr√©compilation)].

A l'inverse, pour les fonctions, il est pr√©f√©rable de choisir le type le plus large possible pour la sp√©cification des arguments.
:::

On peut cr√©er des objets de type `ParRma` via les `constructor` par d√©faut; on acc√®de √† un champ particulier via `objet.champ` :
```{julia}
#| output: true
# with the struct definition, ParRma objects are immutable
prma = ParRma() # constructor with default values
prma2 = ParRma(K = 8.0) # default values except K = 20.0

@show prma
@show prma.K
@show prma2.K;
```

::: {.callout-note}
La macro `@show` est assez explicite

Le `;` permet de ne pas renvoyer l'√©valuation de la commande `prma2.K` (qui vaut 8.0) √©tant donn√© que nous avons d√©j√† forc√© la sortie via `@show`
:::

### Fonctions

Nous d√©finissons les diff√©rentes fonctions impliqu√©es dans le mod√®le de Rosenzweig MacArthur, la logistique et la r√©ponse fonctionnelle de Holling II.

Pour la logistique :
```{julia}
function logistic(x::Real, p::ParRma)
    (; r, K) = p    # deconstruct/get r and K from p
    return r*x*(1-x/K)
end
```

::: {.callout-note}
- les notations `var::Type` permettent de sp√©cifier le type de l'argument de la fonction^[C'est une des mani√®res de faire du [multiple dispatch](https://docs.julialang.org/en/v1/manual/methods/), en d√©finissant diff√©rentes m√©thodes pour les fonctions selon le type de l'argument]
- la notation `(; r, K) = p` permet d'extraire (*deconstruct*) les champs `r` et `K` du param√®tre `p` qui est un objet de type `ParRma`
:::

Pour la r√©ponse fonctionnelle (sans le param√®tre $c$) :
```{julia}
function holling2(x::Real, p::ParRma)
    (; h) = p   # deconstruct h from p
    return x/(x+h)
end
```

### Conditions initiales

Pour utiliser les static arrays avec `DifferentialEquations.jl` il faut que l'√©tat (donc la condition initiale) et les d√©riv√©es rendues par le mod√®le soient des static arrays (ici un `SVector`).

Nous d√©finissons un `struct` de condition initiales, avec pour champs `x0`, `y0` et un `Svector` compos√© de ces deux valeurs :

```{julia}
#| output: true
# initial value struct
@kwdef struct IniV
    x0::Float64 = 1.0
    y0::Float64 = 1.95
    u0::SVector{2, Float64} = SVector(x0, y0)
end
# construct some initial condition
@show iniv = IniV();
```

Nous d√©finissons un constructeur additionnel pour le type `IniV` qui √† partir d'un `SVector` de longueur 2, construit l'objet `IniV` correspondant^[il s'agit d'une forme de multiple dispatch sur le constructeur, avec plusieurs m√©thodes diff√©rents selon le type d'arguments utilis√©s] (nous nous en servirons plus bas dans la fonction `cy_rma()`)

```{julia}
#| output: true
# new constructor method for struct IniV
# takes a length 2 SVector to construct the object (self definition)
IniV(u0::SVector{2, Float64}) = IniV(x0 = u0[1], y0 = u0[2])

# construct an initial condition with this constructor
@show IniV(SVector(3.0, 3.0));
```

### Mod√®le

On d√©finit les √©quations du mod√®le en exploitant les fonctions d√©finies plus haut et la structure des param√®tres, en renvoyant les d√©riv√©es sous forme de `SVector` :

```{julia}
function mod_rma(u::SVector{2}, p::ParRma, t)
    (; c, b, m) = p     # get c, b, m from p
    x = u[1]            # use x, y notations
    y = u[2]

    dx = logistic(x, p) - c * holling2(x,p) * y
    dy = b * holling2(x, p) * y - m * y

    return SVector(dx, dy) # return derivatives as SVector
end
```

### Simulation simple

On d√©finit les param√®tres du temps dans un `struct` :
```{julia}
# time parameters struct
@kwdef struct ParTime
    tspan::Tuple{Float64, Float64} = (0.0, 60.0)
    tstep::Float64 = 0.1
end

# construct a time parameter
ptime = ParTime()
```

On d√©finit une fonction qui d√©finit le probl√®me de simulation, l'int√®gre et retourne la solution, avec pour arguments positionnels la condition initiale, les param√®tres et les param√®tres de temps, et comme keyword argument le param√®tre bool√©en `final`.

Lorsque `final = false` (par d√©faut), la fonction renvoie toute la solution. Lorsque `final  =true` la fonction renvoie la valeur finale de la simulation, ce dont nous nous servirons plus bas dans l'estimation des extremas du cycle limite.
```{julia}
#| output: true
function sim_rma(iniv::IniV, p::ParRma, pt::ParTime; final::Bool = false)
    # deconstruct time parameter
    (; tspan, tstep) = pt
    (; u0) = iniv

    # define and solve simulation problem
    prob_rma = ODEProblem(mod_rma, u0, tspan, p)
    if !final   # if final == false compute whole solution
        sol_rma = solve(prob_rma; reltol = 1e-6, saveat = tstep)
    else        # if final == true compute only final state
        sol_rma = solve(
            prob_rma;
            reltol = 1e-6,
            save_everystep = false,
            save_start = false,
        )
    end

    return sol_rma
end

@time sim_rma(iniv, prma, ptime);
```

::: {.callout-note}
La macro `@time` renvoit le temps (et qqes √©l√©ments sur la computation) mis pour calculer la commande qui la suit, ici la simulation.
:::

Une fois la fonction pr√©compil√©e √† la premi√®re ex√©cution, la performance est incomparable (4 ordres de grandeur plus rapide sur la fonction `sim_rma()`) :

```{julia}
#| output: true
@time sim_rma(iniv, prma2, ptime);
```

### Solution contre le temps

Finalement, on d√©finit une fonction qui simule et produit un graphique de la solution contre le temps, avec pour arguments la condition initiale, les param√®tres et les param√®tres de temps :
```{julia}
#| eval: true
function plot_rma(iniv::IniV, p::ParRma, pt::ParTime)
    # compute the simulation
    sol_rma = sim_rma(iniv, p, pt)

    # initialize figure
    fig = Figure(; fontsize = 20)
    ax = Axis(fig[1,1];
        title = "Mod√®le de Rosenzweig MacArthur\n ",
        xlabel = "temps",
        ylabel = "densit√©s",
    )

    # plot solution
    lines!(ax, sol_rma.t, sol_rma[1,:]; lw = 2, label = "proies")
    lines!(ax, sol_rma.t,  sol_rma[2,:]; lw = 2, label = "pr√©dateurs")
    axislegend(; position = :lt)

    return fig
end
```

Finalement on ex√©cute cette fonction pour tracer la simulation :
```{julia}
#| output: true
#| label: fig-rma-time
#| fig-cap: Simulation des trajectoires du mod√®le de Rosenzweig MacArthur
plot_rma(iniv, prma, ptime)
```

### Diagramme de bifurcations

Nous calculons ici le diagramme de bifurcations : les asymptotiques des pr√©dateurs $y^*$ en fonction de $K$.

#### √âquilibres

Il n'y a pas besoin de simulation ici puisque les lieux des √©quilibres sont facilement calculables analytiquement (cf. cette [page](pop_interactions2.qmd)).

Nous d√©finissons une fonction qui prend les param√®tres du mod√®le et renvoit des tuples d√©finissant les diff√©rentes branches d'√©quilibres $(K, y^*)$ (avec en `kwarg` un `Kmax` et un `Kstep` avec des valeurs par d√©faut).

```{julia}
#| output: false
function eqy_rma(p::ParRma; Kmax::Real = 8.0, Kstep::Real = 0.1)
    (; r, c, h, b, m) = p # deconstruct p (K is useless since it is varied)

    # define bifurcation K values
    Ktrans = m*h/(b-m)
    Khopf = h+2*m*h/(b-m)

    # drops an error if Kmax is too small
    if Kmax < Khopf
        error("For a full computation of equilibria types, Kmax must be greater than $Khopf")
    end

    # y equilibria
    # below transcritical : only y=0
    Krg1 = 0:Kstep:Ktrans
    y01 = ones(length(Krg1)).*0     # broadcasting
    eqs1 = (Krg = Krg1, y0 = y01, yco = nothing)

    # between transcritical and Hopf : y=0 and y>0
    Krg2 = Ktrans:Kstep:Khopf
    y02 = ones(length(Krg2)).*0
    yco2 = [r/c*(h+m*h/(b-m))*(1-m*h/(b-m)/K) for K in Krg2]
    eqs2 = (Krg = Krg2, y0 = y02, yco = yco2)

    # above Hopf : y=0 and y>0
    Krg3 = Khopf:Kstep:Kmax
    y03 = ones(length(Krg3)).*0
    yco3 = [r/c*(h+m*h/(b-m))*(1-m*h/(b-m)/K) for K in Krg3]
    eqs3 = (Krg = Krg3, y0 = y03, yco = yco3)

    return eqs1, eqs2, eqs3
end
```


#### Cycle limite

On d√©finit une fonction qui renvoit un tuple contenant les valeurs de $K$ et les extremas du cycle limite apparaissant pour $K > K_{hopf} = h+\frac{2mh}{b-m}$.

La fonction prend pour argument les param√®tres, et fait appel √† la fonction `sim_rma()` avec les m√©thodes `final = true` (pour les transitoires) et `final = false` (pour les extremas du cycle limite). Elle utilise aussi le constructeur suppl√©mentaire pour les objets `IniV`.


```{julia}
#| output: true
#| eval: true
function cy_rma(p::ParRma; Kmax::Float64 = 8.0, Kstep::Float64 = 0.01)
    # parameters and K range
    (; r, c, h, b, m) = p # deconstruct p (K is useless since it is varied)
    Khopf = h+2*m*h/(b-m)
    Krgh = Khopf-Kstep:Kstep:Kmax

    # drops an error if Kmax is too small
    if Kmax < Khopf
        error("For a computation of the limit cycle, Kmax must be greater than $Khopf")
    end

    # for storage
    ycmin = zero(Krgh)
    ycmax = zero(Krgh)

    # initial value and time parameters
    iniv = IniV()
    ptime = ParTime()

    # transient integration time
    ptrans = ParTime(tspan = (0.0, 8000.0))

    for (i, Kh) in enumerate(Krgh)
        # construct parameter from p, with K = Kh of the loop
        prmabif = ParRma(r, Kh, c, h, b, m)

        # simulate transient, get final state
        utr = sim_rma(iniv, prmabif, ptrans; final = true)[:,1]
        inivtr = IniV(utr) # construct new init value

        # start from end of transient, simulate limit cycle
        sol_cyc = sim_rma(inivtr, prmabif, ptime)

        # get min and max y along the cycle
        ycmin[i] = minimum(sol_cyc[2,:])
        ycmax[i] = maximum(sol_cyc[2,:])
    end

    cycle = (Krg = Krgh, ycmin = ycmin, ycmax = ycmax)
    return cycle
end

@time cy_rma(prma);
```

Apr√®s pr√©compilation, ce calcul est encore plus rapide :
```{julia}
#| output: true
#| eval: true
@time cy_rma(prma2);
```

A titre d'exemple, la simulation sur cette [page](pop_interactions2.qmd) prenait de l'ordre de 20 fois plus longtemps pour un calcul similaire.

#### Repr√©sentation graphique

Finalement, nous d√©finissons une fonction permettant de repr√©senter le diagramme de bifurcations, qui fait appel aux fonctions `eqy_rma()` et `cy_rma()` d√©finies ci-dessus :

```{julia}
function plot_bif_rma(p::ParRma; Kmax = 8.0, Kstep = 0.1)
    # initialize figure
    fig = Figure(; fontsize = 20)
    ax = Axis(fig[1,1];
        title = "Bifurcations du mod√®le de Rosenzweig MacArthur\n ",
        xlabel = "capacit√© de charge ùêæ",
        ylabel = "densit√©s",
    )

    # plot equilibria
    eqs1, eqs2, eqs3 = eqy_rma(p; Kmax = Kmax, Kstep = Kstep)
    lines!(eqs1.Krg, eqs1.y0; color = Cycled(1), lw = 2, label = "branche stable")
    lines!(eqs2.Krg, eqs2.y0; color = Cycled(2), lw = 2, label = "branche instable")
    lines!(eqs2.Krg, eqs2.yco; color = Cycled(1), lw = 2)
    lines!(eqs3.Krg, eqs3.y0; color = Cycled(2), lw = 2)
    lines!(eqs3.Krg, eqs3.yco; color = Cycled(2), lw = 2)

    # plot limit Cycle
    cycle = cy_rma(p; Kmax = Kmax) # we keep the default Kstep = 0.01 for accuracy
    lines!(cycle.Krg, cycle.ycmin; color = Cycled(3), lw=2, label = "cycle limite")
    lines!(cycle.Krg, cycle.ycmax; color = Cycled(3), lw=2)

    axislegend(ax, position = :lt, labelsize = 14)

    return fig
end
```

Ce qui donne :

```{julia}
#| output: true
#| label: fig-rma-bif
#| fig-cap: Diagramme de bifurcations du mod√®le de Rosenzweig MacArthur
plot_bif_rma(prma)
```




### Organisation en modules

Avec cette √©criture de programme exploitant au maximum des structs et des fonctions, il est facile de placer l'ensemble des d√©finitions dans un module dans fichier s√©par√©, et de cr√©er un script principal qui appelle ce module et ne demande que quelques lignes pour effectuer les simulations pr√©sent√©es plus haut sur cette page.

Une telle architecture fichier/moudle/script principal est pr√©sent√©e sur [cette page](annexe_rma_module.qmd).

## Cas des mod√®les de plus grande dimension

Pour les mod√®les de plus grande dimension ($n>8$), l'avantage en performance des static arrays n'est plus si net et la documentation de `DifferentialEquations.jl` recommande d'utiliser la version en place (is in place, IIP dans le jargon du package) de l'interface problem/solver du package.

Il s'agit ici de d√©finir le mod√®le non pas comme renvoyant la d√©riv√©e en fonction de l'√©tat, des param√®tres et du temps, mais comme une fonction d'arguments la d√©riv√©e, l'√©tat, les param√®tres et le temps qui modifie en place la d√©riv√©e (et ne renvoie rien). Cela permet de muter un m√™me objet d√©riv√©e `du` √† chaque fois que le mod√®le est appel√©, plut√¥t que de cr√©er un nouvel objet d√©riv√©e `du` √† chaque appel du mod√®le (c'est aussi dans le m√™me esprit de ce qui est fait, diff√©remment, avec les static arrays plus haut).

Typiquement ce type de mod√®le IIP (en place) s'√©crit:

```{julia}
function mod_rma!(du, u, p::ParRma, t)
    (; c, b, m) = p     # get c, b, m from p
    x = u[1]            # use x, y notations
    y = u[2]

    # in-place computation of du
    du[1] = logistic(x, p) - c * holling2(x,p) * y
    du[2] = b * holling2(x, p) * y - m * y
    return nothing
end
```

La d√©finition du probl√®me d'int√©gration et l'appel de solve est similaire aux autres m√©thodes, √† ceci pr√®s que la condition initiale et la d√©riv√©e doit √™tre mutable, ce qui ne permet pas (ou tr√®s difficilement) d'utiliser la m√©thode en dimension 1. En effet une d√©claration `u0 = 1.0` ou `du = 3.0` n'est pas mutable^[alors que `u0 = [1.0, 2.0]` ou `du =[2.0, 3.0]` le sont. Plus sur la mutabilit√© dans les [Julia notes](https://m3g.github.io/JuliaNotes.jl/stable/immutable/).].
