---
title: "Simulation optimisée"
---

## Modèle de Rosenzweig MacArthur

Nous considérons le modèle de dynamique de populations de Rosenzweig et MacArthur que nous avons déjà vu (@Rosenzweig1963, @Turchin2003, @Smith2008).

$$
\left\{\begin{array}{l}
\dot x = \displaystyle rx\left(1-\frac{x}{K}\right) - c \frac{x}{h+x} y\\[.3cm]
\dot y = b\displaystyle \frac{x}{h+x} y - m y
\end{array}\right.
$$ {#eq-rma}

L'objectif est de réaliser des simulations performantes, et le tracé du diagramme de bifurcation avec l'estimation par simulation du cycle limite. Ce type de simulations lourdes se prête bien à se genre de benchmark.

### Stratégie pour le code

Pour un tel problème de dimension réduite, nous allons utiliser des static arrays (tableaux à adresse fixe dans la mémoire^[depuis le package `StaticArrays.jl`]), ce qui permettra de ne pas crééer une multitude d'objets pour la simulation mais de toujours modifier le même objet en mémoire.

Par ailleurs nous allons essayer de nous conformer au maximum aux préconisations :

- ne pas utiliser de variables globales
- définir des fonctions
- mettre les paramètres dans un nombre limité de variables et les passer en arguments des fonctions

Pour ce dernier point, nous allons définir des types (`struct`) spécifiques.

Nous commençons par importer les packages que nous allons utiliser:
```{julia}
using StaticArrays
using DifferentialEquations
using CairoMakie
```

### Type spécifique pour les paramètres

Nous définissons un `struct` pour les paramètres du modèle de Rosenzweig MacArthur.

Type pour les paramètres :
```{julia}
@kwdef struct ParRma
    r::Float64 = 1.0
    K::Float64 = 10.0
    c::Float64 = 1.0
    h::Float64 = 2.0
    b::Float64 = 2.0
    m::Float64 = 1.0
end
```

::: {.callout-note}
La macro `@kwdef` permet de renseigner des valeurs par défaut des champs du `struct`.
:::

::: {.callout-important}
Lors de la création d'un type `struct`, on peut être tenté d'utiliser des types de champs les plus larges possibles, comme par exemple `r::Real = 1.0` ou `r::Number = 1.0`.

*C'est une très mauvaise idée* : `Real` et `Number` sont des types abstraits qui englobent de nombreux types concrets (e.g. `Int64` et `Float64`). Par construction ils ne permettent pas de spécifier un espace mémoire de taille fixe comme le font les types concrets, et ne permettent donc pas d'optimiser le code à la précompilation.

A titre d'exemple, la fonction `cy_rma()` définie plus bas est 70 fois plus lente avec un `ParRma` qui définit ses champs en `Real` plutôt qu'en `Float64`, passant de ~0.5s après pré-compilation à ~35s de temps d'exécution.
:::

On peut créer des objets de type `ParRma` via les `constructor` ; on accède à un champ particulier via `objet.champ` :
```{julia}
#| output: true
# ParRma type objects are immutable
p_rma = ParRma() # constructor with default values
p_rma2 = ParRma(K = 8.0) # default values except K = 20.0

@show p_rma
@show p_rma.K
@show p_rma2.K; # semi colon do not show output of par_rma2.K
```

::: {.callout-note}
La macro `@show` est assez explicite.
:::

### Fonctions

Nous définissons les différentes fonctions impliquées dans le modèle de Rosenzweig MacArthur, la logistique et la réponse fonctionnelle de Holling II.

Pour la logistique :
```{julia}
function logistic(x, p::ParRma)
    (; r, K) = p    # deconstruct/get r and K from p
    return r*x*(1-x/K)
end
```

::: {.callout-note}
- les notations `var::Type` permettent de spécifier le type de l'argument
- la notation `(; r, K) = p` permet d'extraire (*deconstruct*) les champs `r` et `K` du paramètre `p`
:::

Pour la réponse fonctionnelle (sans le paramètre $c$) :
```{julia}
function holling2(x, p::ParRma)
    (; h) = p   # deconstruct h from p
    return x/(x+h)
end
```

### Conditions initiales

Pour utiliser les static arrays avec `DifferentialEquations.jl` il faut que la condition initiale (donc l'état) et les dérivées soient des static arrays (ici un `SVector`)

```{julia}
#| output: true
#| eval: false
const x0 = 1.0
const y0 = 1.95

# SVector are immutables
u0 = SVector(x0, y0)
```

```{julia}
@kwdef struct IniV
    x0::Float64 = 1.0
    y0::Float64 = 1.95
    u0::SVector{2, Float64} = SVector(x0, y0)
end
```

```{julia}
#| output: true
iniv = IniV()
```

### Modèle

On définit les équations du modèle en exploitant les fonctions définies plus haut et la structure des paramètres, en renvoyant les dérivées sous forme de `SVector` :

```{julia}
function mod_rma(u::SVector{2}, p::ParRma, t)
    (; c, b, m) = p     # get c, b, m from p
    x = u[1]            # use x, y notations
    y = u[2]

    dx = logistic(x, p) - c * holling2(x,p) * y
    dy = b * holling2(x, p) * y - m * y

    return SVector(dx, dy) # return derivatives as SVector
end
```

### Simulation simple

On définit les paramètres du temps dans un `struct` :
```{julia}
@kwdef struct ParTime
    tspan::Tuple{Float64, Float64} = (0.0, 60.0)
    tstep::Float64 = 0.1
end

# construct a time parameter
p_time = ParTime()
```

On définit une fonction qui définit le problème de simulation, l'intègre et retourne la solution, avec pour arguments positionnels la condition initiale, les paramètres et les paramètres de temps, et comme keyword argument le paramètre booléen `final`.

Lorsque `final = false` (par défaut), la fonction renvoie toute la solution. Lorsque `final  =true` la fonction renvoie la valeur finale de la simulation, ce dont nous nous servirons plus bas dans l'estimation des extremas du cycle limite.
```{julia}
#| output: true
function sim_rma(iniv::IniV, p::ParRma, pt::ParTime; final::Bool = false)
    # deconstruct time parameter
    (; tspan, tstep) = pt
    (; u0) = iniv

    # define and solve simulation problem
    prob_rma = ODEProblem(mod_rma, u0, tspan, p)
    if !final   # if final == false compute whole solution
        sol_rma = solve(prob_rma; reltol = 1e-6, saveat = tstep)
    else        # if final == true compute only final state
        sol_rma = solve(
            prob_rma;
            reltol = 1e-6,
            save_everystep = false,
            save_start = false,
        )
    end

    return sol_rma
end

@time sim_rma(iniv, p_rma, p_time);
```

```{julia}
#| output: true
@time sim_rma(iniv, p_rma2, p_time);
```

Et on définit une fonction qui simule et produit un graphique de la simulation contre le temps, avec pour arguments la condition initiale, les paramètres et les paramètres de temps :
```{julia}
#| eval: true
function plot_rma(initv::IniV, p::ParRma, pt::ParTime)
    # compute the Simulation
    sol_rma = sim_rma(iniv, p, pt)

    # initialize figure
    fig = Figure(; fontsize = 20)
    ax = Axis(fig[1,1];
        title = "Modèle de Rosenzweig MacArthur\n ",
        xlabel = "temps",
        ylabel = "densités",
    )

    # plot solution
    lines!(ax, sol_rma.t, sol_rma[1,:]; lw = 2, label = "proies")
    lines!(ax, sol_rma.t,  sol_rma[2,:]; lw = 2, label = "prédateurs")
    axislegend(; position = :lt)

    return fig
end
```

Finalement on exécute cette fonction pour tracer la simulation :
```{julia}
#| output: true
#| label: fig-rma-time
#| fig-cap: Simulation des trajectoires du modèle de Rosenzweig MacArthur
plot_rma(iniv, p_rma, p_time)
```
::: {.callout-note}
La macro `@time` permet de calculer le temps mis pour calculer la commande qui la suit, ici la simulation et la création du graphique.
:::

### Diagramme de bifurcations

Nous calculons ici le diagramme de bifurcations en fonction de $K\in[0, 8]$.

#### Équilibres

Il n'y a pas besoin de simulation ici puisque les lieux des équilibres sont facilement calculables analytiquement (cf. cette [page](pop_interactions2.qmd)).

Nous définissons une fonction qui prend les paramètres du modèle et renvoit des tuples définissant les différentes branches d'équilibres $(K, y^*$ (avec en `kwarg` un `Kmax` et un `Kstep`).

```{julia}
#| output: false
function eqy_rma(p::ParRma; Kmax::Real = 8.0, Kstep::Real = 0.1)
    (; r, K, c, h, b, m) = p # deconstruct p

    # define bifurcation K values
    Ktrans = m*h/(b-m)
    Khopf = h+2*m*h/(b-m)

    # drops an error if Kmax is too small
    if Kmax < Khopf
        error("For a full computation of equilibria types, Kmax must be greater than $Khopf")
    end

    # y equilibria
    # below transcritical : only y=0
    K_p1 = 0:Kstep:Ktrans
    y_01 = ones(length(K_p1)).*0
    eqs1 = (K_p1, y_01)

    # between transcritical and Hopf : y=0 and y>0
    K_p2 = Ktrans:Kstep:Khopf
    y_02 = ones(length(K_p2)).*0
    y_co2 = [r/c*(h+m*h/(b-m))*(1-m*h/(b-m)/K) for K in K_p2]
    eqs2 = (Kp2, y_02, y_co2)

    # above Hopf : y=0 and y>0
    K_p3 = Khopf:Kstep:Kmax
    y_03 = ones(length(K_p3)).*0
    y_co3 = [r/c*(h+m*h/(b-m))*(1-m*h/(b-m)/K) for K in K_p3]
    eqs3 = (K_p3, y_03, y_co3)

    return eqs1, eqs2, eqs3
end
```


#### Cycle limite

```{julia}
#| output: true
#| eval: true
function cy_rma(iniv::IniV, p::ParRma, pt::ParTime; Kmax::Real = 8.0, Kstep::Real = 0.01)
    # parameters and K range
    (; r, K, c, h, b, m) = p # deconstruct p
    Khopf = h+2*m*h/(b-m)
    K_p3 = Khopf:Kstep:Kmax

    # for storage
    y_cmin = zero(K_p3)
    y_cmax = zero(K_p3)

    # transient integration time
    p_ttrans = ParTime(tspan = (0.0, 8000.0))
    # initial condition
    u0 = SVector(1.0, 1.0)

    for (i, Kb) in enumerate(K_p3)
        # new parameters accounting for K loop
        p_rmabif = ParRma(K = Kb)

        # simulate transient, get final state
        uf = sim_rma(iniv, p_rmabif, p_ttrans; final = true)[:,1]

        # start from end of transient, simulate cycle
        sol_cyc = sim_rma(iniv, p_rmabif, pt)

        # get min and max y along the cycle
        y_cmin[i] = minimum(sol_cyc[2,:])
        y_cmax[i] = maximum(sol_cyc[2,:])
    end

    cycle = (K_p3, y_cmin, y_cmax)
    return cycle
end

@time cy_rma(iniv, p_rma, p_time);
```

```{julia}
#| output: true
#| eval: true
@time cy_rma(iniv, p_rma2, p_time);
```


#### Représentation graphique


### Organisation en fichiers / modules


## Cas des modèles de plus grandes dimensions

Pour les modèles de plus grandes dimensions ($n>8$), l'avantage en performance des static arrays n'est plus si net et la documentation de `DifferentialEquations.jl` recommande d'utiliser la version en place (is in place, IIP dans le jargon du package) de l'interface problem/solver du package.

Il s'agit ici de définir le modèle non pas comme renvoyant la dérivée en fonction de l'état, des paramètres et du temps, mais comme une fonction d'arguments la dérivée, l'état, les paramètres et le temps qui modifie en place la dérivée (et ne renvoie rien)). Celà permet de muter un même objet dérivée `du` à chaque fois que le modèle est appelé, plutôt que de créer un nouvel objet dérivée `du` à chaque appel du modèle (c'est aussi ce qui est fait, différemment, avec les static arrays plus haut).

Typiquement ce type de modèle IIP (en place) s'écrit:

```{julia}
function mod_rma!(du, u, p, t)
    return nothing
end
```

La définition du problème d'intégration et l'appel de solve est similaire aux autres méthodes, à ceci près que la condition initiale et la dérivée doit être mutable, ce qui ne permet pas (ou très difficilement) d'utiliser la méthode en dimension 1. En effet une déclaration `u0 = 1.0` ou `du = 3.0` n'est pas mutable^[alors que `u0 = [1.0, 2.0]` ou `du =[2.0, 3.0]` le sont. Plus sur la mutabilité dans les [Julia notes](https://m3g.github.io/JuliaNotes.jl/stable/immutable/).].
