{
  "hash": "d2fa346f690b44419dce1783b93e3878",
  "result": {
    "markdown": "---\ntitle: \"Simulation optimisée\"\n---\n\n## Modèle de Rosenzweig MacArthur\n\nNous considérons le modèle de dynamique de populations de Rosenzweig et MacArthur que nous avons déjà vu (@Rosenzweig1963, @Turchin2003, @Smith2008).\n\n$$\n\\left\\{\\begin{array}{l}\n\\dot x = \\displaystyle rx\\left(1-\\frac{x}{K}\\right) - c \\frac{x}{h+x} y\\\\[.3cm]\n\\dot y = b\\displaystyle \\frac{x}{h+x} y - m y\n\\end{array}\\right.\n$$ {#eq-rma}\n\nL'objectif est de réaliser des simulations performantes, et le tracé du diagramme de bifurcation avec l'estimation par simulation du cycle limite. Ce type de simulations lourdes se prête bien à se genre de benchmark.\n\n### Stratégie pour le code\n\nPour un tel problème de dimension réduite, nous allons utiliser des static arrays (tableaux à adresse fixe dans la mémoire^[depuis le package `StaticArrays.jl`]), ce qui permettra de ne pas crééer une multitude d'objets pour la simulation mais de toujours modifier le même objet en mémoire.\n\nPar ailleurs nous allons essayer de nous conformer au maximum aux préconisations :\n\n- ne pas utiliser de variables globales\n- définir des fonctions\n- mettre les paramètres dans un nombre limité de variables et les passer en arguments des fonctions\n\nPour ce dernier point, nous allons définir des types (`struct`) spécifiques.\n\nNous commençons par importer les packages que nous allons utiliser:\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nusing StaticArrays\nusing DifferentialEquations\nusing CairoMakie\n```\n:::\n\n\n### Type spécifique pour les paramètres\n\nNous définissons un `struct` pour les paramètres du modèle de Rosenzweig MacArthur.\n\nType pour les paramètres :\n\n::: {.cell execution_count=2}\n``` {.julia .cell-code}\n@kwdef struct ParRma\n    r::Number = 1.0\n    K::Number = 10.0\n    c::Number = 1.0\n    h::Number = 2.0\n    b::Number = 2.0\n    m::Number = 1.0\nend\n```\n:::\n\n\n::: {.callout-note}\nLa macro `@kwdef` permet de renseigner des valeurs par défaut des champs du `struct`.\n:::\n\nOn peut créer des objets de type `ParRma` via les `constructor` ; on accède à un champ particulier via `objet.champ` :\n\n::: {.cell execution_count=3}\n``` {.julia .cell-code}\np_rma = ParRma() # constructor with default values\np_rma2 = ParRma(K=20.0) # default values except K = 20.0\n\n@show p_rma\n@show p_rma.K\n@show p_rma2.K; # semi colon do not show output of par_rma2.K\n```\n\n::: {.cell-output .cell-output-stdout}\n```\np_rma = ParRma(1.0, 10.0, 1.0, 2.0, 2.0, 1.0)\np_rma.K = 10.0\np_rma2.K = 20.0\n```\n:::\n:::\n\n\n::: {.callout-note}\nLa macro `@show` est assez explicite.\n:::\n\n### Fonctions\n\nNous définissons les différentes fonctions impliquées dans le modèle de Rosenzweig MacArthur, la logistique et la réponse fonctionnelle de Holling II.\n\nPour la logistique :\n\n::: {.cell execution_count=4}\n``` {.julia .cell-code}\nfunction logistic(x::Number, p::ParRma)\n    (; r, K) = p    # deconstruct/get r and K from p\n    return r*x*(1-x/K)\nend\n```\n:::\n\n\n::: {.callout-note}\n- les notations `var::Type` permettent de spécifier le type de l'argument\n- la notation `(; r, K) = p` permet d'extraire (*deconstruct*) les champs `r` et `K` du paramètre `p`\n:::\n\nPour la réponse fonctionnelle (sans le paramètre $c$) :\n\n::: {.cell execution_count=5}\n``` {.julia .cell-code}\nfunction holling2(x::Number, p::ParRma)\n    (; h) = p   # deconstruct h from p\n    return x/(x+h)\nend\n```\n:::\n\n\n### Conditions initiales\n\nPour utiliser les static arrays avec `DifferentialEquations.jl` il faut que la condition initiale (donc l'état) et les dérivées soient des static arrays (ici un `SVector`)\n\n::: {.cell execution_count=6}\n``` {.julia .cell-code}\nconst x0 = 1.0\nconst y0 = 1.95\n\n# SVector are immutables\nu0 = SVector(x0, y0)\n```\n\n::: {.cell-output .cell-output-display execution_count=211}\n```\n2-element SVector{2, Float64} with indices SOneTo(2):\n 1.0\n 1.95\n```\n:::\n:::\n\n\n### Modèle\n\nOn définit les équations du modèle en exploitant les fonctions définies plus haut et la structure des paramètres, en renvoyant les dérivées sous forme de `SVector` :\n\n::: {.cell execution_count=7}\n``` {.julia .cell-code}\nfunction mod_rma(u::SVector{2}, p::ParRma, t)\n    (; c, b, m) = p     # get c, b, m from p\n    x = u[1]            # use x, y notations\n    y = u[2]\n\n    dx = logistic(x, p) - c * holling2(x,p) * y\n    dy = b * holling2(x, p) * y - m * y\n\n    return SVector(dx, dy) # return derivatives as SVector\nend\n```\n:::\n\n\n### Simulation\n\nOn définit les paramètres du temps :\n\n::: {.cell execution_count=8}\n``` {.julia .cell-code}\n# tuples are immutable\ntspan = (0.0, 30.0)\n\n# global constant\nconst tstep = 0.1\n```\n:::\n\n\nAinsi que le problème de simulation et on effectue la simulation :\n\n::: {.cell execution_count=9}\n``` {.julia .cell-code}\nprob_rma = ODEProblem(mod_rma, u0, tspan, p_rma; saveat = tstep)\n\nsol_rma = solve(prob_rma, reltol = 1e-6)\n```\n:::\n\n\nLa simulation a bien été effectuée :\n\n::: {.cell execution_count=10}\n``` {.julia .cell-code}\nfig1 = Figure()\nax1 = Axis(fig1[1,1])\nlines!(ax1, sol_rma.t, sol_rma[1,:]; lw = 2)\nlines!(ax1, sol_rma.t, sol_rma[2,:]; lw = 2)\n\nfig1\n```\n\n::: {.cell-output .cell-output-display execution_count=215}\n![](annexe_swft_rma_files/figure-html/cell-11-output-1.svg){}\n:::\n:::\n\n\n## Cas des modèles de plus grandes dimensions\n\nPour les modèles de plus grandes dimensions ($n>8$), l'avantage en performance des static arrays n'est plus si net et la documentation de `DifferentialEquations.jl` recommande d'utiliser la version en place (is in place, IIP dans le jargon du package) de l'interface problem/solver du package.\n\nIl s'agit ici de définir le modèle non pas comme renvoyant la dérivée en fonction de l'état, des paramètres et du temps, mais comme une fonction d'arguments la dérivée, l'état, les paramètres et le temps qui modifie en place la dérivée (et ne renvoie rien)). Celà permet de muter un même objet dérivée `du` à chaque fois que le modèle est appelé, plutôt que de créer un nouvel objet dérivée `du` à chaque appel du modèle (c'est aussi ce qui est fait, différemment, avec les static arrays plus haut).\n\nTypiquement ce type de modèle IIP (en place) s'écrit:\n\n::: {.cell execution_count=11}\n``` {.julia .cell-code}\nfunction mod_rma!(du, u, p, t)\n    return nothing\nend\n```\n:::\n\n\nLa définition du problème d'intégration et l'appel de solve est similaire aux autres méthodes, à ceci près que la condition initiale et la dérivée doit être mutable, ce qui ne permet pas (ou très difficilement) d'utiliser la méthode en dimension 1. En effet une déclaration `u0 = 1.0` ou `du = 3.0` n'est pas mutable^[alors que `u0 = [1.0, 2.0]` ou `du =[2.0, 3.0]` le sont. Plus sur la mutabilité dans les [Julia notes](https://m3g.github.io/JuliaNotes.jl/stable/immutable/).].\n\n",
    "supporting": [
      "annexe_swft_rma_files"
    ],
    "filters": [],
    "includes": {}
  }
}