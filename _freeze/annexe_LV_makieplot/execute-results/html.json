{
  "hash": "5cc062c4ae907fc82682de0d768a7a2d",
  "result": {
    "markdown": "---\ntitle: \"Lotka Volterra avec `Makie.jl`\"\n---\n\n\\\n\nL'objectif ici est de faire une jolie représentation graphique du modèle de Lotka Volterra avec la librairie graphique `Makie.jl`.\n\nOn reprend une partie du code de la page sur les [populations en intéractions](pop_interactions.qmd).\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code code-fold=\"true\"}\nusing DifferentialEquations\n\n# conditions initiales\nx0 = 1.0\ny0 = 2.3\netat0 = [x0, y0]\n\n# paramètres\nr = 1.0\nc = 1.0\nb = 1.0\nm = 1.0\npar_lovo = [r, c, b, m]\n\n# integration plus longue\ntspan = (0.0, 30.0)\ntstep = .01\n\n# définition du modèle\nfunction lovo(u, par, t)\n    r, c, b, m = par\n    x = u[1]\n    y = u[2]\n    dx = r*x - c*x*y\n    dy = b*x*y - m*y\n    [dx, dy]\nend\n\n# problème\nprob_lovo = ODEProblem(lovo, etat0, tspan, par_lovo, saveat = tstep)\n# intégration\nsol_lovo = solve(prob_lovo, reltol = 1e-6)\n```\n:::\n\n\nL'objectif est de créer une figure avec trois panels. dans la colonne de gauche, le premier panel représentera la dynamique temporelle, le second le plan de phase, et dans la colonne de droite nous représenterons la figure 3D avec l'intégrale première.\n\n::: {.cell execution_count=2}\n``` {.julia .cell-code}\nusing CairoMakie\n\n# on crée la figure avec un fond gris clair\nfig = Figure(backgroundcolor = RGBf(0.98, 0.98, 0.98),\n              resolution = (1000, 700)) \n\n# déclare les différents panels comme des éléments gridlayout contenant les plots\npanela = fig[1, 1] = GridLayout()\npanelb = fig[2, 1] = GridLayout()\npanelc = fig[:, 2] = GridLayout()\n```\n:::\n\n\n::: {.cell execution_count=3}\n``` {.julia .cell-code}\nax1 = Axis(panela[1,1],\n           xlabel = L\"temps$$\",\n           ylabel = L\"densités de populations$$\",\n           title=\"Dynamiques\")\n\nlines!(ax1, sol_lovo.t, sol_lovo[1,:],\n       linewidth = 2,\n       label = L\"$x(t)$\")\nlines!(ax1, sol_lovo.t, sol_lovo[2,:],\n       linewidth = 2,\n       label = L\"$y(t)$\")\n\naxislegend(ax1, position = :lt, labelsize = 12)\n\nfig\n```\n\n::: {.cell-output .cell-output-display execution_count=164}\n![](annexe_LV_makieplot_files/figure-html/cell-4-output-1.svg){}\n:::\n:::\n\n\n::: {.cell execution_count=4}\n``` {.julia .cell-code}\nax2 = Axis(panelb[1,1],\n           xlabel = L\"population $x$\",\n           ylabel = L\"population $y$\",\n           title = \"Plan de phase\",\n           xticks = (0:.5:2),\n           yticks = (0:.5:2))\n\n# champs de vecteur\nscale = 10\nxrange = range(0, 2.35, length=11)  \nyrange = range(0, 2.35, length=11)\n\nderx = [lovo([x y], par_lovo, 0)[1]/scale for x in xrange, y in yrange]\ndery = [lovo([x y], par_lovo, 0)[2]/scale for x in xrange, y in yrange]\n\narrows!(ax2, xrange, yrange, derx, dery, \n        color = :lightgray, \n        arrowsize = 10)\n\n# nullclines\nlines!(ax2, xrange, [r/c for x in xrange],\n       color = Cycled(2),\n       linewidth = 2,\n       label = L\"$\\dot{x}$ nullcline\")\nlines!(ax2, [0 for y in yrange], yrange,\n       linewidth = 2,\n       color = Cycled(2))\nlines!(ax2, [m/b for y in yrange], yrange,\n       color = Cycled(3),\n       linewidth = 2,\n       label = L\"$\\dot{y}$ nullcline\")\nlines!(ax2, xrange, [0 for y in yrange],\n       color = Cycled(3),\n       linewidth = 2)\n\n# équilibres\nscatter!(ax2, Point2f(0,0),\n         color = Cycled(4))\nscatter!(ax2, Point2f(m/b, r/c),\n         color = Cycled(4))\n\n# trajectoire\nlines!(ax2, sol_lovo[1, :], sol_lovo[2, :],\n       color = Cycled(1),\n       linewidth = 2)\n\nxlims!(ax2, -0.1, 2.35)\nylims!(ax2, -0.1, 2.35)\naxislegend(ax2, position = :rt, labelsize = 12)\n\nfig\n```\n\n::: {.cell-output .cell-output-display execution_count=165}\n![](annexe_LV_makieplot_files/figure-html/cell-5-output-1.svg){}\n:::\n:::\n\n\n::: {.cell execution_count=5}\n``` {.julia .cell-code}\n# l'intégrale première\nfunction int_prem(x, y, par = par_lovo)\n      r, c, b, m = par\n      -r*log(y) + c*y - m*log(x) + b*x\nend\n```\n:::\n\n\n::: {.cell execution_count=6}\n``` {.julia .cell-code}\nax3 = Axis3(panelc[1, 1], \n            title = \"Intégrale première\",\n            xlabel = L\"population $x$\",\n            ylabel = L\"population $y$\",\n            zlabel = L\"$H(x,y)$\",\n            azimuth = 0.5,\n            elevation = 0.2)\n\n# grille x, y\nxsurf = .2: .1: 3\nysurf = .2:.1: 3\n\n# calcul de la surface via une compréhension de liste\nhsurf = [int_prem(x, y, par_lovo) for x in xsurf, y in ysurf]\nhplane = [int_prem(x0, y0, par_lovo) for x in xsurf, y in ysurf]\n\nhs = surface!(ax3, xsurf, ysurf, hsurf, alpha=.5)\nsurface!(ax3, xsurf, ysurf, hplane, color = fill(:red,100,100), alpha = .3)\n\nlines!(ax3, sol_lovo[1,:], sol_lovo[2,:], \n       [int_prem(x0, y0) for x in sol_lovo[1,:]],\n       color = Cycled(4),\n       linewidth = 3)\n\nColorbar(panelc[1, 2], hs, label = L\"$H(x,y)$\")\n\n\n\nfig\n```\n\n::: {.cell-output .cell-output-display execution_count=167}\n![](annexe_LV_makieplot_files/figure-html/cell-7-output-1.svg){}\n:::\n:::\n\n\n",
    "supporting": [
      "annexe_LV_makieplot_files"
    ],
    "filters": [],
    "includes": {}
  }
}