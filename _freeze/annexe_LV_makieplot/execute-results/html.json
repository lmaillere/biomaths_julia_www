{
  "hash": "3b5d94ec460ac0ce48486fcc03f4f9bc",
  "result": {
    "markdown": "---\ntitle: \"Lotka Volterra avec `Makie.jl`\"\n---\n\n\\\n\nL'objectif ici est de faire une jolie représentation graphique du modèle de Lotka Volterra avec la librairie graphique `Makie.jl`.\n\nOn reprend une partie du code de la page sur les [populations en intéractions](pop_interactions.qmd).\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code code-fold=\"true\"}\nusing DifferentialEquations\n\n# conditions initiales\nx0 = 1.0\ny0 = 1.95\netat0 = [x0, y0]\n\n# paramètres\nr = 1.0\nc = 1.0\nb = 1.0\nm = 1.0\npar_lovo = [r, c, b, m]\n\n# integration plus longue\ntspan = (0.0, 30.0)\ntstep = .01\n\n# définition du modèle\nfunction lovo(u, par, t)\n    r, c, b, m = par\n    x = u[1]\n    y = u[2]\n    dx = r*x - c*x*y\n    dy = b*x*y - m*y\n    [dx, dy]\nend\n\n# problème\nprob_lovo = ODEProblem(lovo, etat0, tspan, par_lovo, saveat = tstep)\n# intégration\nsol_lovo = solve(prob_lovo, reltol = 1e-6)\nsol_lovo[1,:]\n```\n\n::: {.cell-output .cell-output-display execution_count=65}\n```\n3001-element Vector{Float64}:\n 1.0\n 0.9905452875414233\n 0.9811817740609885\n 0.9719103370837534\n 0.962731777808045\n 0.9536468229270878\n 0.9446561264865978\n 0.9357602717733164\n 0.9269597732293241\n 0.9182550783849169\n 0.9096465698172779\n 0.9011345671038459\n 0.8927193287932835\n ⋮\n 0.8682662215531705\n 0.8732231912592429\n 0.8782132528861987\n 0.8832364546892432\n 0.888292841827793\n 0.8933824562653292\n 0.8985053366671637\n 0.9036615182961335\n 0.9088510329061205\n 0.9140739086334049\n 0.9193301698858709\n 0.9246198372298333\n```\n:::\n:::\n\n\nL'objectif est de créer une figure avec trois panels. dans la colonne de gauche, le premier panel représentera la dynamique temporelle, le second le plan de phase, et dans la colonne de droite nous représenterons la figure 3D avec l'intégrale première.\n\n::: {.cell execution_count=2}\n``` {.julia .cell-code}\nusing CairoMakie\n\n# on crée la figure avec un fond gris clair\nfig = Figure(backgroundcolor = RGBf(0.98, 0.98, 0.98),\n              resolution = (1000, 700)) \n\n# déclare les différents panels comme des éléments gridlayout contenant les plots\npanela = fig[1, 1] = GridLayout()\npanelb = fig[2, 1] = GridLayout()\npanelc = fig[:, 2] = GridLayout()\n```\n\n::: {.cell-output .cell-output-display execution_count=66}\n```\nGridLayout[1:1, 1:1] with 0 children\n```\n:::\n:::\n\n\n::: {.cell execution_count=3}\n``` {.julia .cell-code}\nax1 = Axis(panela[1,1],\n           xlabel = L\"temps$$\",\n           ylabel = L\"densités de populations$$\",\n           title=\"Dynamiques\")\n\nlines!(ax1, sol_lovo.t, sol_lovo[1,:],\n       linewidth = 2,\n       label = L\"$x(t)$\")\nlines!(ax1, sol_lovo.t, sol_lovo[2,:],\n       linewidth = 2,\n       label = L\"$y(t)$\")\n\nfig\n```\n\n::: {.cell-output .cell-output-display execution_count=67}\n![](annexe_LV_makieplot_files/figure-html/cell-4-output-1.svg){}\n:::\n:::\n\n\n::: {.cell execution_count=4}\n``` {.julia .cell-code}\nax2 = Axis(panelb[1,1],\n           xlabel = L\"population $x$\",\n           ylabel = L\"population $y$\",\n           title = \"Plan de phase\",\n           xticks = (0:.5:2),\n           yticks = (0:.5:2))\n\n# champs de vecteur\nscale = 10\nxrange = range(.1, 2.25, length=11)  \nyrange = range(.1, 2.25, length=11)\n\nderx = [lovo([x y], par_lovo, 0)[1]/scale for x in xrange, y in yrange]\ndery = [lovo([x y], par_lovo, 0)[2]/scale for x in xrange, y in yrange]\n\narrows!(ax2, xrange, yrange, derx, dery, \n        color = :lightgray, \n        arrowsize = 10, \n        label = L\"vector field$$\")\n\n# nullclines\n\n# trajectoire\nlines!(ax2, sol_lovo[1, :], \n       sol_lovo[2, :],\n       label = \"trajectoire\")\n\nxlims!(ax2, 0, 2.25)\nylims!(ax2, 0, 2.25)\n\nfig\n```\n\n::: {.cell-output .cell-output-display execution_count=68}\n![](annexe_LV_makieplot_files/figure-html/cell-5-output-1.svg){}\n:::\n:::\n\n\n",
    "supporting": [
      "annexe_LV_makieplot_files"
    ],
    "filters": [],
    "includes": {}
  }
}