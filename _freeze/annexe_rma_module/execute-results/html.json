{
  "hash": "ef995f414a81f15b02cd2b43e67803e4",
  "result": {
    "markdown": "---\ntitle: \"Mon premier module\"\n---\n\n## Module `RmaMod.jl`\n\nNous exploitons le code produit pour simuler de façon efficace le modèle de Rosenzweig MacArthur (cf. cette [page](annexe_swift_rma.qmd)) pour générer un module (essentiellement un ensemble d'objets et de fonctions qui peuvent être utilisés par d'autres programmes).\n\nUne fois le code entièrement sous forme de `struct` et de `function`, la création du module est très simple. On place le module dans un fichier `RmaMod.jl` avec l'architecture suivante :\n\n::: {.cell execution_count=2}\n``` {.julia .cell-code}\n# ce code n'est pas exécuté dans cette cellule pour ne pas interférer\n# avec le module que nous importons après\n\"\"\"\nsome help regarding the module...\n\"\"\"\nmodule RmaMod\n\n# import required packages, e.g.\nusing StaticArrays\n\n# export what you want other programs to know when importing through `using`\nexport IniV, logistic\n\n# put structs help and definition, e.g.:\n\"\"\"\nsome help for IniV struct\n\"\"\"\n@kwdef struct IniV\n    x0::Float64 = 1.0\n    y0::Float64 = 1.95\n    u0::SVector{2, Float64} = SVector(x0, y0)\nend\n\n# put functions help and definition, e.g.:\n\"\"\"\nsome help for logistic function\n\"\"\"\nfunction logistic(x::Real, p::ParRma)\n    (; r, K) = p    # deconstruct/get r and K from p\n    return r*x*(1-x/K)\nend\n\nend\n```\n:::\n\n\nLe *vrai* fichier `RmaMod.jl` définissant le module `RmaMod` est disponible [ici](src/RmaMod.jl).\n\n## Utilisation du module\n\nPour utiliser le module contenu dans le fichier `RmaMod.jl`, nous incluons ce fichier (il est dans le répertoire `./src/` ici) et l'importons avec `using` :\n\n::: {.cell execution_count=3}\n``` {.julia .cell-code}\ninclude(\"./src/RmaMod.jl\")\nusing .RmaMod\n```\n:::\n\n\nLe module exporte:\n\n- les `structs` : `IniV` (conditions initiales), `ParRma` (paramètres du modèle), `ParTime` (paramètres de temps),\n- les fonctions : `plot_rma()` et `plot_bif_rma()`,\n\ncomme nous le confirme l'aide du module.\n\n::: {.cell execution_count=4}\n``` {.julia .cell-code}\n?RmaMod\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nsearch: RmaMod\n\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=52}\nThe module `RmaMod` provides `structs` and `functions` to simulate and plot the dynamics and bifurcation diagram of the Rosenzweig MacArthur model.\n\nExported structs are:\n\n  * `Iniv` initial condition objects\n  * `ParRma` model parameters objects\n  * `ParTime` time parameters objects\n\nExported functions are:\n\n  * `plot_rma()` to simulate and plot the RMA dynamics against time\n  * `plot_bif_rma()` to simulate and plot the RMA bifurcation diagram against K\n\n---\n\nThe module `RmaMod` provides `structs` and `functions` to simulate and plot the dynamics and bifurcation diagram of the Rosenzweig MacArthur model.\n\nExported structs are:\n\n  * `Iniv` initial condition objects\n  * `ParRma` model parameters objects\n  * `ParTime` time parameters objects\n\nExported functions are:\n\n  * `plot_rma()` to simulate and plot the RMA dynamics against time\n  * `plot_bif_rma()` to simulate and plot the RMA bifurcation diagram against K\n\n---\n\nThe module `RmaMod` provides `structs` and `functions` to simulate and plot the dynamics and bifurcation diagram of the Rosenzweig MacArthur model.\n\nExported structs are:\n\n  * `Iniv` initial condition objects\n  * `ParRma` model parameters objects\n  * `ParTime` time parameters objects\n\nExported functions are:\n\n  * `plot_rma()` to simulate and plot the RMA dynamics against time\n  * `plot_bif_rma()` to simulate and plot the RMA bifurcation diagram against K\n\n---\n\nThe module `RmaMod` provides `structs` and `functions` to simulate and plot the dynamics and bifurcation diagram of the Rosenzweig MacArthur model.\n\nExported structs are:\n\n  * `Iniv` initial condition objects\n  * `ParRma` model parameters objects\n  * `ParTime` time parameters objects\n\nExported functions are:\n\n  * `plot_rma()` to simulate and plot the RMA dynamics against time\n  * `plot_bif_rma()` to simulate and plot the RMA bifurcation diagram against K\n\n---\n\nThe module `RmaMod` provides `structs` and `functions` to simulate and plot the dynamics and bifurcation diagram of the Rosenzweig MacArthur model.\n\nExported structs are:\n\n  * `Iniv` initial condition objects\n  * `ParRma` model parameters objects\n  * `ParTime` time parameters objects\n\nExported functions are:\n\n  * `plot_rma()` to simulate and plot the RMA dynamics against time\n  * `plot_bif_rma()` to simulate and plot the RMA bifurcation diagram against K\n\n---\n\nThe module `RmaMod` provides `structs` and `functions` to simulate and plot the dynamics and bifurcation diagram of the Rosenzweig MacArthur model.\n\nExported structs are:\n\n  * `Iniv` initial condition objects\n  * `ParRma` model parameters objects\n  * `ParTime` time parameters objects\n\nExported functions are:\n\n  * `plot_rma()` to simulate and plot the RMA dynamics against time\n  * `plot_bif_rma()` to simulate and plot the RMA bifurcation diagram against K\n\n---\n\nThe module `RmaMod` provides `structs` and `functions` to simulate and plot the dynamics and bifurcation diagram of the Rosenzweig MacArthur model.\n\nExported structs are:\n\n  * `Iniv` initial condition objects\n  * `ParRma` model parameters objects\n  * `ParTime` time parameters objects\n\nExported functions are:\n\n  * `plot_rma()` to simulate and plot the RMA dynamics against time\n  * `plot_bif_rma()` to simulate and plot the RMA bifurcation diagram against K\n\n---\n\nThe module `RmaMod` provides `structs` and `functions` to simulate and plot the dynamics and bifurcation diagram of the Rosenzweig MacArthur model.\n\nExported structs are:\n\n  * `Iniv` initial condition objects\n  * `ParRma` model parameters objects\n  * `ParTime` time parameters objects\n\nExported functions are:\n\n  * `plot_rma()` to simulate and plot the RMA dynamics against time\n  * `plot_bif_rma()` to simulate and plot the RMA bifurcation diagram against K\n\n:::\n:::\n\n\nOn peut obtenir de l'aide sur ces fonctions (si le module a bien rempli ses docstrings):\n\n::: {.cell execution_count=5}\n``` {.julia .cell-code}\n?plot_rma    # normalement seul ?plot_rma fonctionne\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nsearch: plot_rma plot_bif_rma\n\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=53}\n```\nplot_rma(iniv, p, pt)\n```\n\nsimulates and plots predator `x` and prey `y` density dynamics against time, given model parameters `p` and time parameters `pt`. returns a `CairoMakie` figure object.\n\narguments:\n\n  * `iniv` is an `IniV` initial value object (defined in this module)\n  * `p` is a `ParRma` parameter object (defined in this module)\n  * `pt` is a `ParTime` time parameter object (defined in this module)\n\n:::\n:::\n\n\n## Simulation des dynamiques\n\nNous pouvons simuler les dynamiques du modèle en appelant les constructeurs par défaut des objets à la volée :\n\n::: {.cell execution_count=6}\n``` {.julia .cell-code}\nplot_rma(IniV(), ParRma(), ParTime())\n```\n\n::: {.cell-output .cell-output-display execution_count=54}\n![](annexe_rma_module_files/figure-html/cell-6-output-1.svg){}\n:::\n:::\n\n\nMais aussi en spécifiant certains objets, comme e.g. les paramètres :\n\n::: {.cell execution_count=7}\n``` {.julia .cell-code}\nplot_rma(IniV(), ParRma(K = 5.0), ParTime())\n```\n\n::: {.cell-output .cell-output-display execution_count=55}\n![](annexe_rma_module_files/figure-html/cell-7-output-1.svg){}\n:::\n:::\n\n\n## Diagramme de bifurcations\n\nDe la même manière, on peut générer un diagramme de bifurcations :\n\n::: {.cell execution_count=8}\n``` {.julia .cell-code}\nplot_bif_rma(ParRma())\n```\n\n::: {.cell-output .cell-output-display execution_count=56}\n![](annexe_rma_module_files/figure-html/cell-8-output-1.svg){}\n:::\n:::\n\n\n",
    "supporting": [
      "annexe_rma_module_files"
    ],
    "filters": [],
    "includes": {}
  }
}