{
  "hash": "70185b79f8b1ec755f030324b3c38be0",
  "result": {
    "markdown": "---\ntitle: \"Graphiques animés avec `Makie.jl`\"\n---\n\n\\\n\nNous reprenons le modèle de Lotka Volterra, et testons les capacités de création de graphiques animés avec `Makie.jl`^[Il est aussi possible de créér sur le même modèle des [graphiques interactifs](https://gist.github.com/Datseris/4b9d25a3ddb3936d3b83d3037f8188dd)]. Ce document est largement inspiré par l'excellent [tutoriel](https://www.youtube.com/watch?v=L-gyDvhjzGQ) sur le double pendule chaotique par G. Datseris. \n\n## Trajectoire animée en 2D\n\n### Observables\n\nLe principe tire partie des conteneurs `Observable`, qui sont des conteneurs mutables que l'on peut donc modifier et dont on peut surveiller l'action de modification. Lorsqu'un `Observable` passé à `Makie.jl` est modifié, ce dernier le prend en compte et met à jour le graphique correspondant automatiquement. Cela fonctionne particulièrement bien avec le backend `GL`, qui depuis un script ou un notebook ouvre une fenetre graphique qui se met à jour automatiquement. Sur cette page, il nous faut réafficher la figure.\n\nPrenons un exemple, sur une simple figure, on définit un `Observable` random puis on le trace:\n\n::: {.cell execution_count=2}\n``` {.julia .cell-code}\nusing GLMakie\n\nx = 1:4\ny = Observable(rand(4))\nfig, ax = lines(x, y) \n```\n\n::: {.cell-output .cell-output-display execution_count=92}\n![](annexe_LV_anim_files/figure-html/cell-2-output-1.svg){}\n:::\n:::\n\n\nEnsuite on réassigne la valeur de l'observable^[notez la syntaxe `y[]=` qui assigne le contenu de l'observable et informe le système de la mise à jour de l'observable] et on réaffiche la figure qui s'est mise à jour automatiquement, sans retracer la `line`.\n\n::: {.cell execution_count=3}\n``` {.julia .cell-code}\ny[] = rand(4)\nfig\n```\n\n::: {.cell-output .cell-output-display execution_count=93}\n![](annexe_LV_anim_files/figure-html/cell-3-output-1.svg){}\n:::\n:::\n\n\nIl s'agit d'exploiter ce principe pour créér un graphique animé.\n\n### Trajectoire de Lotka Volterra\n\nNous allons représenter la trajectoire au cours du temps comme un point mobile dans l'espace d'état, avec une \"queue\" qui représente les valeurs de l'état dans le passé proche.\n\nOn commence par définir les fonctions et paramètres pour simuler le modèle et créer un problème ODE `prob_lv`.\n\n::: {.cell execution_count=4}\n``` {.julia .cell-code code-fold=\"true\"}\nusing DifferentialEquations\n\n# conditions initiales\nx0 = 1.0\ny0 = 1.95\netat0 = [x0, y0]\n\n# paramètres\nr = 1.0\nc = 1.0\nb = 1.0\nm = 1.0\npar_lovo = [r, c, b, m]\n\n# temps\ntspan = (0.0, 30.0)\ntstep = .01\n\n# définition du modèle\nfunction lovo(u, par, t)\n    r, c, b, m = par\n    x, y = u\n    dx = r*x - c*x*y\n    dy = b*x*y - m*y\n    [dx, dy]\nend\n\n# define ODE problem\nprob_lv = ODEProblem(lovo, etat0, tspan, par_lovo)\n```\n:::\n\n\nNous créons des observables pour l'état et pour la \"queue\" de simulation sous la forme d'objets de type `Point2f`^[il s'agirait de la meilleure structure pour tracer des points en 2D pour Makie] (ou `CircularBuffer`^[vecteur de taille fixe qu'on remplit/vide avec `push!()`] de `Point2f`) pour les passer à Makie.\n\n::: {.cell execution_count=5}\n``` {.julia .cell-code}\n# observable pour l'état\nx, y = etat0            \nstate_lv = Observable(Point2f(x, y))     # initialisation\n\n# observable pour la queue\nusing DataStructures: CircularBuffer\n\ntailsize = 600\ntail = CircularBuffer{Point2f}(tailsize)    # une queue de simulation \nfill!(tail, Point2f(x, y))      # que l'on initialize sur la condition initiale\ntail = Observable(tail)         # et que l'on transforme en Observable\n```\n:::\n\n\nL'animation repose sur une simulation de proche en proche, pour cela nous utilisons l'interface `integrator` de `DifferentialEquations.jl` et la fonction `step!(integrator)` qui calcule la solution au bout d'un pas de temps. Nous créons une fonction qui effectue ce calcul et met à jour les Observables état et queue (en place !).\n\n::: {.cell execution_count=6}\n``` {.julia .cell-code}\nintegrator_lv = init(prob_lv)    # interface integrator\n\nfunction step_lv!(integrator, state_lv, tail)\n    step!(integrator, 0.01,  true)   # calcule la solution a t+0.01, en place\n    x, y = integrator.u              # assigne la solution à x et y\n    state_lv[] = Point2f(x, y)        # met à jour l'Observable\n    push!(tail[], Point2f(x,y))      # assigne la nouvelle valeur dans la queue, en place\n    tail[] = tail[]                  # l'opération en place n'indique pas la mise à jour de l'Observable\nend\n```\n:::\n\n\nIl faut maintenant définir la figure en elle-même:\n\n::: {.cell execution_count=7}\n``` {.julia .cell-code}\nfig = Figure()\nax = Axis(fig[1, 1], xticks = 0:.5:2, yticks = 0:.5:2)\n\n# champs de vecteur\nscale = 10\nxrange = range(0, 2.75, length=11)  \nyrange = range(0, 2.75, length=11)\n\nderx = [lovo([x y], par_lovo, 0)[1]/scale for x in xrange, y in yrange]\ndery = [lovo([x y], par_lovo, 0)[2]/scale for x in xrange, y in yrange]\n\narrows!(ax, xrange, yrange, derx, dery, \n        color = :lightgray, \n        arrowsize = 10)\n\n# plot of the state\nscatter!(ax, state_lv, \n         marker = :circle, \n         strokewidth = 2, \n         strokecolor = :purple,\n         color = :black,\n         markersize = 8)\n# equilibrium\nscatter!(ax, m/b, r/c, marker = :star, color = :grey, markersize = 14)\n# plot of the tail\ncol = to_color(:purple)\ntailcol = [RGBAf(col.r, col.g, col.b, (i/tailsize)^2) for i in 1:tailsize]\nlines!(ax, tail, linewidth = 3, color = tailcol)\n\n# enluminures\nax.title = \"Lotka Volterra\"\nax.xlabel = \"Proies\"\nax.ylabel = \"Prédateurs\"\nxlims!(ax, 0, 2.25)\nylims!(ax, 0, 2.25)\n\nfig\n```\n\n::: {.cell-output .cell-output-display execution_count=97}\n![](annexe_LV_anim_files/figure-html/cell-7-output-1.svg){}\n:::\n:::\n\n\n::: {.cell execution_count=8}\n``` {.julia .cell-code}\n# test the 2D plot \nfor in in 1:1000\n    step_lv!(integrator_lv, state_lv, tail)\n    sleep(.001)\nend\n```\n:::\n\n\nDepuis un script ou un notebook, la figure proposée par `GLMakie` devrait s'animer. Ici nous ne pouvons qu'afficher la dernière simulation :\n\n::: {.cell execution_count=9}\n``` {.julia .cell-code}\nfig\n```\n\n::: {.cell-output .cell-output-display execution_count=99}\n![](annexe_LV_anim_files/figure-html/cell-9-output-1.svg){}\n:::\n:::\n\n\n### Image animée pour site\n\nIl faut générer une image animée pour pouvoir visualiser l'animation sur cette page html.  \n\nOn peut commencer par réunir tout le code d'initialisation et de génération de figure dans une fonction, pour facilement réinitialiser:\n\n::: {.cell execution_count=10}\n``` {.julia .cell-code code-fold=\"true\"}\nfunction init_anim_lv(etat0)\n    # Odeproblem, integrator\n    prob_lv = ODEProblem(lovo, etat0, tspan, par_lovo)\n    integrator_lv = init(prob_lv)\n\n    x, y = etat0            \n    state_lv = Observable(Point2f(x, y))\n    tailsize = 600\n    tail = CircularBuffer{Point2f}(tailsize)\n    fill!(tail, Point2f(x, y))\n    tail = Observable(tail)\n\n    fig = Figure()\n    ax = Axis(fig[1, 1], xticks = 0:.5:2, yticks = 0:.5:2)\n    scale = 10\n\n    xrange = range(0, 2.75, length=11)  \n    yrange = range(0, 2.75, length=11)\n    derx = [lovo([x y], par_lovo, 0)[1]/scale for x in xrange, y in yrange]\n    dery = [lovo([x y], par_lovo, 0)[2]/scale for x in xrange, y in yrange]\n    arrows!(ax, xrange, yrange, derx, dery, \n            color = :lightgray, \n            arrowsize = 10)\n\n    scatter!(ax, state_lv, \n            marker = :circle, \n            strokewidth = 2, \n            strokecolor = :purple,\n            color = :black,\n            markersize = 8)\n    r, c, b, m = par_lovo\n    scatter!(ax, m/b, r/c, marker = :star, color = :grey, markersize = 14)\n\n    col = to_color(:purple)\n    tailcol = [RGBAf(col.r, col.g, col.b, (i/tailsize)^2) for i in 1:tailsize]\n    lines!(ax, tail, linewidth = 3, color = tailcol)\n\n    ax.title = \"Lotka Volterra\"\n    ax.xlabel = \"Proies\"\n    ax.ylabel = \"Prédateurs\"\n    xlims!(ax, 0, 2.25)\n    ylims!(ax, 0, 2.25)\n\n    return fig, integrator_lv, state_lv, tail\nend\n```\n:::\n\n\nNous générons la figure animée sous forme d'un gif.\n\n::: {.cell execution_count=11}\n``` {.julia .cell-code}\nfig, integrator_lv, state_lv, tail = init_anim_lv(etat0)\n\nframes = 1:132\nrecord(fig, \"lv.gif\", frames; framerate = 60) do i\n    for j in 1:5\n        step_lv!(integrator_lv, state_lv, tail)\n    end\nend\n```\n:::\n\n\nEt finalement nous pouvons afficher la figure animée:\n![](lv.gif)\n\n\n## Trajectoire animée en 3D\n\nAu prix d'une modification très minime du code ci-dessus, on peut facilement créér une animation de la trajectoire en 3 dimensions $(x, y, H(x,y))$. Il faut essentiellement remplacer le système d'axe 2D par un système d'axe 3D `Axis3` et les objets `Point2f` par des `Point3f`.\n\n::: {.cell execution_count=12}\n``` {.julia .cell-code code-fold=\"show\"}\n# on définit l'intégrale première\nfunction int_prem(x, y, par = par_lovo)\n    r, c, b, m = par\n    H = -r*log(y) + c*y - m*log(x) + b*x\n    return H\nend\n\nfunction init_anim3d_lv(etat0)\n    # Odeproblem, integrator\n    prob_lv = ODEProblem(lovo, etat0, tspan, par_lovo)\n    integrator_lv = init(prob_lv)\n\n    x, y = etat0 \n    H0 = int_prem(x, y)\n    state3d_lv = Observable(Point3f(x, y, H0))\n    tailsize = 1000\n    tail3 = CircularBuffer{Point3f}(tailsize)\n    fill!(tail3, Point3f(x, y, H0))\n    tail3 = Observable(tail3)\n\n    fig = Figure()\n    ax = Axis3(fig[1, 1], azimuth = 0.5, elevation = 0.2, xticks = 0:.5:2, yticks = 0:.5:2)\n\n    scatter!(ax, state3d_lv, \n            marker = :circle, \n            strokewidth = 2, \n            strokecolor = :purple,\n            color = :black,\n            markersize = 8)\n    \n    col = to_color(:purple)\n    tailcol = [RGBAf(col.r, col.g, col.b, (i/tailsize)^2) for i in 1:tailsize]\n    lines!(ax, tail3, linewidth = 3, color = tailcol)\n\n    xsurf = .25: .1: 2.25\n    ysurf = .25:.1: 2.25\n    # calcul de la surface via une compréhension de liste\n    hsurf = [int_prem(x, y, par_lovo) for x in xsurf, y in ysurf]\n    # tracé de H(x,y) et du plan z = H(x0,y0)\n    hs = surface!(ax, xsurf, ysurf, hsurf, alpha=.2)\n\n    ax.title = \"Lotka Volterra\"\n    ax.xlabel = \"Proies\"\n    ax.ylabel = \"Prédateurs\"\n    ax.zlabel = L\"$H(x,y)$\"\n    xlims!(ax, 0, 2.25)\n    ylims!(ax, 0, 2.25)\n    zlims!(ax, 1.7, 3.5)\n\n    return fig, integrator_lv, state3d_lv, tail3\nend\n```\n:::\n\n\nOn adapte la fonction d'animation qui avance d'un pas de temps à la nouvelle structure des observables en 3D.\n\n::: {.cell execution_count=13}\n``` {.julia .cell-code}\nfunction animsteplv3!(integrator_lv, state3d_lv, tail3)\n    step!(integrator_lv, 0.01,  true)\n    x, y = integrator_lv.u\n    state3d_lv[] = Point3f(x, y, state3d_lv[][3])\n    push!(tail3[], Point3f(x, y, state3d_lv[][3]))\n    tail3[] = tail3[]\nend\n```\n:::\n\n\nEt on génère une figure gif pour afficher sur cette page.\n\n::: {.cell execution_count=14}\n``` {.julia .cell-code}\nfig, integrator_lv, state3d_lv, tail3 = init_anim3d_lv(etat0)\n\nframes = 1:132\nrecord(fig, \"lv3d.gif\", frames; framerate = 60) do i\n    for j in 1:5\n        animsteplv3!(integrator_lv, state3d_lv, tail3)\n    end\nend\n```\n:::\n\n\nFinalement:\n\n![](lv3d.gif)\n\n",
    "supporting": [
      "annexe_LV_anim_files"
    ],
    "filters": [],
    "includes": {}
  }
}