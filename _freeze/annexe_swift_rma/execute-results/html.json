{
  "hash": "b0a5c4e01b2e8a11410d177973232608",
  "result": {
    "markdown": "---\ntitle: \"Simulation am√©lior√©e\"\n---\n\n## Mod√®le de Rosenzweig MacArthur\n\nNous consid√©rons le mod√®le de dynamique de populations de Rosenzweig et MacArthur que nous avons d√©j√† vu (@Rosenzweig1963, @Turchin2003, @Smith2008).\n\n$$\n\\left\\{\\begin{array}{l}\n\\dot x = \\displaystyle rx\\left(1-\\frac{x}{K}\\right) - c \\frac{x}{h+x} y\\\\[.3cm]\n\\dot y = b\\displaystyle \\frac{x}{h+x} y - m y\n\\end{array}\\right.\n$$ {#eq-rma}\n\nL'objectif est de r√©aliser des simulations performantes sur le trac√© du diagramme de bifurcations, avec l'estimation par simulation du cycle limite. Ce type de simulations lourdes se pr√™te bien √† se genre de benchmark.\n\n### Strat√©gie pour le code\n\nPour un tel probl√®me de dimension r√©duite, nous allons utiliser des static arrays (tableaux √† adresse fixe dans la m√©moire^[depuis le package `StaticArrays.jl`]), ce qui permettra de ne pas cr√©√©er une multitude d'objets pour la simulation mais de toujours modifier le m√™me objet en m√©moire.\n\nPar ailleurs nous allons essayer de nous conformer au maximum aux pr√©conisations :\n\n- ne pas utiliser de variables globales\n- d√©finir des fonctions\n- mettre les param√®tres dans un nombre limit√© de variables et les passer en arguments des fonctions\n\nPour ce dernier point, nous allons d√©finir des types (`struct`) sp√©cifiques.\n\nNous commen√ßons par importer les packages que nous allons utiliser:\n\n::: {.cell execution_count=2}\n``` {.julia .cell-code}\nusing StaticArrays\nusing DifferentialEquations\nusing CairoMakie\n```\n:::\n\n\n### Type sp√©cifique pour les param√®tres\n\nNous d√©finissons un `struct` pour les param√®tres du mod√®le de Rosenzweig MacArthur.\n\nType pour les param√®tres :\n\n::: {.cell execution_count=3}\n``` {.julia .cell-code}\n# parameters struct\n@kwdef struct ParRma\n    r::Float64 = 1.0\n    K::Float64 = 10.0\n    c::Float64 = 1.0\n    h::Float64 = 2.0\n    b::Float64 = 2.0\n    m::Float64 = 1.0\nend\n```\n:::\n\n\n::: {.callout-note}\nLa macro `@kwdef` permet de renseigner des valeurs par d√©faut des champs du `struct`.\n:::\n\n::: {.callout-important}\nLors de la cr√©ation d'un `struct`, on peut √™tre tent√© d'utiliser des types de champs les plus larges possibles, comme par exemple `r::Real = 1.0` ou `r::Number = 1.0`.\n\n*C'est une tr√®s mauvaise id√©e* : `Real` et `Number` sont des types abstraits qui englobent de nombreux types concrets (e.g. `Int64` et `Float64`). Par construction ils ne permettent pas de sp√©cifier un espace m√©moire de taille fixe comme le font les types concrets, et ne permettent donc pas d'optimiser le code √† la pr√©compilation^[Par exemple, la fonction `cy_rma()` d√©finie plus bas (la plus co√ªteuse en temps de calcul) est 70 fois plus lente avec un `ParRma` qui d√©finit ses champs en `Real` plut√¥t qu'en `Float64`, (ex√©cution de ~0.5s √† ~35s apr√®s pr√©compilation)].\n:::\n\nOn peut cr√©er des objets de type `ParRma` via les `constructor` par d√©faut; on acc√®de √† un champ particulier via `objet.champ` :\n\n::: {.cell execution_count=4}\n``` {.julia .cell-code}\n# with the struct definition, ParRma objects are immutable\nprma = ParRma() # constructor with default values\nprma2 = ParRma(K = 8.0) # default values except K = 20.0\n\n@show prma\n@show prma.K\n@show prma2.K;\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nprma = ParRma(1.0, 10.0, 1.0, 2.0, 2.0, 1.0)\nprma.K = 10.0\nprma2.K = 8.0\n```\n:::\n:::\n\n\n::: {.callout-note}\nLa macro `@show` est assez explicite\n\nLe `;` permet de ne pas renvoyer l'√©valuation de la commande `prma2.K` (qui vaut 8.0) √©tant donn√© que nous avons d√©j√† forc√© la sortie via `@show`\n:::\n\n### Fonctions\n\nNous d√©finissons les diff√©rentes fonctions impliqu√©es dans le mod√®le de Rosenzweig MacArthur, la logistique et la r√©ponse fonctionnelle de Holling II.\n\nPour la logistique :\n\n::: {.cell execution_count=5}\n``` {.julia .cell-code}\nfunction logistic(x, p::ParRma)\n    (; r, K) = p    # deconstruct/get r and K from p\n    return r*x*(1-x/K)\nend\n```\n:::\n\n\n::: {.callout-note}\n- les notations `var::Type` permettent de sp√©cifier le type de l'argument de la fonction^[C'est une des mani√®res de faire du [multiple dispatch](https://docs.julialang.org/en/v1/manual/methods/), en d√©finissant diff√©rentes m√©thodes pour les fonctions selon le type de l'argument]\n- la notation `(; r, K) = p` permet d'extraire (*deconstruct*) les champs `r` et `K` du param√®tre `p` qui est un objet de type `ParRma`\n:::\n\nPour la r√©ponse fonctionnelle (sans le param√®tre $c$) :\n\n::: {.cell execution_count=6}\n``` {.julia .cell-code}\nfunction holling2(x, p::ParRma)\n    (; h) = p   # deconstruct h from p\n    return x/(x+h)\nend\n```\n:::\n\n\n### Conditions initiales\n\nPour utiliser les static arrays avec `DifferentialEquations.jl` il faut que l'√©tat (donc la condition initiale) et les d√©riv√©es rendues par le mod√®le soient des static arrays (ici un `SVector`).\n\nNous d√©finissons un `struct` de condition initiales, avec pour champs `x0`, `y0` et un `Svector` compos√© de ces deux valeurs :\n\n::: {.cell execution_count=7}\n``` {.julia .cell-code}\n# initial value struct\n@kwdef struct IniV\n    x0::Float64 = 1.0\n    y0::Float64 = 1.95\n    u0::SVector{2, Float64} = SVector(x0, y0)\nend\n# construct some initial condition\n@show iniv = IniV();\n```\n\n::: {.cell-output .cell-output-stdout}\n```\niniv = IniV() = IniV(1.0, 1.95, [1.0, 1.95])\n```\n:::\n:::\n\n\nNous d√©finissons un constructeur additionnel pour le type `IniV` qui √† partir d'un `SVector` de longueur 2, construit l'objet `IniV` correspondant^[il s'agit d'une forme de multiple dispatch sur le constructeur, avec plusieurs m√©thodes diff√©rents selon le type d'arguments utilis√©s] (nous nous en servirons plus bas dans la fonction `cy_rma()`)\n\n::: {.cell execution_count=8}\n``` {.julia .cell-code}\n# new constructor method for struct IniV\n# takes a length 2 SVector to construct the object (self definition)\nIniV(u0::SVector{2, Float64}) = IniV(x0 = u0[1], y0 = u0[2])\n\n# construct an initial condition with this constructor\n@show IniV(SVector(3.0, 3.0));\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nIniV(SVector(3.0, 3.0)) = IniV(3.0, 3.0, [3.0, 3.0])\n```\n:::\n:::\n\n\n### Mod√®le\n\nOn d√©finit les √©quations du mod√®le en exploitant les fonctions d√©finies plus haut et la structure des param√®tres, en renvoyant les d√©riv√©es sous forme de `SVector` :\n\n::: {.cell execution_count=9}\n``` {.julia .cell-code}\nfunction mod_rma(u::SVector{2, Float64}, p::ParRma, t)\n    (; c, b, m) = p     # get c, b, m from p\n    x = u[1]            # use x, y notations\n    y = u[2]\n\n    dx = logistic(x, p) - c * holling2(x,p) * y\n    dy = b * holling2(x, p) * y - m * y\n\n    return SVector(dx, dy) # return derivatives as SVector\nend\n```\n:::\n\n\n### Simulation simple\n\nOn d√©finit les param√®tres du temps dans un `struct` :\n\n::: {.cell execution_count=10}\n``` {.julia .cell-code}\n# time parameters struct\n@kwdef struct ParTime\n    tspan::Tuple{Float64, Float64} = (0.0, 60.0)\n    tstep::Float64 = 0.1\nend\n\n# construct a time parameter\nptime = ParTime()\n```\n:::\n\n\nOn d√©finit une fonction qui d√©finit le probl√®me de simulation, l'int√®gre et retourne la solution, avec pour arguments positionnels la condition initiale, les param√®tres et les param√®tres de temps, et comme keyword argument le param√®tre bool√©en `final`.\n\nLorsque `final = false` (par d√©faut), la fonction renvoie toute la solution. Lorsque `final  =true` la fonction renvoie la valeur finale de la simulation, ce dont nous nous servirons plus bas dans l'estimation des extremas du cycle limite.\n\n::: {.cell execution_count=11}\n``` {.julia .cell-code}\nfunction sim_rma(iniv::IniV, p::ParRma, pt::ParTime; final::Bool = false)\n    # deconstruct time parameter\n    (; tspan, tstep) = pt\n    (; u0) = iniv\n\n    # define and solve simulation problem\n    prob_rma = ODEProblem(mod_rma, u0, tspan, p)\n    if !final   # if final == false compute whole solution\n        sol_rma = solve(prob_rma; reltol = 1e-6, saveat = tstep)\n    else        # if final == true compute only final state\n        sol_rma = solve(\n            prob_rma;\n            reltol = 1e-6,\n            save_everystep = false,\n            save_start = false,\n        )\n    end\n\n    return sol_rma\nend\n\n@time sim_rma(iniv, prma, ptime);\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  1.249964 seconds (862.99 k allocations: 56.540 MiB, 1.06% gc time, 99.97% compilation time: 100% of which was recompilation)\n```\n:::\n:::\n\n\n::: {.callout-note}\nLa macro `@time` renvoit le temps (et qqes √©l√©ments sur la computation) mis pour calculer la commande qui la suit, ici la simulation.\n:::\n\nUne fois la fonction pr√©compil√©e √† la premi√®re ex√©cution, la performance est incomparable (4 ordres de grandeur plus rapide sur la fonction `sim_rma()`) :\n\n::: {.cell execution_count=12}\n``` {.julia .cell-code}\n@time sim_rma(iniv, prma2, ptime);\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  0.000195 seconds (328 allocations: 47.234 KiB)\n```\n:::\n:::\n\n\n### Solution contre le temps\n\nFinalement, on d√©finit une fonction qui simule et produit un graphique de la solution contre le temps, avec pour arguments la condition initiale, les param√®tres et les param√®tres de temps :\n\n::: {.cell execution_count=13}\n``` {.julia .cell-code}\nfunction plot_rma(iniv::IniV, p::ParRma, pt::ParTime)\n    # compute the simulation\n    sol_rma = sim_rma(iniv, p, pt)\n\n    # initialize figure\n    fig = Figure(; fontsize = 20)\n    ax = Axis(fig[1,1];\n        title = \"Mod√®le de Rosenzweig MacArthur\\n \",\n        xlabel = \"temps\",\n        ylabel = \"densit√©s\",\n    )\n\n    # plot solution\n    lines!(ax, sol_rma.t, sol_rma[1,:]; lw = 2, label = \"proies\")\n    lines!(ax, sol_rma.t,  sol_rma[2,:]; lw = 2, label = \"pr√©dateurs\")\n    axislegend(; position = :lt)\n\n    return fig\nend\n```\n:::\n\n\nFinalement on ex√©cute cette fonction pour tracer la simulation :\n\n::: {.cell execution_count=14}\n``` {.julia .cell-code}\nplot_rma(iniv, prma, ptime)\n```\n\n::: {.cell-output .cell-output-display execution_count=35}\n![Simulation des trajectoires du mod√®le de Rosenzweig MacArthur](annexe_swift_rma_files/figure-html/fig-rma-time-output-1.svg){#fig-rma-time}\n:::\n:::\n\n\n### Diagramme de bifurcations\n\nNous calculons ici le diagramme de bifurcations : les asymptotiques des pr√©dateurs $y^*$ en fonction de $K$.\n\n#### √âquilibres\n\nIl n'y a pas besoin de simulation ici puisque les lieux des √©quilibres sont facilement calculables analytiquement (cf. cette [page](pop_interactions2.qmd)).\n\nNous d√©finissons une fonction qui prend les param√®tres du mod√®le et renvoit des tuples d√©finissant les diff√©rentes branches d'√©quilibres $(K, y^*)$ (avec en `kwarg` un `Kmax` et un `Kstep` avec des valeurs par d√©faut).\n\n::: {.cell execution_count=15}\n``` {.julia .cell-code}\nfunction eqy_rma(p::ParRma; Kmax::Real = 8.0, Kstep::Real = 0.1)\n    (; r, K, c, h, b, m) = p # deconstruct p\n\n    # define bifurcation K values\n    Ktrans = m*h/(b-m)\n    Khopf = h+2*m*h/(b-m)\n\n    # drops an error if Kmax is too small\n    if Kmax < Khopf\n        error(\"For a full computation of equilibria types, Kmax must be greater than $Khopf\")\n    end\n\n    # y equilibria\n    # below transcritical : only y=0\n    Krg1 = 0:Kstep:Ktrans\n    y01 = ones(length(Krg1)).*0     # broadcasting\n    eqs1 = (Krg = Krg1, y0 = y01)\n\n    # between transcritical and Hopf : y=0 and y>0\n    Krg2 = Ktrans:Kstep:Khopf\n    y02 = ones(length(Krg2)).*0\n    yco2 = [r/c*(h+m*h/(b-m))*(1-m*h/(b-m)/K) for K in Krg2]\n    eqs2 = (Krg = Krg2, y0 = y02, yco = yco2)\n\n    # above Hopf : y=0 and y>0\n    Krg3 = Khopf:Kstep:Kmax\n    y03 = ones(length(Krg3)).*0\n    yco3 = [r/c*(h+m*h/(b-m))*(1-m*h/(b-m)/K) for K in Krg3]\n    eqs3 = (Krg = Krg3, y0 = y03, yco = yco3)\n\n    return eqs1, eqs2, eqs3\nend\n```\n:::\n\n\n#### Cycle limite\n\nOn d√©finit une fonction qui renvoit un tuple contenant les valeurs de $K$ et les extremas du cycle limite apparaissant pour $K > K_{hopf} = h+\\frac{2mh}{b-m}$.\n\nLa fonction prend pour argument les param√®tres, et fait appel √† la fonction `sim_rma()` avec les m√©thodes `final = true` (pour les transitoires) et `final = false` (pour les extremas du cycle limite). Elle utilise aussi le constructeur suppl√©mentaire pour les objets `IniV`.\n\n::: {.cell execution_count=16}\n``` {.julia .cell-code}\nfunction cy_rma(p::ParRma; Kmax::Float64 = 8.0, Kstep::Float64 = 0.01)\n    # parameters and K range\n    (; r, K, c, h, b, m) = p # deconstruct p\n    Khopf = h+2*m*h/(b-m)\n    Krgh = Khopf-Kstep:Kstep:Kmax\n\n    # for storage\n    ycmin = zero(Krgh)\n    ycmax = zero(Krgh)\n\n    # initial value and time parameters\n    iniv = IniV()\n    ptime = ParTime()\n\n    # transient integration time\n    ptrans = ParTime(tspan = (0.0, 8000.0))\n\n    for (i, Kh) in enumerate(Krgh)\n        # construct parameter from p, with K = Kh of the loop\n        prmabif = ParRma(r, Kh, c, h, b, m)\n\n        # simulate transient, get final state\n        utr = sim_rma(iniv, prmabif, ptrans; final = true)[:,1]\n        inivtr = IniV(utr) # construct new init value\n\n        # start from end of transient, simulate limit cycle\n        sol_cyc = sim_rma(inivtr, prmabif, ptime)\n\n        # get min and max y along the cycle\n        ycmin[i] = minimum(sol_cyc[2,:])\n        ycmax[i] = maximum(sol_cyc[2,:])\n    end\n\n    cycle = (Krg = Krgh, ycmin = ycmin, ycmax = ycmax)\n    return cycle\nend\n\n@time cy_rma(prma);\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  1.579565 seconds (5.22 M allocations: 122.235 MiB, 1.31% gc time, 71.40% compilation time: 100% of which was recompilation)\n```\n:::\n:::\n\n\nApr√®s pr√©compilation, ce calcul est encore plus rapide :\n\n::: {.cell execution_count=17}\n``` {.julia .cell-code}\n@time cy_rma(prma2);\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  0.445394 seconds (4.62 M allocations: 82.282 MiB, 0.57% gc time)\n```\n:::\n:::\n\n\nA titre d'exemple, la simulation sur cette [page](pop_interactions2.qmd) prenait de l'ordre de 20 fois plus longtemps pour un calcul similaire.\n\n#### Repr√©sentation graphique\n\nFinalement, nous d√©finissons une fonction permettant de repr√©senter le diagramme de bifurcations, qui fait appel aux fonctions `eqy_rma()` et `cy_rma()` d√©finies ci-dessus :\n\n::: {.cell execution_count=18}\n``` {.julia .cell-code}\nfunction plot_bif_rma(p::ParRma)\n    # initialize figure\n    fig = Figure(; fontsize = 20)\n    ax = Axis(fig[1,1];\n        title = \"Bifurcations du mod√®le de Rosenzweig MacArthur\\n \",\n        xlabel = \"capacit√© de charge ùêæ\",\n        ylabel = \"densit√©s\",\n    )\n\n    # plot equilibria\n    eqs1, eqs2, eqs3 = eqy_rma(p)\n    lines!(eqs1.Krg, eqs1.y0; color = Cycled(1), lw = 2, label = \"branche stable\")\n    lines!(eqs2.Krg, eqs2.y0; color = Cycled(2), lw = 2, label = \"branche instable\")\n    lines!(eqs2.Krg, eqs2.yco; color = Cycled(1), lw = 2)\n    lines!(eqs3.Krg, eqs3.y0; color = Cycled(2), lw = 2)\n    lines!(eqs3.Krg, eqs3.yco; color = Cycled(2), lw = 2)\n\n    # plot limit Cycle\n    cycle = cy_rma(p)\n    lines!(cycle.Krg, cycle.ycmin; color = Cycled(3), lw=2, label = \"cycle limite\")\n    lines!(cycle.Krg, cycle.ycmax; color = Cycled(3), lw=2)\n\n    axislegend(ax, position = :lt, labelsize = 14)\n\n    return fig\nend\n```\n:::\n\n\nCe qui donne :\n\n::: {.cell execution_count=19}\n``` {.julia .cell-code}\nplot_bif_rma(prma)\n```\n\n::: {.cell-output .cell-output-display execution_count=40}\n![Diagramme de bifurcations du mod√®le de Rosenzweig MacArthur](annexe_swift_rma_files/figure-html/fig-rma-bif-output-1.svg){#fig-rma-bif}\n:::\n:::\n\n\n### Organisation en modules\n\n\n### Conclusion\n\n\n## Cas des mod√®les de plus grande dimension\n\nPour les mod√®les de plus grande dimension ($n>8$), l'avantage en performance des static arrays n'est plus si net et la documentation de `DifferentialEquations.jl` recommande d'utiliser la version en place (is in place, IIP dans le jargon du package) de l'interface problem/solver du package.\n\nIl s'agit ici de d√©finir le mod√®le non pas comme renvoyant la d√©riv√©e en fonction de l'√©tat, des param√®tres et du temps, mais comme une fonction d'arguments la d√©riv√©e, l'√©tat, les param√®tres et le temps qui modifie en place la d√©riv√©e (et ne renvoie rien)). Cel√† permet de muter un m√™me objet d√©riv√©e `du` √† chaque fois que le mod√®le est appel√©, plut√¥t que de cr√©er un nouvel objet d√©riv√©e `du` √† chaque appel du mod√®le (c'est aussi ce qui est fait, diff√©remment, avec les static arrays plus haut).\n\nTypiquement ce type de mod√®le IIP (en place) s'√©crit:\n\n::: {.cell execution_count=20}\n``` {.julia .cell-code}\nfunction mod_rma!(du, u, p, t)\n    return nothing\nend\n```\n:::\n\n\nLa d√©finition du probl√®me d'int√©gration et l'appel de solve est similaire aux autres m√©thodes, √† ceci pr√®s que la condition initiale et la d√©riv√©e doit √™tre mutable, ce qui ne permet pas (ou tr√®s difficilement) d'utiliser la m√©thode en dimension 1. En effet une d√©claration `u0 = 1.0` ou `du = 3.0` n'est pas mutable^[alors que `u0 = [1.0, 2.0]` ou `du =[2.0, 3.0]` le sont. Plus sur la mutabilit√© dans les [Julia notes](https://m3g.github.io/JuliaNotes.jl/stable/immutable/).].\n\n",
    "supporting": [
      "annexe_swift_rma_files"
    ],
    "filters": [],
    "includes": {}
  }
}