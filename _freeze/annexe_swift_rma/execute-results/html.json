{
  "hash": "b0a5c4e01b2e8a11410d177973232608",
  "result": {
    "markdown": "---\ntitle: \"Simulation améliorée\"\n---\n\n## Modèle de Rosenzweig MacArthur\n\nNous considérons le modèle de dynamique de populations de Rosenzweig et MacArthur que nous avons déjà vu (@Rosenzweig1963, @Turchin2003, @Smith2008).\n\n$$\n\\left\\{\\begin{array}{l}\n\\dot x = \\displaystyle rx\\left(1-\\frac{x}{K}\\right) - c \\frac{x}{h+x} y\\\\[.3cm]\n\\dot y = b\\displaystyle \\frac{x}{h+x} y - m y\n\\end{array}\\right.\n$$ {#eq-rma}\n\nL'objectif est de réaliser des simulations performantes sur le tracé du diagramme de bifurcations, avec l'estimation par simulation du cycle limite. Ce type de simulations lourdes se prête bien à se genre de benchmark.\n\n### Stratégie pour le code\n\nPour un tel problème de dimension réduite, nous allons utiliser des static arrays (tableaux à adresse fixe dans la mémoire^[depuis le package `StaticArrays.jl`]), ce qui permettra de ne pas crééer une multitude d'objets pour la simulation mais de toujours modifier le même objet en mémoire.\n\nPar ailleurs nous allons essayer de nous conformer au maximum aux préconisations :\n\n- ne pas utiliser de variables globales\n- définir des fonctions\n- mettre les paramètres dans un nombre limité de variables et les passer en arguments des fonctions\n\nPour ce dernier point, nous allons définir des types (`struct`) spécifiques.\n\nNous commençons par importer les packages que nous allons utiliser:\n\n::: {.cell execution_count=2}\n``` {.julia .cell-code}\nusing StaticArrays\nusing DifferentialEquations\nusing CairoMakie\n```\n:::\n\n\n### Type spécifique pour les paramètres\n\nNous définissons un `struct` pour les paramètres du modèle de Rosenzweig MacArthur.\n\nType pour les paramètres :\n\n::: {.cell execution_count=3}\n``` {.julia .cell-code}\n# parameters struct\n@kwdef struct ParRma\n    r::Float64 = 1.0\n    K::Float64 = 10.0\n    c::Float64 = 1.0\n    h::Float64 = 2.0\n    b::Float64 = 2.0\n    m::Float64 = 1.0\nend\n```\n:::\n\n\n::: {.callout-note}\nLa macro `@kwdef` permet de renseigner des valeurs par défaut des champs du `struct`.\n:::\n\n::: {.callout-important}\nLors de la création d'un `struct`, on peut être tenté d'utiliser des types de champs les plus larges possibles, comme par exemple `r::Real = 1.0` ou `r::Number = 1.0`.\n\n*C'est une très mauvaise idée* : `Real` et `Number` sont des types abstraits qui englobent de nombreux types concrets (e.g. `Int64` et `Float64`). Par construction ils ne permettent pas de spécifier un espace mémoire de taille fixe comme le font les types concrets, et ne permettent donc pas d'optimiser le code à la précompilation^[Par exemple, la fonction `cy_rma()` définie plus bas (la plus coûteuse en temps de calcul) est 70 fois plus lente avec un `ParRma` qui définit ses champs en `Real` plutôt qu'en `Float64`, (exécution de ~0.5s à ~35s après précompilation)].\n:::\n\nOn peut créer des objets de type `ParRma` via les `constructor` par défaut; on accède à un champ particulier via `objet.champ` :\n\n::: {.cell execution_count=4}\n``` {.julia .cell-code}\n# with the struct definition, ParRma objects are immutable\nprma = ParRma() # constructor with default values\nprma2 = ParRma(K = 8.0) # default values except K = 20.0\n\n@show prma\n@show prma.K\n@show prma2.K;\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nprma = ParRma(1.0, 10.0, 1.0, 2.0, 2.0, 1.0)\nprma.K = 10.0\nprma2.K = 8.0\n```\n:::\n:::\n\n\n::: {.callout-note}\nLa macro `@show` est assez explicite\n\nLe `;` permet de ne pas renvoyer l'évaluation de la commande `prma2.K` (qui vaut 8.0) étant donné que nous avons déjà forcé la sortie via `@show`\n:::\n\n### Fonctions\n\nNous définissons les différentes fonctions impliquées dans le modèle de Rosenzweig MacArthur, la logistique et la réponse fonctionnelle de Holling II.\n\nPour la logistique :\n\n::: {.cell execution_count=5}\n``` {.julia .cell-code}\nfunction logistic(x, p::ParRma)\n    (; r, K) = p    # deconstruct/get r and K from p\n    return r*x*(1-x/K)\nend\n```\n:::\n\n\n::: {.callout-note}\n- les notations `var::Type` permettent de spécifier le type de l'argument de la fonction^[C'est une des manières de faire du [multiple dispatch](https://docs.julialang.org/en/v1/manual/methods/), en définissant différentes méthodes pour les fonctions selon le type de l'argument]\n- la notation `(; r, K) = p` permet d'extraire (*deconstruct*) les champs `r` et `K` du paramètre `p` qui est un objet de type `ParRma`\n:::\n\nPour la réponse fonctionnelle (sans le paramètre $c$) :\n\n::: {.cell execution_count=6}\n``` {.julia .cell-code}\nfunction holling2(x, p::ParRma)\n    (; h) = p   # deconstruct h from p\n    return x/(x+h)\nend\n```\n:::\n\n\n### Conditions initiales\n\nPour utiliser les static arrays avec `DifferentialEquations.jl` il faut que l'état (donc la condition initiale) et les dérivées rendues par le modèle soient des static arrays (ici un `SVector`).\n\nNous définissons un `struct` de condition initiales, avec pour champs `x0`, `y0` et un `Svector` composé de ces deux valeurs :\n\n::: {.cell execution_count=7}\n``` {.julia .cell-code}\n# initial value struct\n@kwdef struct IniV\n    x0::Float64 = 1.0\n    y0::Float64 = 1.95\n    u0::SVector{2, Float64} = SVector(x0, y0)\nend\n# construct some initial condition\n@show iniv = IniV();\n```\n\n::: {.cell-output .cell-output-stdout}\n```\niniv = IniV() = IniV(1.0, 1.95, [1.0, 1.95])\n```\n:::\n:::\n\n\nNous définissons un constructeur additionnel pour le type `IniV` qui à partir d'un `SVector` de longueur 2, construit l'objet `IniV` correspondant^[il s'agit d'une forme de multiple dispatch sur le constructeur, avec plusieurs méthodes différents selon le type d'arguments utilisés] (nous nous en servirons plus bas dans la fonction `cy_rma()`)\n\n::: {.cell execution_count=8}\n``` {.julia .cell-code}\n# new constructor method for struct IniV\n# takes a length 2 SVector to construct the object (self definition)\nIniV(u0::SVector{2, Float64}) = IniV(x0 = u0[1], y0 = u0[2])\n\n# construct an initial condition with this constructor\n@show IniV(SVector(3.0, 3.0));\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nIniV(SVector(3.0, 3.0)) = IniV(3.0, 3.0, [3.0, 3.0])\n```\n:::\n:::\n\n\n### Modèle\n\nOn définit les équations du modèle en exploitant les fonctions définies plus haut et la structure des paramètres, en renvoyant les dérivées sous forme de `SVector` :\n\n::: {.cell execution_count=9}\n``` {.julia .cell-code}\nfunction mod_rma(u::SVector{2, Float64}, p::ParRma, t)\n    (; c, b, m) = p     # get c, b, m from p\n    x = u[1]            # use x, y notations\n    y = u[2]\n\n    dx = logistic(x, p) - c * holling2(x,p) * y\n    dy = b * holling2(x, p) * y - m * y\n\n    return SVector(dx, dy) # return derivatives as SVector\nend\n```\n:::\n\n\n### Simulation simple\n\nOn définit les paramètres du temps dans un `struct` :\n\n::: {.cell execution_count=10}\n``` {.julia .cell-code}\n# time parameters struct\n@kwdef struct ParTime\n    tspan::Tuple{Float64, Float64} = (0.0, 60.0)\n    tstep::Float64 = 0.1\nend\n\n# construct a time parameter\nptime = ParTime()\n```\n:::\n\n\nOn définit une fonction qui définit le problème de simulation, l'intègre et retourne la solution, avec pour arguments positionnels la condition initiale, les paramètres et les paramètres de temps, et comme keyword argument le paramètre booléen `final`.\n\nLorsque `final = false` (par défaut), la fonction renvoie toute la solution. Lorsque `final  =true` la fonction renvoie la valeur finale de la simulation, ce dont nous nous servirons plus bas dans l'estimation des extremas du cycle limite.\n\n::: {.cell execution_count=11}\n``` {.julia .cell-code}\nfunction sim_rma(iniv::IniV, p::ParRma, pt::ParTime; final::Bool = false)\n    # deconstruct time parameter\n    (; tspan, tstep) = pt\n    (; u0) = iniv\n\n    # define and solve simulation problem\n    prob_rma = ODEProblem(mod_rma, u0, tspan, p)\n    if !final   # if final == false compute whole solution\n        sol_rma = solve(prob_rma; reltol = 1e-6, saveat = tstep)\n    else        # if final == true compute only final state\n        sol_rma = solve(\n            prob_rma;\n            reltol = 1e-6,\n            save_everystep = false,\n            save_start = false,\n        )\n    end\n\n    return sol_rma\nend\n\n@time sim_rma(iniv, prma, ptime);\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  1.249964 seconds (862.99 k allocations: 56.540 MiB, 1.06% gc time, 99.97% compilation time: 100% of which was recompilation)\n```\n:::\n:::\n\n\n::: {.callout-note}\nLa macro `@time` renvoit le temps (et qqes éléments sur la computation) mis pour calculer la commande qui la suit, ici la simulation.\n:::\n\nUne fois la fonction précompilée à la première exécution, la performance est incomparable (4 ordres de grandeur plus rapide sur la fonction `sim_rma()`) :\n\n::: {.cell execution_count=12}\n``` {.julia .cell-code}\n@time sim_rma(iniv, prma2, ptime);\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  0.000195 seconds (328 allocations: 47.234 KiB)\n```\n:::\n:::\n\n\n### Solution contre le temps\n\nFinalement, on définit une fonction qui simule et produit un graphique de la solution contre le temps, avec pour arguments la condition initiale, les paramètres et les paramètres de temps :\n\n::: {.cell execution_count=13}\n``` {.julia .cell-code}\nfunction plot_rma(iniv::IniV, p::ParRma, pt::ParTime)\n    # compute the simulation\n    sol_rma = sim_rma(iniv, p, pt)\n\n    # initialize figure\n    fig = Figure(; fontsize = 20)\n    ax = Axis(fig[1,1];\n        title = \"Modèle de Rosenzweig MacArthur\\n \",\n        xlabel = \"temps\",\n        ylabel = \"densités\",\n    )\n\n    # plot solution\n    lines!(ax, sol_rma.t, sol_rma[1,:]; lw = 2, label = \"proies\")\n    lines!(ax, sol_rma.t,  sol_rma[2,:]; lw = 2, label = \"prédateurs\")\n    axislegend(; position = :lt)\n\n    return fig\nend\n```\n:::\n\n\nFinalement on exécute cette fonction pour tracer la simulation :\n\n::: {.cell execution_count=14}\n``` {.julia .cell-code}\nplot_rma(iniv, prma, ptime)\n```\n\n::: {.cell-output .cell-output-display execution_count=35}\n![Simulation des trajectoires du modèle de Rosenzweig MacArthur](annexe_swift_rma_files/figure-html/fig-rma-time-output-1.svg){#fig-rma-time}\n:::\n:::\n\n\n### Diagramme de bifurcations\n\nNous calculons ici le diagramme de bifurcations : les asymptotiques des prédateurs $y^*$ en fonction de $K$.\n\n#### Équilibres\n\nIl n'y a pas besoin de simulation ici puisque les lieux des équilibres sont facilement calculables analytiquement (cf. cette [page](pop_interactions2.qmd)).\n\nNous définissons une fonction qui prend les paramètres du modèle et renvoit des tuples définissant les différentes branches d'équilibres $(K, y^*)$ (avec en `kwarg` un `Kmax` et un `Kstep` avec des valeurs par défaut).\n\n::: {.cell execution_count=15}\n``` {.julia .cell-code}\nfunction eqy_rma(p::ParRma; Kmax::Real = 8.0, Kstep::Real = 0.1)\n    (; r, K, c, h, b, m) = p # deconstruct p\n\n    # define bifurcation K values\n    Ktrans = m*h/(b-m)\n    Khopf = h+2*m*h/(b-m)\n\n    # drops an error if Kmax is too small\n    if Kmax < Khopf\n        error(\"For a full computation of equilibria types, Kmax must be greater than $Khopf\")\n    end\n\n    # y equilibria\n    # below transcritical : only y=0\n    Krg1 = 0:Kstep:Ktrans\n    y01 = ones(length(Krg1)).*0     # broadcasting\n    eqs1 = (Krg = Krg1, y0 = y01)\n\n    # between transcritical and Hopf : y=0 and y>0\n    Krg2 = Ktrans:Kstep:Khopf\n    y02 = ones(length(Krg2)).*0\n    yco2 = [r/c*(h+m*h/(b-m))*(1-m*h/(b-m)/K) for K in Krg2]\n    eqs2 = (Krg = Krg2, y0 = y02, yco = yco2)\n\n    # above Hopf : y=0 and y>0\n    Krg3 = Khopf:Kstep:Kmax\n    y03 = ones(length(Krg3)).*0\n    yco3 = [r/c*(h+m*h/(b-m))*(1-m*h/(b-m)/K) for K in Krg3]\n    eqs3 = (Krg = Krg3, y0 = y03, yco = yco3)\n\n    return eqs1, eqs2, eqs3\nend\n```\n:::\n\n\n#### Cycle limite\n\nOn définit une fonction qui renvoit un tuple contenant les valeurs de $K$ et les extremas du cycle limite apparaissant pour $K > K_{hopf} = h+\\frac{2mh}{b-m}$.\n\nLa fonction prend pour argument les paramètres, et fait appel à la fonction `sim_rma()` avec les méthodes `final = true` (pour les transitoires) et `final = false` (pour les extremas du cycle limite). Elle utilise aussi le constructeur supplémentaire pour les objets `IniV`.\n\n::: {.cell execution_count=16}\n``` {.julia .cell-code}\nfunction cy_rma(p::ParRma; Kmax::Float64 = 8.0, Kstep::Float64 = 0.01)\n    # parameters and K range\n    (; r, K, c, h, b, m) = p # deconstruct p\n    Khopf = h+2*m*h/(b-m)\n    Krgh = Khopf-Kstep:Kstep:Kmax\n\n    # for storage\n    ycmin = zero(Krgh)\n    ycmax = zero(Krgh)\n\n    # initial value and time parameters\n    iniv = IniV()\n    ptime = ParTime()\n\n    # transient integration time\n    ptrans = ParTime(tspan = (0.0, 8000.0))\n\n    for (i, Kh) in enumerate(Krgh)\n        # construct parameter from p, with K = Kh of the loop\n        prmabif = ParRma(r, Kh, c, h, b, m)\n\n        # simulate transient, get final state\n        utr = sim_rma(iniv, prmabif, ptrans; final = true)[:,1]\n        inivtr = IniV(utr) # construct new init value\n\n        # start from end of transient, simulate limit cycle\n        sol_cyc = sim_rma(inivtr, prmabif, ptime)\n\n        # get min and max y along the cycle\n        ycmin[i] = minimum(sol_cyc[2,:])\n        ycmax[i] = maximum(sol_cyc[2,:])\n    end\n\n    cycle = (Krg = Krgh, ycmin = ycmin, ycmax = ycmax)\n    return cycle\nend\n\n@time cy_rma(prma);\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  1.579565 seconds (5.22 M allocations: 122.235 MiB, 1.31% gc time, 71.40% compilation time: 100% of which was recompilation)\n```\n:::\n:::\n\n\nAprès précompilation, ce calcul est encore plus rapide :\n\n::: {.cell execution_count=17}\n``` {.julia .cell-code}\n@time cy_rma(prma2);\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  0.445394 seconds (4.62 M allocations: 82.282 MiB, 0.57% gc time)\n```\n:::\n:::\n\n\nA titre d'exemple, la simulation sur cette [page](pop_interactions2.qmd) prenait de l'ordre de 20 fois plus longtemps pour un calcul similaire.\n\n#### Représentation graphique\n\nFinalement, nous définissons une fonction permettant de représenter le diagramme de bifurcations, qui fait appel aux fonctions `eqy_rma()` et `cy_rma()` définies ci-dessus :\n\n::: {.cell execution_count=18}\n``` {.julia .cell-code}\nfunction plot_bif_rma(p::ParRma)\n    # initialize figure\n    fig = Figure(; fontsize = 20)\n    ax = Axis(fig[1,1];\n        title = \"Bifurcations du modèle de Rosenzweig MacArthur\\n \",\n        xlabel = \"capacité de charge 𝐾\",\n        ylabel = \"densités\",\n    )\n\n    # plot equilibria\n    eqs1, eqs2, eqs3 = eqy_rma(p)\n    lines!(eqs1.Krg, eqs1.y0; color = Cycled(1), lw = 2, label = \"branche stable\")\n    lines!(eqs2.Krg, eqs2.y0; color = Cycled(2), lw = 2, label = \"branche instable\")\n    lines!(eqs2.Krg, eqs2.yco; color = Cycled(1), lw = 2)\n    lines!(eqs3.Krg, eqs3.y0; color = Cycled(2), lw = 2)\n    lines!(eqs3.Krg, eqs3.yco; color = Cycled(2), lw = 2)\n\n    # plot limit Cycle\n    cycle = cy_rma(p)\n    lines!(cycle.Krg, cycle.ycmin; color = Cycled(3), lw=2, label = \"cycle limite\")\n    lines!(cycle.Krg, cycle.ycmax; color = Cycled(3), lw=2)\n\n    axislegend(ax, position = :lt, labelsize = 14)\n\n    return fig\nend\n```\n:::\n\n\nCe qui donne :\n\n::: {.cell execution_count=19}\n``` {.julia .cell-code}\nplot_bif_rma(prma)\n```\n\n::: {.cell-output .cell-output-display execution_count=40}\n![Diagramme de bifurcations du modèle de Rosenzweig MacArthur](annexe_swift_rma_files/figure-html/fig-rma-bif-output-1.svg){#fig-rma-bif}\n:::\n:::\n\n\n### Organisation en modules\n\n\n### Conclusion\n\n\n## Cas des modèles de plus grande dimension\n\nPour les modèles de plus grande dimension ($n>8$), l'avantage en performance des static arrays n'est plus si net et la documentation de `DifferentialEquations.jl` recommande d'utiliser la version en place (is in place, IIP dans le jargon du package) de l'interface problem/solver du package.\n\nIl s'agit ici de définir le modèle non pas comme renvoyant la dérivée en fonction de l'état, des paramètres et du temps, mais comme une fonction d'arguments la dérivée, l'état, les paramètres et le temps qui modifie en place la dérivée (et ne renvoie rien)). Celà permet de muter un même objet dérivée `du` à chaque fois que le modèle est appelé, plutôt que de créer un nouvel objet dérivée `du` à chaque appel du modèle (c'est aussi ce qui est fait, différemment, avec les static arrays plus haut).\n\nTypiquement ce type de modèle IIP (en place) s'écrit:\n\n::: {.cell execution_count=20}\n``` {.julia .cell-code}\nfunction mod_rma!(du, u, p, t)\n    return nothing\nend\n```\n:::\n\n\nLa définition du problème d'intégration et l'appel de solve est similaire aux autres méthodes, à ceci près que la condition initiale et la dérivée doit être mutable, ce qui ne permet pas (ou très difficilement) d'utiliser la méthode en dimension 1. En effet une déclaration `u0 = 1.0` ou `du = 3.0` n'est pas mutable^[alors que `u0 = [1.0, 2.0]` ou `du =[2.0, 3.0]` le sont. Plus sur la mutabilité dans les [Julia notes](https://m3g.github.io/JuliaNotes.jl/stable/immutable/).].\n\n",
    "supporting": [
      "annexe_swift_rma_files"
    ],
    "filters": [],
    "includes": {}
  }
}