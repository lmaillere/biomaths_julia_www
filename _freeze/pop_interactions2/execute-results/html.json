{
  "hash": "afb1a25129a007d700064851442c40f8",
  "result": {
    "markdown": "---\ntitle: \"Populations en interaction (2)\"\n---\n\n## Le modèle de Rosenzweig MacArthur {#sec-rma}\n\nNous considérons le modèle de dynamique de populations attribué à Rosenzweig et MacArthur (voir @Rosenzweig1963, @Turchin2003, @Smith2008).\n\n$$\n\\left\\{\\begin{array}{l}\n\\dot x = \\displaystyle rx\\left(1-\\frac{x}{K}\\right) - c \\frac{x}{h+x} y\\\\[.3cm]\n\\dot y = b\\displaystyle \\frac{x}{h+x} y - m y\n\\end{array}\\right.\n$$ {#eq-rma}\n\n### Dynamiques\n\nIl n'y a pas de difficulté particulière à la simulation par rapport au modèle de Lotka Volterra.\n\n::: {.cell execution_count=2}\n``` {.julia .cell-code code-fold=\"true\"}\nusing DifferentialEquations\nusing DataFrames\n\n# conditions initiales\nx0 = 1.0\ny0 = 1.95\netat0 = [x0, y0]\n\n# paramètres\nr = 1.0\nK = 10.0\nc = 1.0\nh = 2.0\nb = 2.0\nm = 1.0\npar_rma = [r, K, c, h, b, m]\n\n# temps d'integration\ntspan = (0.0, 55.0)\ntstep = .01\n\n# définition du modèle\nfunction rma(u, par, t)\n    r, K, c, h, b, m = par\n    x = u[1]\n    y = u[2]\n\n    dx = r*x*(1-x/K) - c*x/(h+x)*y\n    dy = b*x/(h+x)*y - m*y\n\n    return [dx, dy]\nend\n\n# problème d'intégration\nprob_rma = ODEProblem(\n    rma,\n    etat0,\n    tspan,\n    par_rma;\n    saveat = tstep,\n)\n\n# intégration\nsol_rma = solve(prob_rma, reltol = 1e-6)\n\n# dataframe\nsol_rma = DataFrame(sol_rma)\nrename!(sol_rma, :timestamp => :time, :value1 => :x, :value2 => :y)\n```\n:::\n\n\nNous utiliserons ici le package de visualisation graphique `Makie.jl`^[entièrement écrit en `Julia`, présenté comme \"[le futur](https://medium.com/coffee-in-a-klein-bottle/visualizing-data-with-julia-using-makie-7685d7850f06)\" de la représentation graphique avec `Julia`. Une bonne [introduction à Makie](https://juliadatascience.io/DataVisualizationMakie).] à la place de `Plots.jl`. `Makie.jl` permet un contrôle très approfondi des graphiques. Commençons par tracer les dynamiques contre le temps dans une figure simple.\n\nNous utiliserons le backend `CairoMakie` pour la visualisation en 2D.\n\n::: {.cell execution_count=3}\n``` {.julia .cell-code}\nusing CairoMakie\n```\n:::\n\n\nUn peu comme `Matplotlib` en `Python`, `Makie` définit un triplet `FigureAxisPlot` : la figure est le conteneur de (éventuellement) plusieurs systèmes d'axes qui contiennent chacun un ou plusieurs graphiques (ligne, point, etc.).\n\n::: {.cell execution_count=4}\n``` {.julia .cell-code}\n# on crée la figure\nfig1 = Figure(;\n    backgroundcolor = :transparent,\n    size = (600,400),\n    fontsize = 18,\n)\n\n# on crée un système d'axes en position [1,1] dans la figure\nax1 = Axis(\n    fig1[1,1];\n    xlabel = \"temps\",\n    ylabel = \"densités de populations\",\n    title = \"Modèle de Rosenzweig MacArthur\",\n)\n\n# on trace la population x contre le temps sur le système d'axe ax1\nlines!(\n    ax1,\n    sol_rma.time,\n    sol_rma.x;\n    linewidth = 2,\n    linestyle = :solid,\n    label = L\"x(t)\",   # formule Latex dans la chaine de caractère\n)\n\n# on rajoute la population y\nlines!(\n    ax1,\n    sol_rma.time,\n    sol_rma.y;\n    linewidth = 2,\n    linestyle = :solid,\n    label = L\"y(t)\",\n)\n\n# légende\naxislegend(position = :lt)   # position left top\n\n# on affiche la figure, pas de display() ici\nfig1\n```\n\n::: {.cell-output .cell-output-display execution_count=4}\n![Une première figure avec `Makie.jl`](pop_interactions2_files/figure-html/fig-dyn-rma-output-1.svg){#fig-dyn-rma}\n:::\n:::\n\n\n### Dynamiques et plan de phase\n\n#### Préparation de la figure\n\nNous allons maintenant tracer un graphique plus complexe comprenant en colonne de droite les dynamiques des proies et des prédateurs sur deux lignes et en colonne de gauche le plan de phase. Préparons la figure et les systèmes d'axes.\n\n::: {.cell execution_count=5}\n``` {.julia .cell-code}\n# figure\nfig2 = Figure(;\n    backgroundcolor = :transparent,\n    size = (800,500),\n    fontsize = 20,\n)\n\n# 3 systèmes d'axes\n# position 1e ligne 1e colonne\nax21 = Axis(fig2[1,1]; title = \"Dynamiques\")\n\n# position 2e ligne 1e colonne\nax22 = Axis(fig2[2,1]; xlabel = \"temps\")\n\nax23 = Axis(\n    fig2[:,2];       # position toutes les lignes, 2e colonne\n    xlabel = \"proies\",\n    ylabel = \"prédateurs\",\n    title = \"Plan de phase\",\n)\n\n# on agrandi un peu la deuxième colonne de la figure\ncolsize!(fig2.layout, 2, Auto(1.5))\n\n# ajout d'un titre\nsupertitle = Label(\n    fig2[0, :],      # position ligne \"0\" toutes les colonnes\n    \"Modèle de Rosenzweig MacArthur\";\n    fontsize = 30,\n)\n\n# ajout d'un label d'axes commun à la première colonne\nsideinfo = Label(\n    fig2[1:2, 0],    # position toutes les lignes, 1e colonne\n    \"densités de populations\";\n    rotation = π/2,  # \\pi + TAB, pi/2 fonctionne aussi ici\n)\n\n# on affiche la figure\nfig2\n```\n\n::: {.cell-output .cell-output-display execution_count=5}\n![](pop_interactions2_files/figure-html/cell-5-output-1.svg){}\n:::\n:::\n\n\n#### Dynamiques contre le temps\n\nOn rajoute les dynamiques :\n\n::: {.cell execution_count=6}\n``` {.julia .cell-code}\n# la courbe de dynamique de x sur ax21\nlines!(\n    ax21,\n    sol_rma.time,\n    sol_rma.x;\n    color = Cycled(1),  # pick color 1 in the colorcycle\n    linewidth = 2,\n    linestyle = :solid,\n    label = L\"x\",\n)\n\n# légende pour ce système d'axe\naxislegend(ax21, position = :lt, labelsize = 14)\n\n# la courbe de dynamique de y sur ax22\nlines!(\n    ax22,\n    sol_rma.time,\n    sol_rma.y;\n    color = Cycled(2),\n    linewidth = 2,\n    linestyle = :solid,\n    label = L\"y\",\n)\n\n# légende pour ce système d'axe\naxislegend(ax22, position = :lt, labelsize = 14)\n\n# on enlève les labels de l'axe des x de ax21 (redondants)\nhidexdecorations!(ax21, ticks = false)\n\n# affiche la figure\nfig2\n```\n\n::: {.cell-output .cell-output-display execution_count=6}\n![](pop_interactions2_files/figure-html/cell-6-output-1.svg){}\n:::\n:::\n\n\n#### Plan de phase\n\nPassons maintenant au plan de phase dans le dernier système d'axes. Commençons par les isoclines nulles de $\\dot x$ et $\\dot y$ :\n\n::: {.cell execution_count=7}\n``` {.julia .cell-code}\n# calcul des isoclines nulles\n# vecteurs pour le plot\nxplot = LinRange(0.0, K+.1, 30)\nyplot = xplot\n\n# isoclines nulles de xdot\nnull_x_x = ones(length(yplot)).*0        # x = 0 isocline nulle de xdot\nnull_x_y = [r/c*(h+x)*(1-x/K) for x in xplot]  # y = f(x) isocline nulle de xdot\n\n# isoclines nulles de ydot\nnull_y_y = ones(length(xplot)).*0     # y = 0 isocline nulle de ydot\nnull_y_x = [m*h/(b-m) for x in yplot] # x = mh/(b-m) isocline nulle de ydot\n\n# tracé des isoclines nulle de x\nlines!(\n    ax23,\n    null_x_x,\n    yplot;\n    color = Cycled(2),\n    linewidth = 2,\n    linestyle = :solid,\n)\n\nlines!(\n    ax23,\n    xplot,\n    null_x_y;\n    color = Cycled(2),\n    linewidth = 2,\n    linestyle = :solid,\n    label = L\"nullcline de $x$\",\n)\n\n# tracé des isoclines nulle de y\nlines!(\n    ax23,\n    xplot,\n    null_y_y;\n    color = Cycled(3),\n    linewidth = 2,\n    linestyle = :solid,\n)\n\nlines!(\n    ax23,\n    null_y_x,\n    yplot;\n    color = Cycled(3),\n    linewidth = 2,\n    linestyle = :solid,\n    label = L\"nullcline de $y$\",\n)\n```\n:::\n\n\nPuis nous ajoutons les équilibres:\n\n::: {.cell execution_count=8}\n``` {.julia .cell-code}\n# tracé des équilibres\n# équilibre d'extinction\nscatter!(            # scatter pour des points\n    ax23,\n    0,\n    0;\n    color = Cycled(4),\n    label = L\"équilibres$$\",\n)\n\n# prey only\nscatter!(ax23, K, 0, color = Cycled(4))\n\n# équilibre de coexistence\neq_coex = [m*h/(b-m), r/c*(h+m*h/(b-m))*(1-m*h/(b-m)/K)]\n\nscatter!(ax23, eq_coex[1], eq_coex[2]; color = Cycled(4))\n```\n:::\n\n\nPour tracer le champs de vecteurs, nous créons deux vecteurs de coordonnées `x` et `y`, et calculons par compréhension de liste des matrices de taille correspondante indiquant les composantes `x` et `y` des vecteurs vitesse. Les vecteurs de coordonnées et les matrices de composante des vitesses sont ensuite passées comme argument à la fonction `arrows`.\n\n::: {.cell execution_count=9}\n``` {.julia .cell-code}\n# champs de vecteur\nscale = 10           # il faut mettre à l'échelle sinon on voit rien\nxrange = range(1, 10, length=11)\nyrange = range(1. ,10, length=11)\n\n# composantes des vecteurs vitesses par compréhension de liste\nderx = [rma([x y], par_rma, 0)[1]/scale for x in xrange, y in yrange]\ndery = [rma([x y], par_rma, 0)[2]/scale for x in xrange, y in yrange]\n\n# champs de vecteurs\narrows!(\n    ax23,\n    xrange,          # coordonnée x du début d'une flèche\n    yrange,          # coordonnée y du début d'une flèche\n    derx,            # x fin de la flèche (relativement au debut)\n    dery;            # y fin de la flèche (relativement au debut)\n    color = :lightgray,\n    arrowsize = 10,\n)\n```\n:::\n\n\n::: {.callout-caution}\nDans les compréhensions de listes à plusieurs variables/listes, la syntaxe a son importance:\n\n- `[1 for x in xrange, y in yrange]` crée un array de taille `length(xrange)` par `length(yrange)`\n\n- `[1 for x in xrange for y in yrange]` crée un vecteur de taille `length(xrange) + length(yrange)`\n:::\n\n\net enfin la trajectoire :\n\n::: {.cell execution_count=10}\n``` {.julia .cell-code}\n# trajectoire dans le plan de phase\nlines!(\n    ax23,\n    sol_rma.x,\n    sol_rma.y;\n    color = Cycled(1),\n    linewidth = 2,\n    linestyle = :solid,\n    label = L\"trajectoire $$\",\n)\n\n# ajuste l'espacement des colonnes et lignes\ncolgap!(fig2.layout, 20)\nrowgap!(fig2.layout, 20)\n\n# affiche la figure\nfig2\n```\n\n::: {.cell-output .cell-output-display execution_count=10}\n![Une figure plus complexe avec `Makie.jl`](pop_interactions2_files/figure-html/fig-rma-pplane-output-1.svg){#fig-rma-pplane}\n:::\n:::\n\n\n### Diagramme de bifurcations\n<!-- STOP -->\n\nPour finir, nous allons tracer le diagramme de bifurcation du modèle de Rosenzweig MacArthur $y^*$ en fonction de $K$, en identifiant les bifurcations transcritique et de Hopf vues en cours, et en estimant et représentant les extremas du cycle limite apparaissant pour $K$ grand.\n\nPour rappel, il y a 3 situations asymptotiques distinctes pour le modèle de Rosenzweig MacArthur :\n\n- si : $0<K<\\displaystyle\\frac{mh}{b-m}$ : les prédateurs s'éteignent et les proies convergent vers $K$, l'équilibre d'extinction des deux populations est instable.\n\n- si : $\\displaystyle\\frac{mh}{b-m} <K< h+\\frac{2mh}{b-m}$ : proies et prédateurs co-existent à un équilibre globalement asymptotiquement stable, l'équilibre d'extinction des prédateurs est instable, l'équilibre d'extinction des deux populations est instable.\n\n- si : $h+\\displaystyle\\frac{2mh}{b-m}<K$: proies et prédateurs co-existent le long d'un cycle limite globalement asymptotiquement stable, l'équilibre d'extinction des prédateurs est instable, l'équilibre d'extinction des deux populations est instable.\n\n\nDans un premier temps nous allons calculer et représenter les différents équilibres et leur stabilité dans le plan $(K, y)$, puis nous calculerons et rajouterons une représentation du cycle limite.\n\n#### Equilibres\n\nNous faisons une boucle sur les valeurs de $K$ et calculons les équilibres.\n\n::: {.cell execution_count=11}\n``` {.julia .cell-code}\nK_step = 0.1\n\n# before transcritical\nK_plot1 = 0: K_step: m*h/(b-m)\ny_eq01 = ones(length(K_plot1)).*0\n\n# between transcritical and Hopf\nK_plot2 = m*h/(b-m): K_step: h+2*m*h/(b-m)\ny_eq02 = ones(length(K_plot2)).*0\ny_co2 = [r/c*(h+m*h/(b-m))*(1-m*h/(b-m)/K_p) for K_p in K_plot2]  # may have broadcasted\n\n# above Hopf\nK_plot3 = h+2*m*h/(b-m)-K_step/5: (K_step/10) :8\ny_eq03 = ones(length(K_plot3)).*0\ny_co3 = [r/c*(h+m*h/(b-m))*(1-m*h/(b-m)/K_p) for K_p in K_plot3]; # may have broadcasted\n```\n:::\n\n\nEt nous commençons le tracé de la figure :\n\n::: {.cell execution_count=12}\n``` {.julia .cell-code code-fold=\"true\"}\nfig3 = Figure(backgroundcolor = :transparent,\n              size = (600,400),   # size\n              fontsize = 18)\n\n# on crée un système d'axes en position [1,1] dans la figure\nax31 = Axis(fig3[1,1],\n           xlabel = L\"capacité de charge $K$\",\n           ylabel = L\"densité de population $y^*$\",\n           title = \"Diagramme de bifurcations pour le\\n modèle de Rosenzweig MacArthur\")\n\n# on trace la population x\n# left of transcritical\nlines!(ax31, K_plot1, y_eq01,\n       color = Cycled(1),\n       linewidth = 2,\n       label = L\"branche stable$$\")\n\n# between transcritical and Hopf\nlines!(ax31, K_plot2, y_eq02,\n       color = Cycled(2),\n       linewidth = 2,\n       label = L\"branche instable$$\")\n\nlines!(ax31, K_plot2, y_co2,\n       color = Cycled(1),\n       linewidth = 2)\n\n# right of Hopf\nlines!(ax31, K_plot3, y_eq03,\n       color = Cycled(2),\n       linewidth = 2)\n\nlines!(ax31, K_plot3, y_co3,\n       color = Cycled(2),\n       linewidth = 2)\n\nfig3\n```\n\n::: {.cell-output .cell-output-display execution_count=12}\n![](pop_interactions2_files/figure-html/cell-12-output-1.svg){}\n:::\n:::\n\n\n#### Cycle limite\n\nPour estimer le cycle limite pour chaque la valeur de $K$ nous allons simuler le modèle pendant un transitoire assez long, puis repartir de cette valeur de l'état, simuler un cycle et récupérer les extremas pour les tracer. Nous utilisons une méthode basée sur `remake` pour modifier le problème d'intégration^[voir aussi l'[annexe](annexe_integrator.qmd)].\n\n::: {.cell execution_count=13}\n``` {.julia .cell-code}\n# transient integration time\nt_trans = (0.0, 8000.)\n\n# for storage\ni = 1\ny_cmin = zero(K_plot3)\ny_cmax = zero(K_plot3)\n```\n:::\n\n\n::: {.cell execution_count=14}\n``` {.julia .cell-code}\nrma_pbe = ODEProblem(rma, etat0, t_trans, par_rma)\n\n# estimate limit cycle through loop on K\nfor Kc in K_plot3               # loop on K values\n  par_rmac = [r, Kc, c, h, b, m]    # set parameters\n\n  # transient initial value problem; simulation\n  rma_trans_pbe =  remake(rma_pbe, p = par_rmac)\n  # with such arguments `solve` yields only the final value of the simulation\n  post_trans2 = solve(rma_trans_pbe,\n                      save_everystep = false,\n                      save_start = false,\n                      abstol=1e-6, reltol=1e-6)\n\n  # limit cycle initial value problem; simulation\n  rma_cycle_pbe =  remake(rma_pbe,\n                          p = par_rmac,\n                          u0 = post_trans2[:,1],\n                          tspan = tspan,\n                          saveat = tstep)\n\n  sol_cycle = solve(rma_cycle_pbe, abstol=1e-6, reltol=1e-6)\n\n  # get the extrema of y\n  y_cmin[i] = minimum(sol_cycle[2,:])\n  y_cmax[i] = maximum(sol_cycle[2,:])\n\n  i+=1\n  #return post_trans2\nend\n```\n:::\n\n\n#### Diagramme de bifurcations final\n\nFinalement, on inclut les branches calculées dans le diagramme de bifurcations.\n\n::: {.cell execution_count=15}\n``` {.julia .cell-code code-fold=\"true\"}\nlines!(ax31, K_plot3, y_cmin,\n       color = Cycled(3),\n       linewidth = 2,\n       label = L\"cycle limite$$\")\n\nlines!(ax31, K_plot3, y_cmax,\n       color = Cycled(3),\n       linewidth = 2)\n\naxislegend(ax31, position = :lt, labelsize = 14)\n\nfig3\n```\n\n::: {.cell-output .cell-output-display execution_count=15}\n![Diagramme de bifurcations du modèle de Rosenzweig MacArthur.](pop_interactions2_files/figure-html/fig-bifurcation-rma-output-1.svg){#fig-bifurcation-rma}\n:::\n:::\n\n\n\\\n\nThat’s all folks!\n\n",
    "supporting": [
      "pop_interactions2_files"
    ],
    "filters": [],
    "includes": {
      "include-in-header": [
        "<script src=\"https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js\" integrity=\"sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==\" crossorigin=\"anonymous\"></script>\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js\" integrity=\"sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==\" crossorigin=\"anonymous\"></script>\n<script type=\"application/javascript\">define('jquery', [],function() {return window.jQuery;})</script>\n"
      ]
    }
  }
}