---
title: "Populations exploitées"
---


## Prélèvements et effets Allee {#sec-allee-prelev}

Nous reprenons le modèle précédent sur l'effet Allee mais en prenant en compte des prélèvements externes avec un effort (taux) de prélèvement $E$ :
$$
\dot x = r x \left(\frac{x}{\epsilon}-1\right)\left(1-\frac{x}{K}\right)-Ex.
$$ {#eq-alleeprelev}

La simulation de ce modèle pour différentes valeurs de $E$ (par exemple $E=0.2$ ou $E=0.85$) ne présente aucune difficulté supplémentaire.

Nous allons maintenant nous intéresser à une situation où l'effort de prélèvement $E$ varie au cours du temps entre une valeur soutenable $E_s$ (par exemple $0.2$), et une valeur excessive $E_x$ (par exemple $0.85$). 

L'attendu théorique est que si les prélèvements sont maintenus à une valeur excessive $E_x$ trop longtemps, la population disparait irrémédiablement même si les prélèvements sont par la suite ramenés à une valeur initialement soutenable $E_s$.

### Prélèvements variables dans le temps

```{julia}
using DifferentialEquations, Plots
```



Définissons une fonction `effort()` dépendant du temps, qui renvoit :

- $E_s~$ si $~t<T_s$
- $E_x~$ si $~t\in [T_s+T_x[$
- à nouveau $E_s~$ si $~t\geq T_s+T_x$

```{julia}
# paramètres
E_s = 0.2
E_x = 0.85
T_s = 10.0
T_x = 9.0

par_effort = [E_s, E_x, T_s, T_x]

function effort(t, pars)
    E_s, E_x, T_s, T_x = pars

    if t < T_s || t >= T_s + T_x
        return E_s
    elseif t >= T_s && t < T_s + T_x
        return E_x
    end
end
```

La fonction correspond bien à nos hypothèses :
```{julia}
#| output: true
#| code-fold: true
time2plot = 0: .1: 30

plot(time2plot, [effort(t, par_effort) for t in time2plot],
     palette = :tab10,
     linewidth = 2,
     label = "\$E(t)\$",
     xlabel = "temps",
     ylabel = "\$E(t)\$",
     title = "Effort de pêche \$E(t)\$",
     margin = .5Plots.cm,
     topmargin = 1Plots.cm)
```

### Simulation en fonction du temps

Nous définissons les paramètres du modèle, la condition initiale et le temps d'intégration :
```{julia}
x0 = 10.

tspan = (0.0, 30.0)
tstep = 0.1

r = 1.
K = 10.
epsilon = 2.                 # seuil de Allee
par_allee = [r, K, epsilon] # packing
tspan_allee = (0.0, 3.0)
```


Nous définissons le système dynamique comme précédemment, à la différence que nous prévoyons de surcharger l'argument `p` dans le problème d'intégration sous forme d'un vecteur comprennant :

- le vecteur de paramètres `par_allee` en première position
- le vecteur de paramètres `par_effort` en seconde position
- et la fonction `effort` en troisième position

```{julia}
function allee_evar(u, p, t)
    r, K, epsilon = p[1]        # unpacking model parameters
    par_effort = p[2]           # unpacking fishing effort parameters
    E = p[3]                    # unpacking fishing effort function
    x = u[1]                    # use x notation
    
    dx = r*x*(x/epsilon - 1)*(1 - x/K) - E(t, par_effort)*x
end
```


L'intégration en elle-même suit le shéma vu précédemment, si ce n'est que l'argument de paramètres doit bien refléter ce qui est attendu par la fonction `allee_evar()`. La simulation en elle-même est effectuée avec une modification de la précision relative de l'intégration `reltol = 1e-6`, la précision par défaut n'étant pas suffisante ici.
```{julia}
prob_allee_evar = ODEProblem(allee_evar, 
                             x0, 
                             tspan, 
                             [par_allee, par_effort, effort], 
                             saveat = tstep)

sol_allee_evar = solve(prob_allee_evar, reltol = 1e-6)
```

Finalement, nous pouvons représenter graphiquement la solution contre le temps. Ici, on choisit de ne pas passer par un dataframe, pour illustration.

```{julia}
#| output: true

plot(sol_allee_evar,
     label = "\$x(t)\$",
     linewidth = 2,
     xlabel = "temps",
     ylabel = "densité de population \$x(t)\$",
     title = "Effort de pêche variant dans le temps",
     palette = :tab10,
     legend = :left,
     margin = .5Plots.cm,
     topmargin = 1Plots.cm)
```