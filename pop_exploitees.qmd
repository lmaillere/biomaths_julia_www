---
title: "Populations exploitées"
---


## Prélèvements et effets Allee {#sec-allee-prelev}

Nous reprenons le modèle précédent sur l'effet Allee mais en prenant en compte des prélèvements externes avec un effort (taux) de prélèvement $E$ :
$$
\dot x = r x \left(\frac{x}{\epsilon}-1\right)\left(1-\frac{x}{K}\right)-Ex.
$$ {#eq-alleeprelev}

La simulation de ce modèle pour différentes valeurs de $E$ (par exemple $E=0.2$ ou $E=0.85$) ne présente aucune difficulté supplémentaire.

Nous allons maintenant nous intéresser à une situation où l'effort de prélèvement $E$ varie au cours du temps entre une valeur soutenable $E_s$ (par exemple $0.2$), et une valeur excessive $E_x$ (par exemple $0.85$). 

L'attendu théorique est que si les prélèvements sont maintenus à une valeur excessive $E_x$ trop longtemps, la population disparait irrémédiablement même si les prélèvements sont par la suite ramenés à une valeur initialement soutenable $E_s$.

### Prélèvements variables dans le temps

```{julia}
using DifferentialEquations, Plots, DataFrames
```



Définissons une fonction `effort()` dépendant du temps, qui renvoit :

- $E_s~$ si $~t<T_s$
- $E_x~$ si $~t\in [T_s+T_x[$
- à nouveau $E_s~$ si $~t\geq T_s+T_x$

```{julia}
# paramètres
E_s = 0.2
E_x = 0.85
T_s = 10.0
T_x = 9.0

par_effort = [E_s, E_x, T_s, T_x]

function effort(t, pars)
    E_s, E_x, T_s, T_x = pars

    if t < T_s || t >= T_s + T_x
        return E_s
    elseif t >= T_s && t < T_s + T_x
        return E_x
    end
end
```

La fonction correspond bien à nos hypothèses :
```{julia}
#| output: true
#| code-fold: true
time2plot = 0: .1: 30

plot(time2plot, [effort(t, par_effort) for t in time2plot],
     palette = :tab10,
     linewidth = 2,
     label = "\$E(t)\$",
     xlabel = "temps",
     ylabel = "\$E(t)\$",
     title = "Effort de pêche \$E(t)\$",
     margin = .5Plots.cm,
     topmargin = 1Plots.cm)
```

### Simulation en fonction du temps

Nous définissons les paramètres du modèle, la condition initiale et le temps d'intégration :
```{julia}
#| code-fold: true
x0 = 10.

tspan = (0.0, 30.0)
tstep = 0.1

r = 1.
K = 10.
epsilon = 2.                 # seuil de Allee
par_allee = [r, K, epsilon] # packing
tspan_allee = (0.0, 3.0)
```


Nous définissons le système dynamique comme précédemment, à la différence que nous prévoyons de surcharger l'argument `p` dans le problème d'intégration sous forme d'un vecteur comprennant :

- le vecteur de paramètres `par_allee` en première position
- le vecteur de paramètres `par_effort` en seconde position
- et la fonction `effort` en troisième position

```{julia}
function allee_evar(u, p, t)
    r, K, epsilon = p[1]        # unpacking model parameters
    par_effort = p[2]           # unpacking fishing effort parameters
    E = p[3]                    # unpacking fishing effort function
    x = u[1]                    # use x notation
    
    dx = r*x*(x/epsilon - 1)*(1 - x/K) - E(t, par_effort)*x
end
```


L'intégration en elle-même suit le shéma vu précédemment, si ce n'est que l'argument de paramètres doit bien refléter ce qui est attendu par la fonction `allee_evar()`. La simulation en elle-même est effectuée avec une modification de la précision relative de l'intégration `reltol = 1e-6`, la précision par défaut n'étant pas suffisante ici.
```{julia}
prob_allee_evar = ODEProblem(allee_evar, 
                             x0, 
                             tspan, 
                             [par_allee, par_effort, effort], 
                             saveat = tstep)

sol_allee_evar = solve(prob_allee_evar, reltol = 1e-6)

sol_allee_evar = DataFrame(sol_allee_evar)
rename!(sol_allee_evar, :timestamp => :time, :value => :x)
```

Finalement, nous pouvons représenter graphiquement la solution contre le temps. Ici, malgré la perturbation violente induite par la période de surexploitation, le pêcherie retrouve une situation soutenable après un retour à $E=E_s$. 

```{julia}
#| output: true
#| code-fold: true
#| label: fig-allee_pers
#| fig-cap: Persistence dans le modèle avec effet Allee et prélèvements

plot(sol_allee_evar.time, sol_allee_evar.x,
     label = "\$x(t)\$",
     linewidth = 2,
     xlabel = "temps",
     ylabel = "densité de population \$x(t)\$",
     title = "Effort de pêche variant dans le temps",
     palette = :tab10,
     legend = :left,
     margin = .5Plots.cm,
     topmargin = 1Plots.cm)
```
\

Lorsque la période de surexploitation de la population est trop longue (e.g. ici $T_x=9.2$), la population ne parvient pas à récupérer malgré le retour à un effort de prélèvements soutenable.

```{julia}
#| output: true
#| code-fold: true
#| label: fig-allee_ext
#| fig-cap: Extinction dans le modèle avec effet Allee et prélèvements

# change parameter
T_x2 = 9.2

par_effort2 = [E_s, E_x, T_s, T_x2]

# define new problem and integrate
prob_allee_evar2 = ODEProblem(allee_evar, 
                             x0, 
                             tspan, 
                             [par_allee, par_effort2, effort], 
                             saveat = tstep)

sol_allee_evar2 = solve(prob_allee_evar2, reltol = 1e-7)

sol_allee_evar2 = DataFrame(sol_allee_evar2)
rename!(sol_allee_evar2, :timestamp => :time, :value => :x)

# plot
plot(sol_allee_evar2.time, sol_allee_evar2.x,
     label = "\$x(t)\$",
     linewidth = 2,
     xlabel = "temps",
     ylabel = "densité de population \$x(t)\$",
     title = "Effort de pêche variant dans le temps",
     palette = :tab10,
     legend = :left,
     margin = .5Plots.cm,
     topmargin = 1Plots.cm)
```

### Simulation dans l'espace $(E, x)$

Il s'agit ici de représenter dans l'espace $(E, x)$ l'évolution conjointe de l'effort de pêche et de la densité de la population au cours du temps, afin de mieux comprendre le phénomène d'extinction. Dans cet objectif, on tracera aussi le lieu des équilibres de la population $x^*(E)$ en fonction d'une valeur de $E$ constante, i.e. :
$$
x^*(E) = 0,
$$
ou :
$$
E = r\left(\frac{x^*(E)}{\epsilon}-1\right)\left(1-\frac{x^*(E)}{K}\right).
$$

Nous allons tracer les situations dans 2 sous figures. Commençons par les lieux des équilibres :
```{julia}
#| output: true
# vecteurs pour le tracé
e2plot = 0:.1:1
x2plot1 = epsilon:.02:(K+epsilon)/2
x2plot2 = (K+epsilon)/2:.02:K

# parabole pour les equilibres positifs
function eeqpos(x, par = par_allee)
        r, K, epsilon = par

        r*(x/epsilon -1)*(1-x/K)
end

# on définit des couleurs spécifiques depuis la palette :pal10
mygreen = palette(:tab10)[3]
myorange = palette(:tab10)[2]
myblue = palette(:tab10)[1]

# plot
P1 = plot(e2plot, zeros(length(e2plot)),
          color = mygreen,
          linewidth = 2,
          label = "équilibres stables",
          ylabel = "densité de population \$x\$",
          xlabel = "effort de pêche \$E\$",
          legend = :left)
        #   margin = .5Plots.cm,
        #   topmargin = 1Plots.cm)

plot!(P1, eeqpos.(x2plot1), x2plot1, 
          color= myorange,
          linewidth = 2,
          label = "équilibre instable")

plot!(P1, eeqpos.(x2plot2), x2plot2, 
          color= mygreen,
          linewidth = 2,
          label ="")

display(P1)
```
\

On prépare un graphique `P2` avec les mêmes éléments :
```{julia}
P2 = deepcopy(P1) # évite de tout retaper...
```

On complète `P1` et `P2` avec quelques annotations et les trajectoires calculées plus haut en fonction de l'effort de pêche variable au cours du temps, et on trace les résultats en deux sous-figures :



```{julia}
#| output: true
#| label: fig-alleebif
#| fig-cap: bifurcation pli et catastrophe dans le modèle avec effet Allee et prélèvements

annotate!(P1, .35, 8.5, Plots.text("branche stable", 10, rotation=-28))
annotate!(P1, .4, 2.7, Plots.text("branche instable", 10, rotation=28))
annotate!(P2, .4, 2.7, Plots.text("branche instable", 10, rotation=28))
annotate!(P2, .35, 8.5, Plots.text("branche stable", 10, rotation=-28))

plot!(P1, [effort(t, par_effort) for t in sol_allee_evar.time], sol_allee_evar.x,
      color = myblue, 
      linewidth = 2,
      label = "trajectory")

plot!(P2, [effort(t, par_effort2) for t in sol_allee_evar2.time], sol_allee_evar2.x,
      color = myblue, 
      linewidth = 2,
      label = "trajectory")

plot(P1, P2, suptitle = "Effets Allee et prélèvements",
     margin = .5Plots.cm,
     topmargin = 1Plots.cm)
``` 