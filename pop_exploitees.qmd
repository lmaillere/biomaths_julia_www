---
title: "Populations exploitées"
---


## Prélèvements et effets Allee {#sec-allee-prelev}

Nous reprenons le modèle précédent sur l'effet Allee mais en prenant en compte des prélèvements externes avec un effort (taux) de prélèvement $E$ :
$$
\dot x = r x \left(\frac{x}{\epsilon}-1\right)\left(1-\frac{x}{K}\right)-Ex.
$$ {#eq-alleeprelev}

La simulation de ce modèle pour différentes valeurs de $E$ (par exemple $E=0.2$ ou $E=0.85$) ne présente aucune difficulté supplémentaire.

Nous allons maintenant nous intéresser à une situation où l'effort de prélèvement $E$ varie au cours du temps entre une valeur soutenable $E_s$ (par exemple $0.2$), et une valeur excessive $E_x$ (par exemple $0.85$). 

L'attendu théorique est que si les prélèvements sont maintenus à une valeur excessive $E_x$ trop longtemps, la population disparait irrémédiablement même si les prélèvements sont par la suite ramenés à une valeur initialement soutenable $E_s$.

### Prélèvements variables dans le temps

```{julia}
using DifferentialEquations, Plots, DataFrames
```



Définissons une fonction `effort()` dépendant du temps, qui renvoit :

- $E_s~$ si $~t<T_s$
- $E_x~$ si $~t\in [T_s+T_x[$
- à nouveau $E_s~$ si $~t\geq T_s+T_x$

```{julia}
# paramètres
E_s = 0.2
E_x = 0.85
T_s = 10.0
T_x = 9.0 

par_effort = [E_s, E_x, T_s, T_x]

function effort(t, pars)
    E_s, E_x, T_s, T_x = pars

    if t < T_s || t >= T_s + T_x
        return E_s
    elseif t >= T_s && t < T_s + T_x
        return E_x
    end
end
```

La fonction correspond bien à nos hypothèses :
```{julia}
#| output: true
#| code-fold: true
time2plot = 0: .1: 30

plot(time2plot, [effort(t, par_effort) for t in time2plot],
     palette = :tab10,
     linewidth = 2,
     label = "\$E(t)\$",
     xlabel = "temps",
     ylabel = "\$E(t)\$",
     title = "Effort de pêche \$E(t)\$",
     margin = .5Plots.cm,
     topmargin = 1Plots.cm)
```

### Simulations en fonction du temps

Nous définissons les paramètres du modèle, la condition initiale et le temps d'intégration :
```{julia}
#| code-fold: true
x0 = 10.

tspan = (0.0, 30.0)
tstep = 0.1

r = 1.
K = 10.
epsilon = 2.                 # seuil de Allee
par_allee = [r, K, epsilon] # packing
tspan_allee = (0.0, 3.0)
```


Nous définissons le système dynamique comme précédemment, à la différence que nous prévoyons de surcharger l'argument `p` dans le problème d'intégration sous forme d'un vecteur comprennant :

- le vecteur de paramètres `par_allee` en première position
- le vecteur de paramètres `par_effort` en seconde position
- et la fonction `effort` en troisième position

```{julia}
function allee_evar(u, p, t)
    r, K, epsilon = p[1]        # unpacking model parameters
    par_effort = p[2]           # unpacking fishing effort parameters
    E = p[3]                    # unpacking fishing effort function
    x = u[1]                    # use x notation
    
    dx = r*x*(x/epsilon - 1)*(1 - x/K) - E(t, par_effort)*x
end
```


L'intégration en elle-même suit le shéma vu précédemment, si ce n'est que l'argument de paramètres doit bien refléter ce qui est attendu par la fonction `allee_evar()`. La simulation en elle-même est effectuée avec une modification de la précision relative de l'intégration `reltol = 1e-6`, la précision par défaut n'étant pas suffisante ici.
```{julia}
prob_allee_evar = ODEProblem(allee_evar, 
                             x0, 
                             tspan, 
                             [par_allee, par_effort, effort], 
                             saveat = tstep)

sol_allee_evar = solve(prob_allee_evar, reltol = 1e-6)

sol_allee_evar = DataFrame(sol_allee_evar)
rename!(sol_allee_evar, :timestamp => :time, :value => :x)
```

Finalement, nous pouvons représenter graphiquement la solution contre le temps. Ici, malgré la perturbation violente induite par la période de surexploitation, le pêcherie retrouve une situation soutenable après un retour à $E=E_s$. 

```{julia}
#| output: true
#| code-fold: true
#| label: fig-allee_pers
#| fig-cap: Persistence dans le modèle avec effet Allee et prélèvements

plot(sol_allee_evar.time, sol_allee_evar.x,
     label = "\$x(t)\$",
     linewidth = 2,
     xlabel = "temps",
     ylabel = "densité de population \$x(t)\$",
     title = "Effort de pêche variant dans le temps",
     palette = :tab10,
     legend = :left,
     margin = .5Plots.cm,
     topmargin = 1Plots.cm)
```
\

Lorsque la période de surexploitation de la population est trop longue (e.g. ici $T_x=9.2$), la population ne parvient pas à récupérer malgré le retour à un effort de prélèvements soutenable.

```{julia}
#| output: true
#| code-fold: true
#| label: fig-allee_ext
#| fig-cap: Extinction dans le modèle avec effet Allee et prélèvements

# change parameter
T_x2 = 9.2

par_effort2 = [E_s, E_x, T_s, T_x2]

# define new problem and integrate
prob_allee_evar2 = ODEProblem(allee_evar, 
                             x0, 
                             tspan, 
                             [par_allee, par_effort2, effort], 
                             saveat = tstep)

sol_allee_evar2 = solve(prob_allee_evar2, reltol = 1e-6)

sol_allee_evar2 = DataFrame(sol_allee_evar2)
rename!(sol_allee_evar2, :timestamp => :time, :value => :x)

# plot
plot(sol_allee_evar2.time, sol_allee_evar2.x,
     label = "\$x(t)\$",
     linewidth = 2,
     xlabel = "temps",
     ylabel = "densité de population \$x(t)\$",
     title = "Effort de pêche variant dans le temps",
     palette = :tab10,
     legend = :left,
     margin = .5Plots.cm,
     topmargin = 1Plots.cm)
```

### Simulations dans l'espace $(E, x)$

Il s'agit ici de représenter dans l'espace $(E, x)$ l'évolution conjointe de l'effort de pêche et de la densité de la population au cours du temps, afin de mieux comprendre le phénomène d'extinction. Dans cet objectif, on tracera aussi le lieu des équilibres de la population $x^*(E)$ en fonction d'une valeur de $E$ constante, i.e. :
$$
x^*(E) = 0,
$$
ou :
$$
E = r\left(\frac{x^*(E)}{\epsilon}-1\right)\left(1-\frac{x^*(E)}{K}\right).
$$

Nous allons tracer les situations dans 2 sous figures. Commençons par les lieux des équilibres :
```{julia}
#| output: true
# vecteurs pour le tracé
e2plot = 0:.1:1
x2plot1 = epsilon:.02:(K+epsilon)/2
x2plot2 = (K+epsilon)/2:.02:K

# parabole pour les equilibres positifs
function eeqpos(x, par = par_allee)
        r, K, epsilon = par

        r*(x/epsilon -1)*(1-x/K)
end

# on définit des couleurs spécifiques depuis la palette :pal10
mygreen = palette(:tab10)[3]
myorange = palette(:tab10)[2]
myblue = palette(:tab10)[1]
myred = palette(:tab10)[4]

# plot
P1 = plot(e2plot, zeros(length(e2plot)),
          color = mygreen,
          linewidth = 2,
          label = "équilibres stables",
          ylabel = "densité de population \$x\$",
          xlabel = "effort de pêche \$E\$",
          legend = :left)
        #   margin = .5Plots.cm,
        #   topmargin = 1Plots.cm)

plot!(P1, eeqpos.(x2plot1), x2plot1, 
          color= myorange,
          linewidth = 2,
          label = "équilibre instable")

plot!(P1, eeqpos.(x2plot2), x2plot2, 
          color= mygreen,
          linewidth = 2,
          label ="")

display(P1)
```
\

On prépare un graphique `P2` avec les mêmes éléments :
```{julia}
P2 = deepcopy(P1) # évite de tout retaper...
```

On complète `P1` et `P2` avec quelques annotations et les trajectoires calculées plus haut en fonction de l'effort de pêche variable au cours du temps, et on trace les résultats en deux sous-figures :



```{julia}
#| output: true
#| label: fig-alleebif
#| fig-cap: bifurcation pli et catastrophe dans le modèle avec effet Allee et prélèvements

annotate!(P1, .35, 8.5, Plots.text("branche stable", 10, rotation=-28))
annotate!(P1, .4, 2.7, Plots.text("branche instable", 10, rotation=28))
annotate!(P2, .4, 2.7, Plots.text("branche instable", 10, rotation=28))
annotate!(P2, .35, 8.5, Plots.text("branche stable", 10, rotation=-28))

plot!(P1, [effort(t, par_effort) for t in sol_allee_evar.time], sol_allee_evar.x,
      color = myblue, 
      linewidth = 2,
      label = "trajectory")

plot!(P2, [effort(t, par_effort2) for t in sol_allee_evar2.time], sol_allee_evar2.x,
      color = myblue, 
      linewidth = 2,
      label = "trajectory")

plot(P1, P2, suptitle = "Effets Allee et prélèvements",
     margin = .5Plots.cm,
     topmargin = 1Plots.cm)
``` 

## La tordeuse du bourgeon de l'épinette


### Modèle

Nous considérons le modèle de dynamique de populations suivant, inspiré de @ludwig1978 :

$$
\dot x =rx\left(1-\frac{x}{K}\right) - \frac{\alpha x^2}{h^2+x^2}\ y,
$$ {#eq-tordeuse}

avec $x$ la densité de tordeuses et $y$ la densité d'oiseaux. La croissance des tordeuses suit une loi logistique et la prédation des oiseaux une réponse fonctionnelle de type Holling III.


### Simulations

On procède classiquement, en ajustant les valeurs de paramètres pour mettre en évidence les phénomènes dynamiques attendus :

```{julia}
# paramètres
r = 5.0      # natalité
K = 10.0     # mortalité
α = 1.0      # taux max de prédation
h = 0.5      # constante de demi-saturation
yc = 7.0     # densité de prédateurs

par_tordeuse = [r, K, α, h, yc] 

# temps d'intégration
tspan = (0.0, 3.0)
tstep = 0.02
```

Puis on définit le modèle :
```{julia}
function tordeuse(u, p, t)
    r, K, α, h, yc = p
    x = u[1]
    dx = r*x*(1 - x/K) - α*x^2/(h^2 + x^2)*yc
end
```

Comme pour le modèle avec effets Allee, on définit une fonction qui simule et renvoit la solution pour pouvoir illustrer la bi-stabilité :
```{julia}
function int_tordeuse(x0, tspan = tspan, param = par_tordeuse)
    prob_tordeuse = ODEProblem(tordeuse,       # modèle
                               x0,               # condition initiale
                               tspan,            # tspan
                               param,            # paramètres
                               saveat = tstep)   # option de sortie
    
    sol_tordeuse = solve(prob_tordeuse)
    sol_tordeuse = DataFrame(sol_tordeuse)
    rename!(sol_tordeuse, :timestamp => :time, :value => :x)
end
```


Nous simulons le modèle depuis différentes conditions intiales, et traçons les résultats via une boucle.
```{julia}
#| output: true
# conditions initiales
x0step = 1.35
x0vec = x0step:x0step:K

# custom color palette
init_cgrad = palette([:steelblue, :lightblue], length(x0vec))

# initialisation du graphique, équilibre nul
P = plot(palette = init_cgrad,
         legend = :right, 
         label ="équilibres instables",
         title = "Tordeuse du bourgeon de l\'épinette",
         ylabel = "densité de population \$x(t)\$", 
         xlabel = "temps \$t\$",
         margin = .5Plots.cm,
         topmargin = 1Plots.cm)

# boucle de plot avec intégration pour differentes conditions initiales
for x0 in x0vec
    plot!(P, int_tordeuse(x0).time, int_tordeuse(x0).x,
          linewidth = 2,
          label = "")
end

display(P)      # actually shows the plot P
```


### Equilibres

Les valeurs des équilibres positifs du modèle @eq-tordeuse n'ont pas d'écriture mathématique simple. Nous allons calculer numériquement les racines du polynôme dont ils sont solution :
$$
r\left(1-\frac{x^*}{K}\right)\left(h^2+x^{*2}\right)-\alpha x^* y = 0
$$ {#eq-eq-tordeuse}

Pour cela, on utilise le package `Polynomials.jl` :
```{julia}
#| output: true
using Polynomials

# définition du monôme X
X = Polynomial([0, 1])

# définition du polynôme 
pol = r*(1-X/K)*(h^2 + X^2)-α*X*yc

# calcul des racines, réelles, positives et plus petites que K
eq_pos = roots(pol)                         # calcul des racines
eq_pos = real.(eq_pos[isreal.(eq_pos)])     # filtrage des racines réelles
eq_pos = eq_pos[(eq_pos .> 0) .& (eq_pos .<= K)] # filtrage des racines >0 et <K
```

Et on trace les différents équilibres :
```{julia}
#| output: true
#| label: fig-tordeuse-temps
#| fig-cap: bistabilité dans le modèle de la tordeuse du bourgeon de l'épinette
t2plot = collect(tspan)

# initialisation du graphique, équilibre nul
plot!(P, t2plot, zeros(length(t2plot)), 
         lw=2, 
         linestyle = :dash, 
         color = myorange, 
         palette = init_cgrad,
         legend = :right, 
         label ="équilibres instables",
         ylabel = "densité de population \$x(t)\$", 
         xlabel = "temps \$t\$",
         margin = .5Plots.cm,
         topmargin = 1Plots.cm)

# équilibres positifs
if length(eq_pos) == 1
    plot!(P, t2plot, ones(length(t2plot)).*eq_pos, 
          color = mygreen, 
          label ="équilibre stable")
elseif length(eq_pos) == 3
    plot!(P, t2plot, ones(length(t2plot)).*eq_pos[1], 
          lw=2, 
          linestyle = :dash, 
          color = mygreen, 
          label ="équilibres stables")
    plot!(P, t2plot, ones(length(t2plot)).*eq_pos[2], 
          lw=2, 
          linestyle = :dash, 
          color = myorange, 
          label = "")
    plot!(P, t2plot, ones(length(t2plot)).*eq_pos[3], 
          lw=2, 
          linestyle = :dash, 
          color = mygreen, 
          label = "")
end
```

### Diagramme de bifurcations 

Finalement nous traçons dans le plan $(y, x)$ le lieu des points d'équilibres en fonction de la taille de la population d'oiseaux:

$$
y = \frac{r}{\alpha x^*}\left(1-\frac{x^*}{K}\right)(h^2+x^{*2})
$${#eq-lieutordeuse}


Comme nous l'avons vu en cours cette fonction est non monotone avec une branche décroissante, une branche croissante puis à nouveau une branche décroissante, le sens de variation déterminant la stabilité de l'équilibre correspondant.

Pour déterminer ces différentes branches et les représenter de différentes couleurs de façon à illustrer leur stabilité, nous allons dériver l'@eq-lieutordeuse par rapport à $x^*$ en utilisant le package `Symbolics.jl` et chercher les racines de la dérivée^[si l'@eq-lieutordeuse avait été un polynôme nous aurions utilisé les outils pour les polynômes, mais il s'agit d'une fraction rationnelle].

```{julia}
#| output: true
using Symbolics

@variables X
D = Differential(X)

Y = r/(α*X)*(1-X/K)*(h^2+X^2)
```

Les racines de la dérivée, sont les racines du numérateur de la dérivée, donc on dérive, et on récupère ce numérateur:
```{julia}
#| output: true
dnumerator = Symbolics.arguments(Symbolics.value(simplify(expand_derivatives(D(Y)))))[1]
dnumerator
```

Comme ce numérateur est un polynôme, on peut utiliser le polynôme symbolique de `Symbolics.jl` pour regénérer un polynôme et utiliser la méthode `roots()` de `Polynomials.jl`^[il faut l'admettre, ce serait plus simple d'avoir directement une façon de trouver les racines d'un polynôme symbolique, mais ça ne semble pas implanté pour l'instant (fin 2023)]

```{julia}
# on récupère les coefficients X^k du polynôme
coefs_dict = Symbolics.value(dnumerator).dict
dd = Dict(Symbolics.degree(first(kv)) => kv[2] for kv ∈ coefs_dict)

# on rajoute dans le dictionnaire le coefficient constant
dd[0] = substitute(dnumerator, Dict(X=>0))

# on définit le polynôme à partir du dictionnaire
dnumpoly = SparsePolynomial(dd, :X)

# on calcule les solutions en filtrant les racines entre 0 et K via une fonction anonyme s-> K > s > 0
droots = filter(s -> K > s > 0, roots(dnumpoly))
```

On calcule les branches correspondantes et on peut les tracer dans le plan $(y,x)$ pour illustrer le diagramme de bifurcations.

```{julia}
#| output: true
#| label: fig-tordeuse-bif
#| fig-cap: bifurcations dans le modèle de la tordeuse du bourgeon de l'épinette
# on calcule chacune des branches
xplot1 = 0.08:.01:droots[1]
xplot2 = droots[1]:.01:droots[2]
xplot3 = droots[2]:.01:K
yeq1 = r.*(1 .-xplot1./K) ./ (α.*xplot1).*(h^2 .+xplot1.^2)
yeq2 = r.*(1 .-xplot2./K) ./ (α.*xplot2).*(h^2 .+xplot2.^2)
yeq3 = r.*(1 .-xplot3./K) ./ (α.*xplot3).*(h^2 .+xplot3.^2)

# diagramme de bifurcations
Pbif = plot(yeq1, xplot1,
            linewidth = 2,
            color = mygreen,
            label = "équilibres stables",
            legend = :left,
            xlabel = "population d'oiseaux \$y\$",
            ylabel = "population de tordeuses \$x\$",
            title = "Diagramme de bifurcations pour le modèle de tordeuses",
            margin = .5Plots.cm,
            topmargin = 1Plots.cm)

plot!(Pbif, yeq2, xplot2,
      linewidth = 2,
      color = myred,
      label = "équilibres instables")

plot!(Pbif, yeq3, xplot3,
      linewidth = 2,
      color = mygreen,
      label = "")

plot!(Pbif, [0, maximum(yeq1)], [0, 0], 
      color = myred,
      lw = 2,
      label = "")
```






Nous verrons sur la page des [populations en interactions](pop_interactions.qmd) le cas où la population d'oiseaux varie lentement au cours du temps.