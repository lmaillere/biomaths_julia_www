---
title: "Populations en interaction (1)"
---

## La tordeuse du bourgeon de l'épinette (suite)

Pour débuter cette partie sur les populations en interactions, nous reprenons le modèle de tordeuse de @ludwig1978 en supposant que la population d'oiseaux réagit (lentement) à la démographie des tordeuses, via la prédation.

Le changement principal ici est la dimension du modèle (dimension 2) :  les tailles de populations de tordeuses $x$ et d'oiseaux $y$ varient toutes deux au cours du temps en s'influençant l'une l'autre, avec une population d'oiseaux qui varie lentement (d'où le paramètre $\varepsilon$).

Le modèle prend la forme :		 			
$$ 
\left\{
\begin{array}{l}
\displaystyle \dot x = rx\left(1-\frac{x}{K}\right) - \frac{\alpha x^2}{h^2+x^2}\ y \\[.3cm]
\displaystyle \dot y = \varepsilon \left(\frac{n \alpha x^2}{h^2+x^2}\ y -m y\right)
\end{array}
\right.
$$ {#eq-tordeuse-yvar}

Il faut ajuster un peu la manière de coder pour prendre en compte ces deux dimensions. Commençons par les paramètres divers.
```{julia}
using DifferentialEquations, Plots, DataFrames

# paramètres
r = 5.0      # natalité
K = 10.0     # mortalité
α = 1.0      # taux max de prédation
h = 0.5      # constante de demi-saturation

ϵ = 0.01     # timescale
n = 5.0      # gain à la prédation
m = 3.0      # moralité


par_tord_ois = [r, K, α, h, ϵ, n, m] 

# temps d'intégration
tspan = (0.0, 400.0)
tstep = 0.02

# conditions initiales
x0 = 1.0    # tordeuses
y0 = 2.5    # oiseaux
etat0 = [x0, y0]
```

Puis le modèle :
```{julia}
function tord_ois(u, param, t)
    r, K, α, h, ϵ, n, m = param
    x = u[1]
    y = u[2]
    dx = r*x*(1 - x/K) - α*x^2/(h^2 + x^2) * y
    dy = ϵ*(n*α*x^2/(h^2 + x^2) * y - m * y)
    [dx, dy]
end
```

Problème d'intégration et simulation :
```{julia}
prob_tord_ois = ODEProblem(tord_ois, 
                           etat0, 
                           tspan, 
                           par_tord_ois, 
                           saveat = tstep)

sol_tord_ois = solve(prob_tord_ois, reltol = 1e-6)

sol_tord_ois = DataFrame(sol_tord_ois)
rename!(sol_tord_ois, :timestamp => :time, :value1 => :x, :value2 => :y)
```

Représentation graphique contre le temps
```{julia}
#| output: true
# color definitions
mygreen = palette(:tab10)[3]
myorange = palette(:tab10)[2]
myblue = palette(:tab10)[1]
myred = palette(:tab10)[4]

P1 = plot(sol_tord_ois.time, sol_tord_ois.x,
          color = myblue,
          linewidth = 2,
          label = "tordeuses \$x\$",
          xlabel = "temps",
          ylabel = "densités de populations",
          title = "Dynamiques des tordeuses avec\n population d'oiseaux variable")

plot!(P1, sol_tord_ois.time, sol_tord_ois.y ./ 2,
      color = myorange,
      linewidth = 2,
      label = "oiseaux \$y/2\$",)
```
\

On observe ici des *bifurcations dynamiques* avec le passage de la population de tordeuse d'une branche d'équilibre stable à l'autre, qui créé un comportement de type cycle d'hysteresis. La situation se comprend bien sur le diagramme de bifurcations $(y, x)$. On retrace le diagramme de bifurcations.

```{julia}
#| code-fold: true
using Symbolics, Polynomials

@variables X
D = Differential(X)

# lieu des équilibres positifs
Y = r/(α*X)*(1-X/K)*(h^2+X^2)

# dénominateur de la dérivée
dnumerator = Symbolics.arguments(Symbolics.value(simplify(expand_derivatives(D(Y)))))[1]

# on récupère les coefficients X^k du polynôme
coefs_dict = Symbolics.value(dnumerator).dict
dd = Dict(Symbolics.degree(first(kv)) => kv[2] for kv ∈ coefs_dict)
# on rajoute dans le dictionnaire le coefficient constant
dd[0] = substitute(dnumerator, Dict(X=>0))

# on définit le polynôme à partir du dictionnaire
dnumpoly = SparsePolynomial(dd, :X)

# on calcule les racines en filtrant les racines entre 0 et K via une fonction anonyme s-> K > s > 0
droots = filter(s -> K > s > 0, roots(dnumpoly))

# vecteur pour le tracé du diagramme de bifurcation
xplot1 = 0.08:.01:droots[1]
xplot2 = droots[1]:.01:droots[2]
xplot3 = droots[2]:.01:K
yeq1 = r.*(1 .-xplot1./K) ./ (α.*xplot1).*(h^2 .+xplot1.^2)
yeq2 = r.*(1 .-xplot2./K) ./ (α.*xplot2).*(h^2 .+xplot2.^2)
yeq3 = r.*(1 .-xplot3./K) ./ (α.*xplot3).*(h^2 .+xplot3.^2)

# diagramme de bifurcations
Pbif = plot(yeq1, xplot1,
            linewidth = 2,
            color = mygreen,
            label = "équilibres stables",
            legend = :left,
            xlabel = "population d'oiseaux \$y\$",
            ylabel = "population de tordeuses \$x\$",
            title = "Diagramme de bifurcations pour le modèle de tordeuses",
            margin = .5Plots.cm,
            topmargin = 1Plots.cm)

plot!(Pbif, yeq2, xplot2,
      linewidth = 2,
      color = myred,
      label = "équilibres instables")

plot!(Pbif, yeq3, xplot3,
      linewidth = 2,
      color = mygreen,
      label = "")

plot!(Pbif, [0, maximum(yeq1)], [0, 0], 
      color = myred,
      lw = 2,
      label = "")
```

On trace sur ce diagramme la trajectoire simulée plus haut :
```{julia}
#| output: true
plot!(Pbif, sol_tord_ois.y, sol_tord_ois.x,
      color = myblue,
      linewidth = 2,
      linealpha = 0.5,
      label = "trajectoire")
```

## Le modèle de Lotka Volterra